{"version":3,"sources":["statecharts/impl.cljc"],"mappings":";AAcA,wCAAA,xCAAMA,wFAAsBC;AAA5B,AACE,GAAI,AAACC,qBAAKD;AACRA;;AADF,kDAAA,wDAEWA;;;AAEb,qCAAA,rCAAME,kFAAmBF;AAAzB,AACE,oBACE,iBAAAG,oBAAK,AAACC,wBAAQJ;AAAd,AAAA,GAAAG;AACK,OAACE,eAAKJ,qBAAKD;;AADhBG;;;AAEA,OAACG,6CAAKP,sCAAqBC;;AAH7B,GAKE,AAACC,qBAAKD;AALR,0FAMGA;;AANH,AAAA,0FAAA,2CAAA,wDASYA;;;;;AAEd,iCAAA,jCAAMO,0EAAeP;AAArB,AACE,GAAI,AAACI,wBAAQJ;AACXA;;AADF,0FAEGA;;;AAEL,+BAAA,/BAAMQ,sEAAaR;AAAnB,AACE,GAAI,AAACC,qBAAKD;AACRA;;AADF,kDAAA,qDAESA;;;AAEX,6BAAA,mFAAA,yDAAA,2CAAA,qGAAA,mFAAA,5YAAKS,kRACmBF,4KAChBG;AAER;;;4BAAA,mFAAA,yEAAA,mFAAA,3QAAKC,+JAGFC,qKACSA;AAEZ,gCAAA,mFAAA,yDAAA,2CAAA,yGAAA,mFAAA,mDAAA,2CAAA,yDAAA,aAAA,mFAAA,wDAAA,2CAAA,6DAAA,+CAAA,mFAAA,uDAAA,2CAAA,6DAAA,aAAA,mFAAA,uFAAA,mFAAA,2DAAA,2CAAA,6DAAA,x/CAAKC,qRACmBX,kiBAEMS,saACID,wSACHD;AAE/B,2BAAA,mFAAA,sDAAA,2CAAA,6DAAA,5QAAKK,yRACsBL;AAE3B,0BAAA,mFAAA,oDAAA,2CAAA,6DAAA,zQAAKM,sRACqBN;AAE1B,qCAAA,mFAAA,qEAAA,mFAAA,hRAAKO,wKAEFC,0JAEKP;AAER;;;kCAAA,mFAAA,0GAAA,mFAAA,qEAAA,vXAAKQ,4KAEKN,yBAASD,6JAAcM;AAMjC,2BAAA,mFAAA,9GAAKE,8JACEP,yBAASM;AAEhB,iCAAA,mFAAA,gDAAA,2CAAA,6DAAA,aAAA,mFAAA,5WAAKE,qaAEOD,yBAAQN;AAEpB,6BAAA,mFAAA,2DAAA,2CAAA,6DAAA,nRAAKQ,gSACwBV;AAE7B,sCAAA,tCAAMW,oFAAoBC;AAA1B,qFAKO,AAACC,sDAAO,WAAAC,tJAIR,oDAAA,7CAACQ;AAJO,AAAA,IAAAP,aAAAD;SAAA,AAAAE,4CAAAD,WAAA,IAAA,hEAAME;aAAN,AAAAD,4CAAAD,WAAA,IAAA,pEAASG;AAAT,AAGO,mDAAA,WAAAC,vDAACC;AAAD,AAAM,qDAAAD,iBAAA,/DAACE,sHAAeJ;sCAFtBC,nCACA3B,AACA;qDAJfqB;;AAaP,8CAAA,9CAAMW,oGAA4BlC;AAAlC,AACE,GAAI,AAACC,qBAAKD;AACR,OAACsB,oCAAmBtB;;AACpBA;;;AAEJ,uCAAA,mFAAA,mDAAA,2CAAA,yDAAA,aAAA,mFAAA,kGAAA,mFAAA,wDAAA,2CAAA,6DAAA,+CAAA,mFAAA,uDAAA,2CAAA,6DAAA,aAAA,mFAAA,uFAAA,mFAAA,2DAAA,2CAAA,6DAAA,p5CAAKmC,waAEMnB,2SACkBL,saACID,wSACHD;AAE9B,wCAAA,mFAAA,yDAAA,2CAAA,/NAAK2B,6RACmBF,oDACrBC;AAEH,2BAAA,mFAAA,sDAAA,2CAAA,6DAAA,5QAAKE,yRACsBD;AAE3B,0CAAA,mFAAA,0DAAA,2CAAA,6DAAA,/RAAKE,4SACuBzB;AAE5B,gDAAA,hDAAM0B,wGAA8BC;AAApC,AACE,IAAMC,SAAO,AAAA,wFAASD;AAAtB,AACE,GAAA,AAAAE,cAAQD;AACND;;AACA,2DAAA,gEAAA,pHAACG,+CAAOH,qDAASI,+EAAkBH;;;AAEzC,0BAAA,mFAAA,qDAAA,2CAAA,6DAAA,aAAA,mFAAA,qDAAA,/ZAAKI;AAGL,4BAAA,mFAAA,0DAAA,2CAAA,6DAAA,2CAAA,qFAAA,oFAAA,mDAAA,2CAAA,yDAAA,KAAA,8DAAA,2CAAA,sZAAA,mFAAA,yDAAA,2CAAA,6DAAA,aAAA,mFAAA,kFAAA,mFAAA,mDAAA,6GAAA,mFAAA,4DAAA,2CAAA,6DAAA,aAAA,mFAAA,kFAAA,mFAAA,mDAAA,qIAAA,mFAAA,kFAAA,mFAAA,mDAAA,xvFAAKC,iyBAI2C,AAACC,6CACAR,8CACAS,gEAC3BX,yBACAvB,yBACAC,wBACAuB,wCACAlB,+BACAC,2BAEAwB,qaAEUjC,4pBAEAA,gbACpBA;AAMZ,kCAAA,mFAAA,qEAAA,2CAAA,6DAAA,aAAA,mFAAA,mDAAA,2CAAA,yDAAA,aAAA,mFAAA,8DAAA,2CAAA,6DAAA,aAAA,mFAAA,mDAAA,mFAAA,kFAAA,mFAAA,6EAAA,2CAAA,6DAAA,8CAAA,mFAAA,8EAAA,2CAAA,6DAAA,tpDAAKqC,0jCAKQC,kTAC6BtC,uTACAA;AAE1C,6BAAA,oFAAA,mDAAA,2CAAA,8DAAA,2CAAA,qPAAA,mFAAA,mFAAA,mFAAA,2DAAA,2CAAA,6DAAA,0CAAA,mFAAA,gEAAA,2CAAA,6DAAA,aAAA,mFAAA,mQAAA,mFAAA,yDAAA,2CAAA,6DAAA,+CAAA,mFAAA,4DAAA,2CAAA,6DAAA,3mEAAKuC,+WACwB,AAACJ,6CACAK,iDACAJ,gEAC3BC,qKACKrC,oSACsBsC,0aACOG,qDAClCjC,+BACAiB,yBACAvB,yBACAC,wBACAM,2BAEAwB,yRAC0BC,sSACCA;AAE9B,AAAA,AAEA;;;2BAAA,3BAAMQ,8DAEHC;AAFH,AAGE,IAAMC,YAAU,AAACC,gDAAUN,2BAAUI,KACnB,6JAAA,2CAAA,qDAAA,7PAACG,mHACAC;AAFnB,AAIE,oBAAU,AAACC,kDAAYT,2BAAUK;AAAjC;AAAA,AAEE,IAAMK,eAAO,AAACC,mDAAqB,AAACC,iDAAWZ,2BAAUK;IACnDQ,mBAAW,AAAA,gFAAKR;IAChBS,YAAI,iBAAAC,WAAA;AAAA,AAAA,oBACEF;AACA,QAAAE,SAAA,2DAAoBF;;AAFtBE;;;AAFV,AAMK,AAACC,aAAgBF,8CAAQJ,rBACA,AAACO,fACD,AAACC;;AAC7B,MAAO,AAACC,gDAAQL,UAAIJ;;;AACxB,CAACU,kEAAAA,6EAAAA,bAAiBf,yDAAAA;;AAClBA;;AAIJ,AAAA,AAAA,AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,AAAA,CAAA,AAAA,iFAAA,WAAAgB,mBAAAC,/GAAWgE;;AAAX,AAAA,IAAAjE,yBAAA;AAAA,AAAA,OAAAA,8DAAAC,gBAAA;;;AAAA,CAAA,AAAA,iFAAA,WAAAC,mBAAAC,OAAAC,tHAAW6D;;AAAX,AAAA,IAAA/D,yBAAA;AAAA,AAAA,IAAAG,WAAAF;IAAAE,eAAA,EAAA,CAAAA,oBAAAC,oBAAA,AAAAD,aAAA;AAAA,AAAA,QAAAA;KAAA;AAAAE;;;;AAAA,OAAAC,4CAAAC,gBAAAN,OAAAC;;;;;AAAA,CAAA,AAAA,sFAAA,WAAAM,mBAAAC,gBAAAC,pIAAWqD;;AAAX,AAAA,IAAAvD,yBAAA;AAAA,AAAA,OAAAG,+CAAA,WAAAC,kBAAAC;AAAA,AAAA,IAAAC,aAAAD;IAAAE,kBAAA,AAAA9D,4CAAA6D,WAAA,IAAA;IAAAE,kBAAA,AAAA/D,4CAAA6D,WAAA,IAAA;AAAA,AAAA,QAAAL,gDAAAA,8CAAAG,kBAAAG,gBAAAC,mBAAAP,0BAAAG,kBAAAG,gBAAAC;GAAAN,mBAAAF;;;AAAA,CAAA,AAAA,6FAAA,WAAAS,mBAAAC,qBAAAC,hJAAW4C;;AAAX,AAAA,IAAA9C,yBAAA;AAAA,AAAA,IAAAG,wBAAA,WAAAC;AAAA,AAAA,OAAAC,+BAAAJ,qBAAA,oBAAA,GAAA,IAAA,GAAAC,mBAAAE;;AAAA,AAAA,OAAAC,+BAAAJ,qBAAAE,sBAAA,uCAAA,KAAA,IAAAD,mBAAA,AAAAI,+CAAA,mFAAA,KAAAC,2BAAA,KAAA,EAAA,IAAA,AAAAA,sCAAA,CAAA,6CAAAnB,UAAA,eAAAE;;;AAAA,CAAA,AAAA,qFAAA,WAAAkB,hGAAWsC;;AAAX,AAAA,IAAAtC,eAAA;AAAA,AAAA,YAAAC,qBAAA,IAAAD,aAAA,EAAA,mFAAA,qDAAA,kBAAAlB,iBAAA,AAAAoB,oBAAApB,iBAAA,AAAAqB;;;AAAA,CAAA,AAAA,6EAAA,WAAAC,xFAAWkC;;AAAX,AAAA,IAAAlC,yBAAA;AAAA,AAAAC;;;AAAA,CAAA,AAAA,mFAAA,WAAAC,9FAAWgC;;AAAX,AAAA,IAAAhC,yBAAA;AAAA,AAAA,+CAAA1B,SAAAyB,cAAAvB,gBAAAyB,1EAAW+B;;;AAAX,CAAA,AAAA,iFAAA,WAAA9B,5FAAW8B;;AAAX,AAAA,IAAA9B,yBAAA;AAAA,AAAA,QAAA,IAAA,AAAAC,gBAAA3B;;;AAAA,CAAA,AAAA,6EAAA,WAAA4B,xFAAW4B;;AAAX,AAAA,IAAA5B,yBAAA;AAAA,AAAA,IAAAC,kBAAAJ;AAAA,AAAA,GAAA,GAAA,CAAAI,mBAAA;AAAAA;;AAAA,IAAAA,sBAAA,AAAA,WAAAC;AAAA,AAAA,QAAA,aAAA,AAAAC,8BAAAD;GAAAF;AAAA,AAAA,CAAAH,gBAAAI;;AAAAA;;;;AAAA,CAAA,AAAA,+EAAA,WAAAG,UAAAC,pGAAWuB;;AAAX,AAAA,IAAAxB,gBAAA;AAAA,AAAA,SAAA,GAAA,CAAAC,cAAA,aAAA,EAAA,CAAA,AAAAD,8BAAA,AAAAC,6BAAA,EAAA,AAAAC,6CAAA,AAAAF,gBAAA,AAAAC,mBAAA,AAAAC,6CAAA,AAAAF,uBAAA,AAAAC;;;AAAA,CAAA,AAAA,8EAAA,WAAAE,mBAAAC,5GAAWoB;;AAAX,AAAA,IAAArB,yBAAA;AAAA,AAAA,GAAA,AAAAE,0BAAA,iFAAA,iEAAAD;AAAA,OAAAE,+CAAA,AAAAC,qBAAA,AAAAvF,6CAAA,mCAAAmF,wBAAAZ,eAAAa;;AAAA,+CAAAtC,SAAAyB,cAAA,AAAAiB,oBAAA,AAAAF,+CAAAtC,gBAAAoC,kBAAA,/JAAWoB;;;;AAAX,CAAA,AAAA,mGAAA,WAAAf,mBAAA/C,jIAAW8D;;AAAX,AAAA,IAAAf,yBAAA;AAAA,AAAA,IAAAC,WAAAhD;IAAAgD,eAAA,EAAA,CAAAA,oBAAA7C,oBAAA,AAAA6C,aAAA;AAAA,AAAA,QAAAA;KAAA;AAAA;;;;AAAA,OAAAL,0BAAArC,gBAAAN;;;;;AAAA,CAAA,AAAA,qFAAA,WAAAiD,mBAAAC,gBAAA1B,nIAAWsC;;AAAX,AAAA,IAAAb,yBAAA;AAAA,AAAA,IAAAE,cAAAC;IAAAC,cAAAH;AAAA,AAAA,oBAAA,CAAAC,4CAAAA,0CAAA,6CAAAE,eAAAF,sBAAA,6CAAAE;AAAA,+CAAA7B,SAAAK,cAAAvB,gBAAA,1EAAWwD;;AAAX,+CAAA1D,SAAAyB,cAAA,AAAAxE,8CAAAiD,gBAAA4C,gBAAA1B,UAAA,lJAAWsC;;;;AAAX,CAAA,AAAA,+EAAA,WAAAR,1FAAWQ;;AAAX,AAAA,IAAAR,yBAAA;AAAA,AAAA,OAAAC,cAAA,AAAAjC,+CAAA,mFAAA,KAAAkC,mBAAA,6CAAApD,SAAA,eAAAE;;;AAAA,CAAA,AAAA,sFAAA,WAAAmD,mBAAAjC,pHAAWsC;;AAAX,AAAA,IAAAL,yBAAA;AAAA,AAAA,+CAAArD,SAAAoB,SAAAlB,gBAAAyB,rEAAW+B;;;AAAX,CAAA,AAAA,mFAAA,WAAAJ,mBAAAC,jHAAWG;;AAAX,AAAA,IAAAJ,yBAAA;AAAA,AAAA,GAAA,AAAAjI,wBAAAkI;AAAA,OAAAD,kEAAA,AAAAE,eAAAD,oBAAA,KAAA,AAAAC,eAAAD,oBAAA;;AAAA,OAAAjD,+CAAAmD,gBAAAH,uBAAAC;;;;AAAA,CAAA,AAAAG,8CAAA;AAAA,AAAA,AAAA;;;AAAA,CAAA,AAAAA,oDAAA;;AAAA,CAAA,AAAAA,yDAAA,WAAAC;AAAA,AAAA,YAAAC,eAAA,KAAA,qCAAA,KAAA,IAAA;;;AAAA,CAAA,AAAAF,4DAAA,WAAAC,mBAAAE;AAAA,AAAA,OAAAC,iBAAAD,qBAAA;;;AAAA;;;0CAAA,1CAAWM,4FAAmBnE;AAA9B,AAAA,YAAA0D,qCAAA,KAAA,KAAA,ZAA8B1D;;;AAA9B;;;6CAAA,qDAAA+D,lGAAWK;AAAX,AAAA,IAAAJ,uBAAA,iBAAAC,WAAA,AAAAzB,+CAAAuB,SAAA;AAAA,AAAA,GAAA,AAAAG,wBAAAH;AAAA,OAAA7G,6CAAA,mCAAA+G;;AAAAA;;;AAAA,AAAA,YAAAP,mCAAA,AAAA,2EAAAK,UAAA,KAAA,AAAArB,oBAAAsB,sBAAA;;;AAAAN,AAEA;;;0BAAA,1BAAMW,4DAEHC;AAFH,AAGE;mCAAOC;AAAP,AACE,YAAAb,yFAAA,KAAA,KAAA,hEAAoB,AAACc,8CAAMF,EAAEC;;;IADxBA;;;;EAAAA;;oCAAAA;;;IAAAA;0BAAAA;;;;;;;AAGT,0CAAA,1CAAOE,4FAAkBC;AAAzB,AACE,SAAK,AAACxJ,qBAAKwJ,aACN,AAACtC,6CAAE,iBAAAuC,WAAQ,AAAA,uFAASD;AAAjB,AAAA,GAAA,CAAAC,YAAA;AAAA;;AAAA,2BAAAA,pBAAyBC;;KAA5B;;AAEP,2CAAA,mDAAAC,gCAAAC,9HAAOI,uGAEJG,MACAC;AAHH,AAAA,IAAAP,aAAAF;IAAAE,iBAAA,AAAAC,4BAAAD;WAAAA,PACQI;gBADR,AAAAlF,4CAAA8E,eAAA,vEACoBK;IADpBH,aAAAH;IAAAG,iBAAA,AAAAD,4BAAAC;sBAAAA,lBAIQM;aAJR,AAAAtF,4CAAAgF,eAAA,pEAI+BP;YAJ/B,AAAAzE,4CAAAgF,eAAA,nEAIsCO;kBAJtC,AAAAvF,4CAAAgF,eAAA,zEAI4CQ;AAJ5C,AAKE,oBAAUL;AAAV;AAAA,AACE,MAAO,gDAAA,2CAAA,2CAAA,tIAAC7F,+LAEUgG;;;AACpB,GACE,oDAAA,pDAACnD,6CAAEsC;AACH,IAAMe,kBAAY,EAAI,AAACvJ,qBAAKuJ,cACRA,YACA,CAACA,4CAAAA,oEAAAA,1BAAYJ,gDAAAA,1CAAMC,gDAAAA;AAFvC,AAGE,OAACI,6BAAeN,UAAUI,MAAMC;;AALpC,GAOE,oDAAA,pDAACrD,6CAAEsC;AACH,OAACiB,+BAAiBP,UAAUI;;AAR9B,AAWE,MAAO,AAACjG,gDAAQ,CAAA,uEAAgCmF,kBAAQa;;;;;AAE5D,AAAA;;;2BAAA,mCAAAK,9DAAOE;AAAP,AAAA,IAAAD,WAAA,AAAA;AAAA,AAAA,QAAAA;KAAA;AAAA,OAAAC,uDAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAA,CAAA,UAAA;;;KAAA;AAAA,OAAAA,uDAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAA,CAAA,UAAA;;;;AAAA,MAAA,KAAAC,MAAA,CAAA,8DAAA,AAAA;;;;;AAAA,CAAA,yDAAA,zDAAOD,oEAEHI,IAAIb,MAAMG;AAFd,AAGG,8EAAA,vEAACW,uDAAQD,IAAIb,MAAMG;;;AAHtB,CAAA,yDAAA,2BAAAQ,pFAAOF,oEAIHI,IAAIb,MAAMG;AAJd,AAAA,IAAAS,aAAAD;IAAAC,iBAAA,AAAAjB,4BAAAiB;YAAA,AAAAhG,4CAAAgG,eAAA,nEAI4BG;AAJ5B,AAKG,OAAC9F,+CAAO,WAAK+F,UAAU3B;AAAf,AACE,GAAI,AAACD,wCAAiBC;AACpB,AACE,AAACQ,yCAAwBgB,IAAIG,UAAUb,MAAMd;;AAC7C2B;;AACF,IAAMC,SAAO,CAAC5B,uCAAAA,wDAAAA,nBAAO2B,oCAAAA,1BAAUb,oCAAAA;AAA/B,AACE,GAAI,mBAAW9B,lBAAkB4C;AAC/B,OAAKA;;AACLD;;;GACR,iBAAAE,WAAQlB;AAAR,AAAA,GACE,AAAC1H,cAAIyI;AACL,sDAAAG,SAAA,xDAAC/D;;AAFH+D;;KAGA,AAAA,0FAAWlB;;;AAjBtB,CAAA,mDAAA,nDAAOS;;AAAP,AAmBA;;;;;;;;+BAAA,mFAAA,mDAAA,2CAAA,yDAAA,aAAA,mFAAA,kDAAA,mFAAA,9eAAKU,qiBAQW3K,yCACbQ,+BACAN,yBACAC;AAEH,mCAAA,nCAAOyK,8EAAWhJ;AAAlB,AACE,IAAAiJ,WAAQ,AAAA,mFAAOjJ;AAAf,AAAA,GAAA,CAAAiJ,YAAA;AAAA;;AACQ,oDAAAA,SAAA,tDAACtE;;;AAEX,mCAAA,nCAAOuE,8EAAWlJ;AAAlB,AACE,sCAAA,/BAAC8E,0BAAU9E;;AAEb,iCAAA,jCAAOmJ,0EAASnJ;AAAhB,AACE,SAAK,AAACE,cAAI,AAAC8I,iCAAUhJ,YAChB,GAAK,AAACkJ,iCAAUlJ;;AAEvB;;;;;;;mCAAA,nCAAMoJ,8EAMHC;AANH,AAOE,IAAMC,aAAW,AAACC,6BAAa,AAACC,eAAKH;IAC/BI,MACS,AAAC5G,+CACC,gBAAA6G,LAAKE;AAAL,AAAA,IAAAD,aAAAD;WAAA,AAAAvK,4CAAAwK,WAAA,IAAA,lEAAW3J;QAAX,AAAAb,4CAAAwK,WAAA,IAAA,/DAAgBE;AAAhB,AACE,oBAAI,AAACb,iCAAUhJ;AACb,IAAM8J,aAAW,AAACC,2BAAWX,iCACA,AAAA,0FAAUpJ;AADvC,AAEE,GAAI,OAAA,NAAO6J;AAAX,0FAEGC;;AAGD,OAAC3J,+CAAOyJ,KACA,KAAA,JAAKC,SACL,WAAKG;AAAL,AAAA,uDACGA,GAAGF;;;;AAClB,OAACG,6CAAKL,KAAK,AAAA,gFAAK5J;;oCAftBsJ,jCACA;AAFf,AAkBE,OAACY,8BAAcT;;AAEnB,AAAA,kCAAA,0CAAAtB,5EAAMqC;AAAN,AAAA,IAAAL,qBAAA;AAAA,AAAA,IAAAC,0BAAA,AAAA;AAAA,AAAA,IAAAC,wBAAA;;AAAA,AAAA,GAAA,CAAAA,wBAAAD;AAAA,AAAA,AAAAD,wBAAA,CAAA,UAAAE;;AAAA,eAAA,CAAAA,wBAAA;;;;AAAA;;;;AAAA,IAAAC,uBAAA,EAAA,CAAA,MAAA,AAAAH,4BAAA,AAAA,KAAAI,qBAAA,AAAAJ,yBAAA,KAAA,IAAA,OAAA;AAAA,AAAA,OAAAK,qEAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAAF;;;AAAA,AAAA,CAAA,uEAAA,iBAAAG,xFAAMD,kFAAgBhN,EAAE0N,EAAE3I;AAA1B,AAAA,IAAAmI,aAAAD;IAAAC,iBAAA,AAAAnD,4BAAAmD;UAAAA,NAA4CS;AAA5C,AACE,GAAM,MAAA,LAAM3N;AAAZ,AACE,MAAO,AAACsE,gDAAQ,CAAA,iCAAA,lBAAoB,AAACsJ,eAAKF,mDAAO3I,aAAG,AAAC/C,8CAAM2L,IAAID,EAAE3I;;AADnE;;;;AADF,CAAA,0DAAA,1DAAMiI;;AAAN;AAAA,CAAA,oDAAA,WAAAG,/DAAMH;AAAN,AAAA,IAAAI,WAAA,AAAAC,gBAAAF;IAAAA,eAAA,AAAAG,eAAAH;IAAAI,WAAA,AAAAF,gBAAAF;IAAAA,eAAA,AAAAG,eAAAH;IAAAK,WAAA,AAAAH,gBAAAF;IAAAA,eAAA,AAAAG,eAAAH;AAAA,AAAA,IAAAM,qBAAA;AAAA,AAAA,OAAAA,wDAAAL,SAAAG,SAAAC,SAAAL;;;AAAA,AAKA;;;;;;;;;;;;;;;;;;;;;;;;;;;;kCAAA,lCAAMU,4EA2BHC,KAAKjM;AA3BR,AA4BE,IAAMiM,WAAK,AAACC,gCAAgBD;IACtBE,SAAO,AAACC,cAAI,AAACC,kDAAUJ;AAD7B,AAEE,GACE,WAAA,VAAMjM;AACNiM;;AAFF,GAIE,mBAAAhJ,lBAAUjD;AACV,OAAC4K,6CAAKuB,OAAOnM;;AALf,GAOE,GAAK,AAACsM,4BAAYtM;AAClB,MAAO,gDAAA,qBAAA,2CAAA,hHAACyC,wKAAsCzC;;AARhD,GAUE,qEAAA,rEAACsF,6CAAE,AAACkG,gBAAMxL;AACV,OAACoM,cAAI,AAACX,eAAKzL;;AAXb,GAaE,qEAAA,rEAACsF,6CAAE,AAACkG,gBAAMxL;AACV,OAACoM,cAAI,AAAChI,+CAAO6H,SAAK,6CAAA,7CAACM,iDAAOvM;;AAd5B,AAiBE,OAACoM,cAAI,AAAChI,+CAAO+H,OAAOnM;;;;;;;;AAE1B,0CAAA,1CAAMwM,4FAAkBxM;AAAxB,AACE,SAAK,AAACsM,4BAAYtM,aACb,qEAAA,rEAACsF,6CAAE,AAACkG,gBAAMxL;;AAEjB,oCAAA,pCAAMyM,gFAAYC,OAAMC;AAAxB,AACE,IAAMC,IAAE,AAAC7H,gBAAM2H;AAAf,AACE,SAAK,CAAIE,KAAE,AAAC7H,gBAAM4H,aACb,AAACrH,6CAAEoH,OAAM,AAACG,6CAAKD,EAAED;;AAE1B;;;;;;;;;;;;;;;;;;;;oDAAA,pDAAMG,gHAmBHC,QAAQC;AAnBX,AAAA;;AAqBA,mDAAA,nDAAMC,8GAA2BD;AAAjC,AACE,OAACE,mBAAQ,eAAA,WAAAC,1BAAC3O;AAAD,AAAO,sDAAA2O,iBAAA,mFAAA,gDAAA,nMAACC;GAA4BJ;;AAE/C,AAAA;;;gCAAA,wCAAAlE,xEAAOuE;AAAP,AAAA,IAAAvC,qBAAA;AAAA,AAAA,IAAAC,0BAAA,AAAA;AAAA,AAAA,IAAAC,wBAAA;;AAAA,AAAA,GAAA,CAAAA,wBAAAD;AAAA,AAAA,AAAAD,wBAAA,CAAA,UAAAE;;AAAA,eAAA,CAAAA,wBAAA;;;;AAAA;;;;AAAA,IAAAC,uBAAA,EAAA,CAAA,MAAA,AAAAH,4BAAA,AAAA,KAAAI,qBAAA,AAAAJ,yBAAA,KAAA,IAAA,OAAA;AAAA,AAAA,OAAAuC,mEAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAApC;;;AAAA,AAAA,CAAA,qEAAA,rEAAOoC,gFAEJnK,EAAEsE,EAAIC;AAFT,AAGE,OAACC,8CAAM+F,iBAAOvK,EAAE,sBAAA,rBAAK,AAAC6B,gBAAM7B,UAAIsE,EAAEC;;;AAHpC,CAAA,wDAAA,xDAAO4F;;AAAP;AAAA,CAAA,kDAAA,WAAAC,7DAAOD;AAAP,AAAA,IAAAE,WAAA,AAAA/B,gBAAA8B;IAAAA,eAAA,AAAA7B,eAAA6B;IAAAE,WAAA,AAAAhC,gBAAA8B;IAAAA,eAAA,AAAA7B,eAAA6B;AAAA,AAAA,IAAA1B,qBAAA;AAAA,AAAA,OAAAA,wDAAA2B,SAAAC,SAAAF;;;AAAA,AAKA,+BAAA,mFAAA,yDAAA,3KAAKI;AAGL,2BAAA,mFAAA,mDAAA,mFAAA,0FAAA,mFAAA,gDAAA,2CAAA,6DAAA,aAAA,mFAAA,yDAAA,0DAAA,mEAAA,mFAAA,qDAAA,qDAAA,mFAAA,yDAAA,6DAAA,8EAAA,mFAAA,sDAAA,2CAAA,6DAAA,aAAA,2DAAA,mFAAA,oDAAA,2CAAA,6DAAA,aAAA,x1DAAKC,ySAEKD;AAMV,yBAAA,mFAAA,mDAAA,2CAAA,yDAAA,aAAA,mFAAA,yDAAA,2CAAA,6DAAA,kDAAA,mFAAA,wDAAA,2CAAA,6DAAA,kDAAA,mFAAA,yDAAA,2CAAA,6DAAA,kDAAA,mFAAA,uDAAA,2CAAA,6DAAA,aAAA,mFAAA,yDAAA,kEAAA,mFAAA,2DAAA,2CAAA,6DAAA,aAAA,mFAAA,yDAAA,79DAAKE,ihBAEwBF,qSACAA,sSACAA;AAI7B,mCAAA,mFAAA,tHAAKG,wKACGH;AAER,iCAAA,jCAAMI,0EAAenN;AAArB,AACE,IAAMoN,OAAK,0DAAA,8DAAA,0CAAA,6DAAA,AAAA,7MACE,AAACpE,iCAAUhJ,uEAGX,AAACkJ,iCAAUlJ;;AAJxB,AASE,0DAAA,nDAACR,8CAAMQ,0DAAWoN;;AAEtB,AAAA,gCAAA,wCAAAjF,xEAAMmF;AAAN,AAAA,IAAAD,WAAA,AAAA;AAAA,AAAA,QAAAA;KAAA;AAAA,OAAAC,4DAAA,CAAA,UAAA,MAAA,CAAA,UAAA;;;KAAA;AAAA,OAAAA,4DAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAA,CAAA,UAAA;;;;AAAA,MAAA,KAAAhF,MAAA,CAAA,8DAAA,AAAA;;;;;AAAA,CAAA,8DAAA,9DAAMgF,yEACFC,KAAKC;AADT,AAEG,6EAAA,tEAACC,4DAAaF,KAAKC;;;AAFtB,CAAA,8DAAA,9DAAMF,yEAGFC,KAAKC,KAAKE;AAHd,AAKG,IAAM1N,OAAK,iBAAMwN,WAAK,AAACjC,gCAAgBiC;IACtBxN,OAAK,AAAC6C,+CACC,WAAK8K,aAAazC;AAAlB,AACE,oBACE,AAAClC,iCAAU2E;AACX,mEAAA,mFAAA,/IAAClB,+CAAOkB,4JAAuBzC;;AAFjC,GAIE,AAAChC,iCAAUyE;AACX,mEAAA,mFAAA,/IAAClB,+CAAOkB,yJAAsBzC;;AALhC,AAQE,yBAAA,lBAAC0C;;;;GACLL,KACAC;AAbb,AAcE,IAAAK,WAAQ7N;IAAR6N,eAAA,EAAA,CAAAA,YAAA,OAAA,KACQ,+BAAAA,/BAACV;AADT,AAAA,GAAA,CAAAU,gBAAA;AAAA;;AAEQ,qDAAAA,aAAA,3DAACrO,gHAAYgO;;;AAhBlC,AAiBE,oBAAIE;AACF1N;;AACA,IAAA8N,WAAQ9N;AAAR,AAAA,GAAA,CAAA8N,YAAA;AAAA;;AACQ,6BAAAA,SAAA,mFAAA,gDAAA,sDAAA,oDAAA,qDAAA,jUAACC;;;;;AAzBhB,CAAA,wDAAA,xDAAMT;;AAAN,AA2BA,oCAAA,pCAAMU,gFAAeC;AAArB,AACE,IAAAC,WAAqB,AAAC3C,gCAAgB0C;IAAtCE,aAAAD;IAAAE,aAAA,AAAA1I,cAAAyI;IAAAE,eAAA,AAAAxD,gBAAAuD;IAAAA,iBAAA,AAAAtD,eAAAsD;WAAAC,PAAQI;WAARL,PAAeM;aAAf,TACOC;IACAlF,MAAI,AAACmF;AAFZ,AAAA,IAAAV,eAAAA;IACOS,aAAAA;IACAlF,UAAAA;;AAFP,AAAA,IAAA6E,aAAAJ;IAAAK,aAAA,AAAA7I,cAAA4I;IAAAE,eAAA,AAAA3D,gBAAA0D;IAAAA,iBAAA,AAAAzD,eAAAyD;eAAAC,XAAQC;eAARF,XAAeG;IACRC,aAAAA;IACAlF,UAAAA;AAFP,AAGE,GACE,qBAAAnH,pBAAUmM;AACV,IAAMI,UAAQ,AAAC5E,6CAAK0E,WAAOF;IACrBhF,UAAI,AAACQ,6CAAKR,QAAIoF;AADpB,AAEE,GAAI,AAACnJ,cAAIgJ;AACP,eAAOA;eAAKG;eAAQpF;;;;;;AACpBA;;;AANN,GAQE,AAAChM,qBAAKgR;AACN,AACE,GAAQ,AAACK,uBAAOJ;AAAhB;AAAA,AAAA,MAAA,KAAApG,MAAA,CAAA,kBAAA,sDAAA,KAAA;;;AAEA,OAAC7I,6CAAKgK,QAAI,AAACzK,sDAAO;kBAAA+P;AAAA,AAAA,IAAAC,aAAAD;QAAA,AAAA5P,4CAAA6P,WAAA,IAAA,/DAAM9D;QAAN,AAAA/L,4CAAA6P,WAAA,IAAA,/DAAQzM;AAAR,AACE,IAAMoM,aAAO,AAAC1E,6CAAK0E,WAAOzD;AAA1B,AACE,OAAC+D,eAAKN,WACA,4CAAA,5CAACpP;kBAAD2P;AAAA,AAAM,+DAAAA,xDAACzP,6CAAKkP;;CAAU,CAACX,kEAAAA,qEAAAA,LAAczL,iDAAAA;;mDAC/CkM;;AAhBtB;;;;;;AAkBJ,AAAA,4CAAA,oDAAAtG,hGAAMgH;AAAN,AAAA,IAAAhF,qBAAA;AAAA,AAAA,IAAAC,0BAAA,AAAA;AAAA,AAAA,IAAAC,wBAAA;;AAAA,AAAA,GAAA,CAAAA,wBAAAD;AAAA,AAAA,AAAAD,wBAAA,CAAA,UAAAE;;AAAA,eAAA,CAAAA,wBAAA;;;;AAAA;;;;AAAA,IAAAC,uBAAA,EAAA,CAAA,MAAA,AAAAH,4BAAA,AAAA,KAAAI,qBAAA,AAAAJ,yBAAA,KAAA,IAAA,OAAA;AAAA,AAAA,OAAAgF,+EAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAA7E;;;AAAA,AAAA,CAAA,iFAAA,sBAAA8E,vGAAMD,4FAQH1G,IAAIwF;AARP,AAAA,IAAAoB,aAAAD;IAAAC,iBAAA,AAAA9H,4BAAA8H;WAAAA,PAUQK;wBAVR,AAAAlN,4CAAA6M,eAAA,/EASWI;AATX,AAWE,IAAMxB,aAAO,AAAC1C,gCAAgB0C;AAA9B,AACE,IAAM0B,QAAM,2FAAA,3FAAC1F,6CAAK,AAAC+D,kCAAcC;IAG3B5B,QAAM,6CAAA,WAAAuD,xDAAC9R;AAAD,AAAO,uEAAA8R,hEAACnC,4DAAahF;GAAOkH;AAHxC,AAIE,oBAAIF;AACFE;;AACAtD;;;;AAlBR,CAAA,oEAAA,pEAAM8C;;AAAN;AAAA,CAAA,8DAAA,WAAAG,zEAAMH;AAAN,AAAA,IAAAI,WAAA,AAAA1E,gBAAAyE;IAAAA,eAAA,AAAAxE,eAAAwE;IAAAE,WAAA,AAAA3E,gBAAAyE;IAAAA,eAAA,AAAAxE,eAAAwE;AAAA,AAAA,IAAArE,qBAAA;AAAA,AAAA,OAAAA,wDAAAsE,SAAAC,SAAAF;;;AAAA,AAoBA;;;;gDAAA,hDAAMO,wGAGHpH,IAAI+E;AAHP,AAIE,OAACsC,mDAAW,WAAKlG,KAAKmG;AAAV,AACE,OAACtE,cAAI,AAACC,kDAAU9B;GAClB4D,KACA,AAACwC,8CAAM,AAAC5L,gBAAMoJ;;AAE5B;;;gDAAA,hDAAMyC,wGAEHxH,IAAI+E;AAFP,AAKO,mDAAA,WAAA0C,vDAAC3Q;AAAD,AAAM,uEAAA2Q,hEAACzC,4DAAahF;GADpB,AAACoH,8CAA6BpH,IAAI+E;;AAGzC,uDAAA,vDAAM2C,sHAAqC1H,IAAI2H,MAAMC;AAArD,AACE,OAACC,6BAAa,WAAKC;AAAL,AACE,OAACzE,kCAAWyE,IAAIH;GAClB,AAACP,8CAA6BpH,IAAI4H;;AAElD,iCAAA,6CAAAG,9EAAME,0EACHjI;AADH,AAAA,IAAAgI,aAAAD;IAAAC,iBAAA,AAAAlJ,4BAAAkJ;SAAAA,LACkCG;aADlC,AAAApO,4CAAAiO,eAAA,pEACeE;aADf,AAAAnO,4CAAAiO,eAAA,pEACsBpR;AADtB,AAEE,GAEE,WAAA,VAAMA;AAFR;;AAAA,GAME,AAACsF,6CAAEgM,OAAOtR;AACVsR;;AAPF,AAUE,OAACR,qDAAoC1H,IAAIkI,OAAOtR;;;;;AAEpD;;;;;;;;;;iCAAA,6CAAAwR,eAAAC,7FAAMG,0EASHxI,aAEWb,eAECsJ;AAbf,AAAA,IAAAH,aAAAF;IAAAE,iBAAA,AAAAxJ,4BAAAwJ;WAAAA,PAWQ/Q;WAXR,AAAAwC,4CAAAuO,eAAA,lEAUWvD;IAVXwD,aAAAF;IAAAE,iBAAA,AAAAzJ,4BAAAyJ;YAAAA,RAaQjJ;WAbR,AAAAvF,4CAAAwO,eAAA,lEAYW5D;AAZX,AAcE,IAAMgE,qBAAmB,WAAKC;AAAL,AACE,OAACxT,eAAK,WAAAyT;AAAA,AAAA,IAAAC,aAAAD;IAAAC,iBAAA,AAAAhK,4BAAAgK;SAAAA,LACUX;YADV,AAAApO,4CAAA+O,eAAA,nEAAaC;AAAb,AAEE,oBAAM,iBAAAC,mBAAI,AAACvR,cAAIsR;AAAT,AAAA,GAAAC;AAAAA;;AACI,QAACD,sCAAAA,yDAAAA,rBAAM5J,qCAAAA,/BAAMsJ,qCAAAA;;;AADvB,AAEE,yDAAA,lDAACnM,+CAAO6L;;AAFV;;GAGFS;;IAC3BK,QAAM,yBAAA,zBAACC;IACPf,KAAG,iBAAAgB,qBAEW,AAAC/T,eAAK,WAAAiU;AAAA,AAAA,IAAAC,aAAAD;IAAAC,iBAAA,AAAAxK,4BAAAwK;eAAAA,XACU/R;eADV,AAAAwC,4CAAAuP,eAAA,tEAAavE;AAAb,AAEE,IAAAoE,qBAAe,AAAClM,cAAI,wDAAA,mFAAA,3IAAC+G,+CAAOzM,4IAAUoN;AAAtC,AAAA,GAAAwE;AAAA,AAAA,UAAAA,NAAWP;AAAX,AACE,6BAAA,7BAACW,uBAAQN;;AACT,IAAAE,yBAAc,AAACR,mBAAmBC;AAAlC,AAAA,oBAAAO;AAAA,AAAA,SAAAA,LAAWhB;AAAX,AACE,wDAAA,jDAACpR,8CAAMoR,4DAAWpD;;AADpB;;;AAFF;;GAIF,AAACyC,8CAA6BxH,IAAI,AAAA,mFAAOzI;AAR1D,AAAA,oBAAA4R;AAAA,AAAA,IAAAC,aAAAD;IAAAC,iBAAA,AAAAtK,4BAAAsK;SAAAA,LACgBjB;aADhB,AAAApO,4CAAAqP,eAAA,pEAAmBlB;aAAnB,AAAAnO,4CAAAqP,eAAA,pEAA0BxS;AAA1B,AASE,IAAM4S,kBAAgB,0BAAA,+CAAA,vDAAM5S,QACJ,AAACgM,gCAAesF,OAAOtR;IACzCuR,qGAAOA,9CACA,iDAAA,jDAACpR,yGAAcyS,vJACf,wKAAA,xKAACzS,sOAAiB,EAAI,AAACqM,wCAAiBxM,aAClB,AAACsF,6CAAEsN,gBAAgBtB;AALtD,AAME,4DAAA,rDAACnR,8CAAMoR,gEAAW,AAACF,+BAAcjI,IAAImI;;AAfzC;;;AART,AAAA,0FAAA,AAAAO,gBAwBIO,OAAMd;;AAEZ,oCAAA,4CAAAsB,hFAAME;AAAN,AAAA,IAAAD,aAAAD;IAAAC,iBAAA,AAAA5K,4BAAA4K;YAAAA,RAAkDG;WAAlD,AAAA9P,4CAAA2P,eAAA,lEAAgC3E;cAAhC,AAAAhL,4CAAA2P,eAAA,rEAAqCE;AAArC,AACE,IAAMA,cAAQ,AAAC9G,gCAAgB8G;IACzBA,cAAQ,EAAI,0EAAA,1EAAC1N,6CAAE,AAACkG,gBAAMwH,6DACZ,AAACvH,eAAKuH,aACNA;AAHhB,AAIE,OAAC5S,6CAAK+N,KAAK6E;;AAEf,8CAAA,9CAAME,oGACH9J,IAAI+J,OAAOhF,KAAKiF;AADnB,AAGO,OAACC,mDAAW,WAAKlF;AAAL,AACE,IAAA7P,oBAAK,yDAAA,zDAACgV,gDAAKnF;AAAX,AAAA,GAAA7P;AAAA,IAAAA,wBAEK,iBAAA8T,mBAAIgB;AAAJ,AAAA,oBAAAhB;AAAAA;;AACI,OAACkB,gDAAKH,OAAOhF;;;AAHtB,AAAA,oBAAA7P;AAIK,OAACmO,kCAAW0G,OAAOhF;;AAJxB7P;;;AAAAA;;GAFd,AAACkS,8CAA6BpH,IAAI+E;;AAQzC,qCAAA,rCAAMoF,kFACHnK,IAAI4I;AADP,AAEE,IAAMwB,mBACA,WAAAC;AAAA,AAAA,IAAAC,aAAAD;IAAAC,iBAAA,AAAAxL,4BAAAwL;UAAAA,NACUC;aADV,AAAAxQ,4CAAAuQ,eAAA,pEAAa1T;aAAb,AAAAmD,4CAAAuQ,eAAA,pEAAoBP;sBAApB,AAAAhQ,4CAAAuQ,eAAA,7EAA2BN;AAA3B,AAIE,oBAAMpT;AAAN,AACE,gBAAA,ZAAO4T,2DAAY5T;IACZ6T,QAAMD;;AADb,AAEE,mBAAA,fAAMG;kBAAND;AAAA,AAAc,2CAAAA,pCAACrO,0BAAUmO;;;IACnBI,uEAIE,AAAC9T,4CACC,5GA4BF,AAACsD,+CAAOiR;kBA5BNP;AAAA,AAAA,IAAAC,aAAAD;IAAAC,iBAAA,AAAAjM,4BAAAiM;WAAAA,PACUxT;WADV,AAAAwC,4CAAAgR,eAAA,lEAAapG;WAAb,AAAA5K,4CAAAgR,eAAA,lEAAkBhG;AAAlB,AAEE,OAACiG,+CAAOL,aACN,AAAC3P,+CACC,AAAC8O,4CAA2B9J,IACA+J,OACAhF,KACAiF,iBAC5B,iBAAAiB,WAAMtG;IAANsG,eAAA,EAAA,CAAAA,oBAAApR,oBAAA,AAAAoR,aAAA;AAAA,AAAA,QAAAA;KAAA;AAEE,IAAMC,UAGK,4CAAA,5CAACpU;kBAADsU;AAAA,AAAM,yDAAAA,lDAAC5J,6CAAKuD;;gBAFZ,AAAA,0FAAUxN,zGACV4T,AACA;AAHX,AAIED;;;KANJ;AAYE,oBAAU,AAAC9V,eAAK;kBAAKL;AAAL,AACE,SAAK,AAACmV,gDAAKnF,KAAKhQ,QACX,AAACsO,kCAAW0B,KAAKhQ;;CACxByV;AAHhB;;AAAA,AAAA,0FAIG,AAACb,kCAAiBpS;;;;;AAhBvB;;;;;CAVR,4CAAA,5CAACT;kBAAD+T;AAAA,AAAM,uEAAAA,iBAAA,jFAAC7F,4DAAahF;;CADpByK;IAiCFG,WAAI,AAACU,qDAAuB,AAACC,cAAIX,MAAKJ;AApC5C,AAqCE,GAAA,GAAQ,AAACnE,uBAAOuE;AACd,eAEE,AAAC5T,6CAAKwT,UAAUI;eAEhBA;;;;;AACFJ;;;;;AA9CR;;;AALR,4FAoDO,AAAC1T,4CAAIsT,iBAAiBxB,zJACtB,OAACxO,+CAAOoR,eAAK,AAACrF;;AAEvB,+BAAA,/BAAMsF,sEAAazL,IAAI+E,KAAKtC;AAA5B,AACE,IAAMlL,OAAK,AAACyN,4DAAahF,IAAI+E;AAA7B,AACE,QAACtC,kCAAAA,wCAAAA,RAAElL,oBAAAA;;AAEP,qCAAA,rCAAMmU,kFAAmB1L,IAAIwK;AAA7B,AAEO,6DAAA,WAAAmB,jEAACpV;AAAD,AAAS,wCAAAoV,iBAAA,lDAACF,6BAAYzL;qDADtBwK;;AAGP,gCAAA,hCAAMoB,wEAAc7W;AAApB,AACE,GAAI,EAAK,AAACmO,4BAAYnO,QACb,gEAAA,hEAACmH,6CAAE,AAACP,gBAAM5G;AACjB,OAACqN,gBAAMrN;;AACPA;;;AAEJ;;;;;4CAAA,5CAAM8W,gGAIH7L,IAAI8L;AAJP,AAKG,qCAAI,iBAAO5E,QAAM4E,vDA4CbF;IA3COrU,OAAKyI;aADZ,TAEOwF;6BAFP,zBAGOuG;;AAHP,AAIE,IAAM7E,YAAM,6CAAA,7CAAClQ,8EAAQ,AAACgU,+CAAO3E,uBAAOa;AAApC,AACE,oBACE,AAAC3G,iCAAUhJ;AACX,IAAMyU,WAAS,AAAA,0FAAUzU;IACnB0U,SAAO,AAACC,mBAAS9J,gBAAM8E;IACvBiF,iBACA,AAACC,8BAAc;kBAAK3J,EAAE4J;AAAP,AACE,IAAAC,WAAuBD;IAAvBE,WACuB,AAACzV,4CAGCuL,eACA,AAACtI,4CAAIkS,OAAOxJ;AALrC,AAAA,0JAAA6J,SAAAC,gEAAAD,SAAAC,pOAACV,0EAAAA,6FAAAA;;CAMHG;AAVrB,AAcE,GAAID;AACF,OAAC9H,8BAAauB,OACA;kBAAK/C;AAAL,AAAA,uDACGA,EAAE0J;;;;AACnBA;;;AApBN,GAsBE,AAAC1L,iCAAUlJ;AACX,AACE,IAAMiV,KAAG,AAACjB,cAAI,AAACzU,4CAAIsL,gBAAM8E;IACnBzE,IAAE,AAACL,gBAAMoK;AADf,AAEE,GAAQ,iEAAA,jEAACtQ,6CAAE,AAACP,gBAAM6Q;AAAlB;AAAA,AAAA,MAAA,KAAA3M,MAAA,CAAA,sGAAA,KAAA,zFAAyB,CAAA,8DAAuBqH;;;AAChD,IAAMA,YAAM,AAAC8D,+CAAO3E,uBAAO,AAACvP,4CAAIuL,eAAK6E;AAArC,AACE,GAAI,AAACjK,cAAIiK;AACP,eACEA;eACA,oDAAA,mFAAA,vIAAClD,+CAAOzM,iJAAckL;eACtB,AAACjB,6CAAKgE,OAAO/C;eAHf;;;;;;;AAKA,OAACjB,6CAAKgE,OAAO/C;;;AAlCvB,AAsCE,OAACjB,6CAAKgE,OAAO,AAACiH,iBAAOvF;;;;;;;;AAGlC,kCAAA,8CAAAwF,hFAAME,4EACH5M,aAEYV,MAAMmJ,YAClBoE;AAJH,AAAA,IAAAF,aAAAD;IAAAC,iBAAA,AAAA7N,4BAAA6N;YAAAA,RAGQxN;aAHR,AAAApF,4CAAA4S,eAAA,pEAEWnH;AAFX,AAKE,IAAMsG,gBAAc,AAACpF,0CAAsB1G,IAAIwF;IACzCsH,eAAa,+CAAA,WAAAC,1DAACC;AAAD,AAAS,yJAAA,lJAAC9Q,6CAAE,AAAA,mFAAA6Q;GAAmBjB;IAC5ClD,MACS,4CAAA,WAAAqE,vDAACnW;AAAD,AAAM,0CAAAmW,nCAACzE,+BAAcxI,qBAAMb,MAAMG,MAAMmJ;GADvCqE;IAETxF,IAAE,uHAAA,KAAA,ZAAesB,5DACA,AAAC9R,4CAAIsL,9EACL,AAAChN,eAAK8X,2FACnB,kBAAO,iWAAA,2CAAA,5YAAC7T,gDAAQ,CAAA,yIAAA,tFAAY,AAAA,gFAAK2G,wEAA2B,AAAA,mFAAOV,sHAC1CkG;IAC7BoD,2IAASA,7DACA,AAAC9R,4CAAIqW,hHACL,AAACnC,+CAAOoC;AAXvB,AAYE,GAAI,GAAK,AAACC,qBAAKzE;AAAf,iGAAA,iCAAA,xCACGpD;;AACD,IAAM8H,gLAIc,AAACN,+CAAO,WAAAO,3JAoBR,4CAAA,5CAACzW,pEACD,AAACE,6CAAK,AAACmP;AArBC,AAAA,IAAAqH,aAAAD;IAAAC,iBAAA,AAAA1O,4BAAA0O;WAAAA,PACUjW;WADV,AAAAwC,4CAAAyT,eAAA,lEAAazI;AAAb,AAEE,OAAC3P,eACC,WAAAqY;AAAA,AAAA,IAAAC,aAAAD;IAAAC,iBAAA,AAAA5O,4BAAA4O;SAAAA,LACUvF;aADV,AAAApO,4CAAA2T,eAAA,pEAAa9W;aAAb,AAAAmD,4CAAA2T,eAAA,pEAAoB3D;sBAApB,AAAAhQ,4CAAA2T,eAAA,7EAA2B1D;AAA3B,AAEE,GACE,kDAAA,lDAAC9N,6CAAE6I;AAGH,IAAA7P,oBAAK8U;AAAL,AAAA,oBAAA9U;AACK,2DAAA,pDAACgH,6CAAEtF;;AADR1B;;;AAJF,GAOE,AAACgH,6CAAE6N,OAAOhF;AAGViF;;AAVF,AAaE,OAAC3G,kCAAW0G,OAAOhF;;;;GACvB6D;GAvBZkD;IA0BdtB,YAAU,AAACL,mCAAkBnK,IAAI4I;IACjC+E,eAEkB,sDAAA,WAAAE,jEAACtX;AAAD,AAAS,wCAAAsX,iBAAA,lDAACpC,6BAAYzL;uEAFtBsN,lBACAM,AACA;IAClBE,gBAAc,AAACpC,mCAAkB1L,IAAIwK;IACrCuD,gLAAgBnF,nKACA,sDAAA,tDAACrS;IACjByX,UAAQ,AAAChT,sDAAO2S,aAAaI,6DAAWD;IAGxCG,wMAA2B,4CAAA,5CAACnX,iGAAUgV,hLACX,6CAAA,7CAAC9U,rDACN,AAACsU,qPAAuBgC,rSACxB,AAACY,+SAAkB1D;IACzC2D,YAAU,AAACtC,0CAAsB7L,IAAIiO;AAxC3C,AAAA,0FAyCGE,UAAUH,QACV,AAACnK,iDAA0B,4CAAA,WAAAuK,vDAACtX;AAAD,AAAM,uEAAAsX,hEAACpJ,4DAAahF;GAClBwK;;;AAEtC,4BAAA,5BAAM6D,gEACHrO;AADH,AAEE,SAAA,2CAAA,yDAAA,iCAAA,wDAAA,iCAAA,8DAAA,KAAA,yDAAA,/VAAMmI;IAIAqC,YAAc,uCAAA,vCAACL,mCAAkBnK,uFAAKmI;IACtC2F,gBAAc,AAACpC,mCAAkB1L,IAAIwK;IACrChF,SAAc,AAACqG,0CAAsB7L,IAAIwK;AAN/C,AAAA,0FAOGhF,OAAOsI;;AAEZ,AAAA,8BAAA,sCAAApO,pEAAM6O;AAAN,AAAA,IAAAD,WAAA,AAAA;AAAA,AAAA,QAAAA;KAAA;AAAA,OAAAC,0DAAA,CAAA,UAAA;;;KAAA;AAAA,OAAAA,0DAAA,CAAA,UAAA,MAAA,CAAA,UAAA;;;;AAAA,MAAA,KAAA1O,MAAA,CAAA,8DAAA,AAAA;;;;;AAAA,CAAA,4DAAA,5DAAM0O,uEACFvO;AADJ,AAEG,qEAAA,9DAAC4O,0DAAW5O;;;AAFf,CAAA,4DAAA,WAAAwO,SAAAC,hFAAMF;AAAN,AAAA,IAAAG,aAAAF;IAAAE,iBAAA,AAAA5P,4BAAA4P;UAAAA,NAIS1O;cAJT,AAAAjG,4CAAA2U,eAAA,rEAGY9E;WAHZ,AAAA7P,4CAAA2U,eAAA,lEAGoB/J;IAHpBgK,aAAAF;IAAAE,iBAAA,AAAA7P,4BAAA6P;YAAAA,RAQSI;WART,AAAAhV,4CAAA4U,eAAA,qDAAA,vHAKYE;YALZ,AAAA9U,4CAAA4U,eAAA,nEAKiBzO;cALjB,AAAAnG,4CAAA4U,eAAA,2DAAA,hIAKuBG;AALvB,AASG,IAAMA,cAAQ,EAAI,GAAA,YAAA,XAAOA,oBACTA,QACA,AAAA,yFAAU9O;YAF1B,2CAAA,qDAAA,xGAGMV;IAHN0P,aAIuB,AAACX,0BAASrO;aAJjC,AAAAtJ,4CAAAsY,WAAA,IAAA,pEAIOxJ;cAJP,AAAA9O,4CAAAsY,WAAA,IAAA,rEAIchB;IACR7O,QAAM,iEAAA,kHAAA,nLAACpI,qDAAM+X,qEACGtJ,qHACEwI;AAPxB,AAQE,oBAAIa;AACF,8EAAA,2CAAA,lHAAC5O,uDAAQD,IAAIb,MAAMG,yGAAcY;;AACjCf;;;;AAnBP,CAAA,sDAAA,tDAAMoP;;AAAN,AAqBA;;;;oCAAA,4DAAAU,hGAAME,gFAGHnP,IAAIb,MAAMG;AAHb,AAAA,IAAA4P,aAAAD;IAAAC,iBAAA,AAAApQ,4BAAAoQ;WAAA,AAAAnV,4CAAAmV,eAAA,qDAAA,vHAIWL;YAJX,AAAA9U,4CAAAmV,eAAA,nEAIgBhP;kBAJhB,AAAAnG,4CAAAmV,eAAA,zEAIsBzG;kCAJtB,AAAA1O,4CAAAmV,eAAA,zFAIkCrC;AAJlC,AAME,IAIMpE,kBACA,iBAAAO,mBAAIP;AAAJ,AAAA,oBAAAO;AAAAA;;AAAgB1J;;;IALtB8P,aAQM,AAACxC,gCAAe5M,IACAb,MACAG,MACAmJ,gBACAoE;gBAZtB,AAAAnW,4CAAA0Y,WAAA,IAAA,vEAOOjB;cAPP,AAAAzX,4CAAA0Y,WAAA,IAAA,rEAOiBpB;mCAPjB,AAAAtX,4CAAA0Y,WAAA,IAAA,1FAOyBC;IAOnBlP,YAAU,2DAAA,qHAAA,sHAAA,iKAAA,vcAACpJ,qDAAMoI,+DACGgP,qJACgBkB,gGACX,AAAA,uFAASlQ,mEACZ6O;AAlB5B,AAmBE,oBAAIa;AACF,4FAAA,2CAAA,hIAAC5O,uDACCD,IACAG,UACAsI,mHACQvI;;AACVC;;;AAEN;;;oCAAA,pCAAMmP,gFAEHtP,IAAIb,MAAMsJ,YAAY8G;AAFzB,AAIE,QAAA,JAAOnO;IACAjC,YAAM,qDAAA,rDAAC7C,+CAAO6C;cADrB,VAEO6O;;AAFP,AAIE,GAAM,KAAA,JAAG5M;AAAT,AAGE,MAAO,sOAAA,2CAAA,jRAAC/H,gDAAQ,CAAA,0EAAmC,AAAA,mFAAOoP,2HAClC,AAAA,uFAAStJ;;AAJnC;;AAMA,IAAMG,QACA,2BAAA,2CAAA,qDAAA,zHAAI,OAAA,NAAO8B,YACTqH;IAFR+G,aASM,AAACL,kCAAiBnP,IAAIb,UAAMG,MAAMiQ;IATxCC,iBAAA,AAAA1Q,4BAAA0Q;gBAAAA,ZAQWrQ;eARX,AAAApF,4CAAAyV,eAAA,tEAOcC;mCAPd,AAAA1V,4CAAAyV,eAAA,1FAOuBH;IAIjBrB,cACA,kBAAIyB,UACF,AAACzY,6CAAKgX,QAAQyB,UACdzB;AAdR,AAeE,oBAAIqB;AACF,eAAO,KAAA,JAAKjO;eAAG,yDAAA,zDAAC9E,+CAAO6C;eAA+B6O;;;;;;AADxD,0FAEG7O,UAAM6O;;;;;AAEf,AAAA;;;;;;;;;;;8BAAA,sCAAAtO,pEAAMiQ;AAAN,AAAA,IAAAD,WAAA,AAAA;AAAA,AAAA,QAAAA;KAAA;AAAA,OAAAC,0DAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAA,CAAA,UAAA;;;KAAA;AAAA,OAAAA,0DAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAA,CAAA,UAAA;;;;AAAA,MAAA,KAAA9P,MAAA,CAAA,8DAAA,AAAA;;;;;AAAA,CAAA,4DAAA,5DAAM8P,uEAUF3P,IAAIb,MAAMG;AAVd,AAWG,iFAAA,1EAACwQ,0DAAW9P,IAAIb,MAAMG;;;AAXzB,CAAA,4DAAA,2BAAAsQ,vFAAMD,uEAYF3P,IAAIb,MAAMG;AAZd,AAAA,IAAAuQ,aAAAD;IAAAC,iBAAA,AAAA/Q,4BAAA+Q;WAAAA,PAaSN;WAbT,AAAAxV,4CAAA8V,eAAA,qDAAA,vHAcYhB;YAdZ,AAAA9U,4CAAA8V,eAAA,nEAciB3P;AAdjB,AAgBG,IACGuI,cACA,AAAClT,6BAAY+J;IAEbiQ,WACA,mDAAA,nDAACxY,8CAAMwY,uEAAkB9G;IAL5BsH,aAQG,AAACT,kCACCtP,IACA,qDAAA,rDAAC1D,+CAAO6C,mEACRsJ,YACA8G;gBAZL,AAAA7Y,4CAAAqZ,WAAA,IAAA,vEAOI5P;cAPJ,AAAAzJ,4CAAAqZ,WAAA,IAAA,rEAOc/B;AAPd,AAcE,IAAAgC,WAAQ,gEAAA,2IAAA,3MAAC1T,sDAAO6D;AAAhB,AAAA,oBACE,iBAAA6I,mBAAI,AAACvR,cAAIoX;AAAT,AAAA,GAAA7F;AAAAA;;AAAe9I;;;AACf,qDAAA8P,SAAA,vDAACjZ,mHAAgBiX;;AAFnBgC;;;;AA9BL,CAAA,sDAAA,tDAAML;;AAAN,AAkCA,uCAAA,vCAAOM,sFAAe1Y,KAAKwN;AAA3B,AACE,IAAA,AACE,oBAAU,AAACC,4DAAazN,KAAKwN;AAA7B;AAAA,AACE,MAAO,gDAAA,iBAAA,2CAAA,0DAAA,qFAAA,3PAAC1L,iKAAgC0L;;;AAF5C;gBAAA,GAAA,CAAAmL,kBAIkDrQ;AAJlD,QAAAqQ,JAI4DC;AAJ5D,AAKI,GAAI,sLAAA,tLAACjU,6CAAE,AAAA,mHAAQ,AAACkU,kBAAQD;AAAxB;;AAEE,MAAOA;;;AAPb,AAAA,MAAAD;;;;AASF,AAAA;;;;oCAAA,4CAAAxQ,hFAAMpG;AAAN,AAAA,IAAA+W,WAAA,AAAA;AAAA,AAAA,QAAAA;KAAA;AAAA,OAAA/W,gEAAA,CAAA,UAAA;;;KAAA;AAAA,OAAAA,gEAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAA,CAAA,UAAA;;;;AAAA,MAAA,KAAAuG,MAAA,CAAA,8DAAA,AAAA;;;;;AAAA,CAAA,kEAAA,lEAAMvG,6EAGFwL;AAHJ,AAIG,iFAAA,1EAACwL,gEAAiBxL,KAAKA;;;AAJ1B,CAAA,kEAAA,lEAAMxL,6EAKFwL,KAAKvN,KAAKgZ;AALd,AAMG,AACE,IAAMC,oBAAY,AAACja,sDAAO2W,qEAAS,eAAA,AAAA,8EAAI3V,7FAASkZ;IAC1CC,wLAAaF,pGACA,4CAAA,5CAAC1Z,pEAGD,AAACkU,+CAAOoC;AAL3B,AAME,GAAM,AAACnQ,cAAIyT;AAAX,AACE,IAAAC,mBAAA,AAAA1T,cAAeyT;IAAfE,qBAAA;IAAAC,qBAAA;IAAAC,iBAAA;;AAAA,AAAA,GAAA,AAAA,CAAAA,iBAAAD;AAAA,mBAAA,AAAAD,wDAAAE,vEAAQla;AAAR,AAAA,IACcA,mBAAO,AAACgM,gCAAe2N,aAAa3Z;AADlD,AAAA,AAEE,oBAAU,AAACqZ,qCAAcnL,KAAKlO;AAA9B;AAAA,AACE,MAAO,2IAAA,2CAAA,yEAAA,/PAACyC,gDAAQ,CAAA,8DAAuBzC,+HACrBA,yEAAc2Z;;;AAJpC;AAAA,eAAAI;eAAAC;eAAAC;eAAA,CAAAC,iBAAA;;;;;;;AAAA,IAAA3H,2BAAA,AAAAlM,cAAA0T;AAAA,AAAA,GAAAxH;AAAA,AAAA,IAAAwH,uBAAAxH;AAAA,AAAA,GAAA,AAAA4H,6BAAAJ;AAAA,IAAAK,wBAAA,AAAAC,sBAAAN;AAAA,AAAA,eAAA,AAAAO,qBAAAP;eAAAK;eAAA,AAAArV,gBAAAqV;eAAA;;;;;;;AAAA,mBAAA,AAAA5O,gBAAAuO,/BAAQ/Z;AAAR,AAAA,IACcA,mBAAO,AAACgM,gCAAe2N,aAAa3Z;AADlD,AAAA,AAEE,oBAAU,AAACqZ,qCAAcnL,KAAKlO;AAA9B;AAAA,AACE,MAAO,2IAAA,2CAAA,yEAAA,/PAACyC,gDAAQ,CAAA,8DAAuBzC,+HACrBA,yEAAc2Z;;;AAJpC;AAAA,eAAA,AAAAlO,eAAAsO;eAAA;eAAA;eAAA;;;;;;;;AAAA;;;;;AADF;;AAMF,IAAAxH,2BAAmB,AAAA,yFAAU5R;AAA7B,AAAA,oBAAA4R;AAAA,AAAA,oBAAAA,hBAAWS;AAAX,AACE,IAAMuH,qBAAa,oDAAA,mFAAA,vIAACnN,+CAAOzM,iJAAcqS;AAAzC,AACE,oBAAUuH;AAAV;AAAA,AACE,MAAO,gJAAA,2CAAA,yEAAA,pQAAC9X,gDAAQ,CAAA,sEAA+BuQ,+HAC5BA,sEAAe2G;;;AAJxC;;AAKA,IAAAa,mBAAA,AAAAnU,cAAqB,AAAA,uFAAS1F;IAA9B8Z,qBAAA;IAAAC,qBAAA;IAAAC,iBAAA;;AAAA,AAAA,GAAA,AAAA,CAAAA,iBAAAD;AAAA,IAAAE,mBAAA,AAAAH,wDAAAE;iBAAA,AAAA7a,4CAAA8a,iBAAA,IAAA,9EAASE;kBAAT,AAAAhb,4CAAA8a,iBAAA,IAAA,/EAAcG;AAAd,AAAA,AACE,AAACrB,gEAAiBxL,KAAK6M,YAAM,AAACnQ,6CAAK+O,aAAamB;;AADlD;AAAA,eAAAN;eAAAC;eAAAC;eAAA,CAAAC,iBAAA;;;;;;;AAAA,IAAApI,2BAAA,AAAAlM,cAAAmU;AAAA,AAAA,GAAAjI;AAAA,AAAA,IAAAiI,uBAAAjI;AAAA,AAAA,GAAA,AAAA4H,6BAAAK;AAAA,IAAAJ,wBAAA,AAAAC,sBAAAG;AAAA,AAAA,eAAA,AAAAF,qBAAAE;eAAAJ;eAAA,AAAArV,gBAAAqV;eAAA;;;;;;;AAAA,IAAAS,mBAAA,AAAArP,gBAAAgP;iBAAA,AAAA1a,4CAAA+a,iBAAA,IAAA,9EAASC;kBAAT,AAAAhb,4CAAA+a,iBAAA,IAAA,/EAAcE;AAAd,AAAA,AACE,AAACrB,gEAAiBxL,KAAK6M,YAAM,AAACnQ,6CAAK+O,aAAamB;;AADlD;AAAA,eAAA,AAAArP,eAAA+O;eAAA;eAAA;eAAA;;;;;;;;AAAA;;;;;AAEA,oBAAM,AAAC7Q,iCAAUhJ;AAAjB,AACE,IAAAqa,aAAA,AAAA3U,cAAqB,AAAA,0FAAU1F;IAA/Bsa,eAAA;IAAAC,eAAA;IAAAC,WAAA;;AAAA,AAAA,GAAA,AAAA,CAAAA,WAAAD;AAAA,IAAAE,aAAA,AAAAH,kDAAAE;WAAA,AAAArb,4CAAAsb,WAAA,IAAA,lEAASN;YAAT,AAAAhb,4CAAAsb,WAAA,IAAA,nEAAcL;AAAd,AAAA,AACE,AAACrB,gEAAiBxL,KAAK6M,MAAM,AAACnQ,6CAAK+O,aAAamB;;AADlD;AAAA,eAAAE;eAAAC;eAAAC;eAAA,CAAAC,WAAA;;;;;;;AAAA,IAAA5I,qBAAA,AAAAlM,cAAA2U;AAAA,AAAA,GAAAzI;AAAA,AAAA,IAAAyI,iBAAAzI;AAAA,AAAA,GAAA,AAAA4H,6BAAAa;AAAA,IAAAZ,kBAAA,AAAAC,sBAAAW;AAAA,AAAA,eAAA,AAAAV,qBAAAU;eAAAZ;eAAA,AAAArV,gBAAAqV;eAAA;;;;;;;AAAA,IAAAiB,aAAA,AAAA7P,gBAAAwP;WAAA,AAAAlb,4CAAAub,WAAA,IAAA,lEAASP;YAAT,AAAAhb,4CAAAub,WAAA,IAAA,nEAAcN;AAAd,AAAA,AACE,AAACrB,gEAAiBxL,KAAK6M,MAAM,AAACnQ,6CAAK+O,aAAamB;;AADlD;AAAA,eAAA,AAAArP,eAAAuP;eAAA;eAAA;eAAA;;;;;;;;AAAA;;;;;;AADF;;;;AA1BL,CAAA,4DAAA,5DAAMtY;;AAAN,AA8BA,2BAAA,3BAAM4Y,8DAAS/S,MAAMgT;AAArB,AACE,IAAMC,KAAG,AAACtP,gCAAgB,AAAA,oFAAQ3D;IAC5BkT,KAAG,AAACvP,gCAAgBqP;AAD1B,AAEE,OAAC9O,kCAAWgP,GAAGD;;AAEnB","names":["statecharts.impl/canon-one-transition","x","cljs.core/map?","statecharts.impl/canon-transitions","and__4210__auto__","cljs.core/vector?","cljs.core/some","cljs.core.mapv","statecharts.impl/canon-actions","statecharts.impl/canon-event","statecharts.impl/T_Actions","cljs.core/ifn?","statecharts.impl/T_Target","cljs.core/keyword?","statecharts.impl/T_Transition","statecharts.impl/T_Entry","statecharts.impl/T_Exit","statecharts.impl/T_DelayExpression","cljs.core/int?","statecharts.impl/T_DelayedEvent","statecharts.impl/T_Event","statecharts.impl/T_Transitions","statecharts.impl/T_Initial","statecharts.impl/decode-delayed-map","m","cljs.core.mapcat","p__12602","vec__12603","cljs.core.nth","ms","target","p1__12601#","cljs.core.map","cljs.core.assoc","cljs.core.into","statecharts.impl/decode-delayed-transitions","statecharts.impl/T_DelayedTransition","statecharts.impl/T_DelayedTransitions","statecharts.impl/T_After","statecharts.impl/T_EventlessTransitions","statecharts.impl/insert-eventless-transitions","node","always","cljs.core/not","cljs.core.update","cljs.core/assoc","statecharts.impl/T_Type","statecharts.impl/T_States","cljs.core.comp","statecharts.delayed/insert-delayed-transitions","statecharts.impl/T_Integrations","cljs.core/any?","statecharts.impl/T_Machine","statecharts.delayed/replace-delayed-place-holder","statecharts.delayed/scheduler?","statecharts.impl/machine","orig","conformed","malli.core.decode","malli.transform.transformer","malli.transform/default-value-transformer","malli.core.validate","reason","malli.error.humanize","malli.core.explain","machine-id","msg","G__12606","js/console.warn","cljs.core/clj->js","js/JSON.stringify","cljs.core.ex_info","statecharts.impl/validate-targets","this__4461__auto__","k__4462__auto__","this__4463__auto__","k12608","else__4464__auto__","G__12612","cljs.core/Keyword","v","cljs.core.get","__extmap","this__4481__auto__","f__4482__auto__","init__4483__auto__","cljs.core.reduce","ret__4484__auto__","p__12613","vec__12614","k__4485__auto__","v__4486__auto__","this__4476__auto__","writer__4477__auto__","opts__4478__auto__","pr-pair__4479__auto__","keyval__4480__auto__","cljs.core/pr-sequential-writer","cljs.core.concat","cljs.core/PersistentVector","G__12607","cljs.core/RecordIter","cljs.core/-iterator","cljs.core/nil-iter","this__4459__auto__","__meta","this__4456__auto__","__hash","this__4465__auto__","cljs.core/count","this__4457__auto__","h__4319__auto__","coll__4458__auto__","cljs.core/hash-unordered-coll","this12609","other12610","cljs.core._EQ_","this__4471__auto__","k__4472__auto__","cljs.core/contains?","cljs.core.dissoc","cljs.core/-with-meta","cljs.core/not-empty","this__4468__auto__","G__12617","this__4469__auto__","k__4470__auto__","pred__12618","cljs.core/keyword-identical?","expr__12619","this__4474__auto__","cljs.core/seq","cljs.core/MapEntry","this__4460__auto__","this__4466__auto__","entry__4467__auto__","cljs.core/-nth","cljs.core/-conj","statecharts.impl/ContextAssignment","this__4505__auto__","cljs.core/List","writer__4506__auto__","cljs.core/-write","G__12611","extmap__4501__auto__","G__12621","cljs.core/record?","statecharts.impl/->ContextAssignment","statecharts.impl/map->ContextAssignment","statecharts.impl/assign","f","args","cljs.core.apply","statecharts.impl/internal-action?","action","G__12622","cljs.core/namespace","p__12623","p__12624","map__12625","cljs.core/--destructure-map","map__12626","statecharts.impl/execute-internal-action","_fsm","scheduler","state","transition-event","internal-action","event","event-delay","statecharts.delayed/schedule","statecharts.delayed/unschedule","var_args","G__12628","statecharts.impl/execute","js/Error","p__12629","map__12630","fsm","statecharts.impl.execute","debug","new-state","retval","G__12631","statecharts.impl/PathElement","statecharts.impl/parallel?","G__12632","statecharts.impl/compound?","statecharts.impl/atomic?","statecharts.impl/path->_state","xs","indexed-xs","statecharts.utils/with-index","cljs.core/rest","ret","p__12633","vec__12634","accu","i","para-state","statecharts.utils/map-vals","id","cljs.core.conj","statecharts.utils/devectorize","args__4824__auto__","len__4818__auto__","i__4819__auto__","argseq__4825__auto__","cljs.core/IndexedSeq","statecharts.impl/check-or-throw","p__12641","map__12642","seq12637","G__12638","cljs.core/first","cljs.core/next","G__12639","G__12640","self__4805__auto__","k","map","cljs.core/name","statecharts.impl/resolve-target","base","statecharts.utils/ensure-vector","parent","cljs.core/vec","cljs.core.drop_last","cljs.core/sequential?","cljs.core.drop","statecharts.impl/absolute-target?","statecharts.impl/is-prefix?","short","long","n","cljs.core.take","statecharts.impl/external-self-transition-actions","handler","nodes","statecharts.impl/has-eventless-transition?","cljs.core/boolean","p1__12643#","cljs.core.get_in","statecharts.impl/updatev-last","seq12644","G__12645","G__12646","cljs.core/update","statecharts.impl/RT_NodePath","statecharts.impl/RT_Node","statecharts.impl/RT_TX","statecharts.impl/T_Configuration","statecharts.impl/add-node-type","type","G__12648","statecharts.impl/resolve-node","root","path","statecharts.impl.resolve_node","full?","current-root","cljs.core/reduced","G__12649","G__12650","cljs.core/select-keys","statecharts.impl/_state->nodes","_state","G__12655","vec__12656","seq__12657","first__12658","vec__12666","seq__12667","first__12668","head","more","prefix","cljs.core/sorted-set","current","cljs.core/empty?","p__12669","vec__12670","cljs.core/cons","p1__12651#","statecharts.impl/_state->configuration","p__12677","map__12678","seq12674","G__12675","G__12676","no-resolve?","_opt","paths","p1__12673#","statecharts.impl/backtrack-ancestors-as-paths","cljs.core.reductions","_","cljs.core.range","statecharts.impl/backtrack-ancestors-as-nodes","p1__12679#","statecharts.impl/find-least-common-compound-ancessor","path1","path2","statecharts.utils/find-first","anc","p__12680","map__12681","statecharts.impl/get-tx-domain","source","tx","p__12682","p__12683","map__12684","map__12685","statecharts.impl/select-one-tx","input-event","cljs.core/deref","first-satisfied-tx","txs","p__12686","map__12687","guard","or__4212__auto__","found","cljs.core/volatile!","temp__5753__auto__","map__12690","p__12688","map__12689","cljs.core/vreset!","target-resolved","p__12691","map__12692","statecharts.impl/get-initial-path","initial","_node","statecharts.impl/add-ancestors-to-entry-set","domain","external?","cljs.core.take_while","cljs.core.not_EQ_","statecharts.impl/compute-entry-set","get-tx-entry-set","p__12696","map__12697","_tx","entry-set","seeds","p1__12693#","exist?","new","p1__12694#","p__12701","map__12702","cljs.core.remove","G__12703","regions","cljs.core/keys","p1__12695#","cljs.core/concat","clojure.set.difference","cljs.core/set","cljs.core/into","statecharts.impl/get-actions","statecharts.impl/get-entry-actions","p1__12704#","statecharts.impl/simple-state","statecharts.impl/configuration->_state","configuration","parent-compound?","children","groups","cljs.core/group-by","parallel-state","statecharts.utils/map-kv-vals","region","G__12707","G__12708","ks","cljs.core/ffirst","p__12713","map__12714","statecharts.impl/-do-transition","ignore-unknown-event?","atomic-nodes","p1__12709#","cljs.core.filter","p1__12710#","cljs.core/identity","cljs.core/second","cljs.core/nil?","cljs.core/seq?","exit-set","p__12715","map__12716","p__12717","map__12718","exit-actions","cljs.core/reverse","p1__12711#","entry-actions","tx-actions","actions","new-configuration","clojure.set.union","new-value","p1__12712#","statecharts.impl/-do-init","G__12720","statecharts.impl/initialize","p__12721","p__12722","map__12723","map__12724","statecharts.impl.initialize","exec","context","_opts","vec__12725","p__12728","map__12729","statecharts.impl/-transition-once","vec__12730","_pending-eventless-tx?","statecharts.impl/-transition-impl","opts","map__12734","_actions","G__12736","statecharts.impl/transition","p__12737","map__12738","statecharts.impl.transition","vec__12739","G__12742","statecharts.impl/valid-target?","e12743","e","cljs.core/ex-data","G__12745","statecharts.impl.validate_targets","current-path","transitions","cljs.core/vals","targets","seq__12746","chunk__12748","count__12749","i__12750","cljs.core/chunked-seq?","c__4638__auto__","cljs.core/chunk-first","cljs.core/chunk-rest","initial-node","seq__12752","chunk__12753","count__12754","i__12755","vec__12762","vec__12765","name","child","seq__12768","chunk__12769","count__12770","i__12771","vec__12778","vec__12781","statecharts.impl/matches","value","v1","v2"],"sourcesContent":["(ns statecharts.impl\n  (:require [malli.core :as ma]\n            [malli.transform :as mt]\n            [clojure.set]\n            [malli.error]\n            [statecharts.delayed\n             :as fsm.d\n             :refer [insert-delayed-transitions\n                     replace-delayed-place-holder\n                     scheduler?]]\n            [statecharts.utils :as u]\n            [statecharts.macros :refer [prog1]])\n  (:refer-clojure :exclude [send]))\n\n(defn canon-one-transition [x]\n  (if (map? x)\n    x\n    {:target x}))\n\n(defn canon-transitions [x]\n  (cond\n    (and (vector? x)\n         (some map? x))\n    (mapv canon-one-transition x)\n\n    (map? x)\n    [x]\n\n    :else\n    [{:target x}]))\n\n(defn canon-actions [x]\n  (if (vector? x)\n    x\n    [x]))\n\n(defn canon-event [x]\n  (if (map? x)\n    x\n    {:type x}))\n\n(def T_Actions\n  [:vector {:decode/fsm canon-actions}\n   [:fn ifn?]])\n\n(def T_Target\n  \"See `resolve-target` for the synatx of target definition.\"\n  [:or\n   keyword?\n   [:vector keyword?]])\n\n(def T_Transition\n  [:vector {:decode/fsm canon-transitions}\n   [:map {:closed true}\n    [:target {:optional true} T_Target]\n    [:guard {:optional true} [:fn ifn?]]\n    [:actions {:optional true} T_Actions]]])\n\n(def T_Entry\n  [:entry {:optional true} T_Actions])\n\n(def T_Exit\n  [:exit {:optional true} T_Actions])\n\n(def T_DelayExpression\n  [:or\n   int?\n   ;; when replaced as a\n   [:fn ifn?]])\n\n(def T_DelayedEvent\n  \"Generated internal event for delayed transitions.\"\n  [:tuple keyword? T_Target [:or int?\n                             ;; See delayed/generate-delayed-events\n                             ;; for why we use string instead of\n                             ;; delayed fn as the event key.\n                             :string]])\n\n(def T_Event\n  [:or keyword? T_DelayedEvent])\n\n(def T_Transitions\n  [:on {:optional true}\n   [:map-of T_Event T_Transition]])\n\n(def T_Initial\n  [:initial {:optional true} T_Target])\n\n(defn decode-delayed-map [m]\n  ;; {1000 :s1 2000 :s2}\n  ;; =>\n  ;; [{delay: 1000 :target :s1} {:delay 2000 :target :s2}]\n  (->> m\n       (mapcat (fn [[ms target]]\n                 (->> target\n                      canon-transitions\n                      (map #(assoc % :delay ms)))))\n       (into [])))\n\n#_(decode-delayed-map {1000 :s1 2000 :s2})\n#_(decode-delayed-map {1000 [{:target :s1\n                              :cond :c1}\n                             {:target :s2}]\n                       2000 :s2})\n\n(defn decode-delayed-transitions [x]\n  (if (map? x)\n    (decode-delayed-map x)\n    x))\n\n(def T_DelayedTransition\n  [:map {:closed true}\n   [:delay T_DelayExpression]\n   [:target {:optional true} T_Target]\n   [:guard {:optional true} [:fn ifn?]]\n   [:actions {:optional true} T_Actions]])\n\n(def T_DelayedTransitions\n  [:vector {:decode/fsm decode-delayed-transitions}\n   T_DelayedTransition])\n\n(def T_After\n  [:after {:optional true} T_DelayedTransitions])\n\n(def T_EventlessTransitions\n  [:always {:optional true} T_Transition])\n\n(defn insert-eventless-transitions [node]\n  (let [always (:always node)]\n    (if-not always\n      node\n      (update node :on assoc :fsm/always always))))\n\n(def T_Type\n  [:type {:optional true} [:enum :parallel]])\n\n(def T_States\n  [:schema\n   {:registry\n            {::state [:map {:closed true\n                            :decode/fsm {:leave (comp\n                                                 insert-eventless-transitions\n                                                 insert-delayed-transitions)}}\n                      T_After\n                      T_Entry\n                      T_Exit\n                      T_EventlessTransitions\n                      T_Transitions\n                      T_Initial\n                      ;; TODO: dispatch on type\n                      T_Type\n                      [:states {:optional true}\n                       [:map-of keyword? [:ref ::state]]]\n                      [:regions {:optional true}\n                       [:map-of keyword? [:ref ::state]]]]}}\n   [:map-of keyword? [:ref ::state]]])\n\n#_(ma/validate T_States {:s1 {:on {:e1 {:target :s2}}}\n                       :s2 {:initial :s2.1\n                            :states {:s2.1 {:on {:e2.1_2.2 {:target :s2.2}}}}}})\n\n(def T_Integrations\n  [:integrations {:optional true}\n   [:map {:closed true}\n    [:re-frame {:optional true}\n     [:map\n      [:path any?]\n      [:transition-event {:optional true} keyword?]\n      [:initialize-event {:optional true} keyword?]]]]])\n\n(def T_Machine\n  [:map {:decode/fsm {:leave (comp\n                              replace-delayed-place-holder\n                              insert-delayed-transitions)}}\n   T_Integrations\n   [:id keyword?]\n   [:context {:optional true} any?]\n   [:scheduler {:optional true} [:fn scheduler?]]\n   T_Transitions\n   T_After\n   T_Entry\n   T_Exit\n   T_Initial\n   ;; TODO: dispatch on type\n   T_Type\n   [:states {:optional true} T_States]\n   [:regions {:optional true} T_States]])\n\n(declare validate-targets)\n\n(defn machine\n  \"Create a canonical presentation of the machine using malli.\"\n  [orig]\n  (let [conformed (ma/decode T_Machine orig\n                    (mt/transformer\n                     mt/default-value-transformer\n                     {:name :fsm}))]\n    (when-not (ma/validate T_Machine conformed)\n      ;; TODO: ensure the initial target exists\n      (let [reason (malli.error/humanize (ma/explain T_Machine conformed))\n            machine-id (:id conformed)\n            msg (cond-> \"Invalid fsm machine spec:\"\n                  machine-id\n                  (str \" machine-id=\" machine-id))]\n        #?(:cljs\n           (js/console.warn msg (-> reason\n                                    (clj->js)\n                                    (js/JSON.stringify))))\n        (throw (ex-info msg reason))))\n    (validate-targets conformed)\n    conformed))\n\n;; TODO: use deftype. We use defrecord because it has a handy\n;; toString.\n(defrecord ContextAssignment [v])\n\n(defn assign\n  \"Wrap a function into a context assignment function.\"\n  [f]\n  (fn [& args]\n    (ContextAssignment. (apply f args))))\n\n(defn- internal-action? [action]\n  (and (map? action)\n       (= (some-> (:action action) namespace) \"fsm\")))\n\n(defn- execute-internal-action\n  [{:as _fsm :keys [scheduler]}\n   state\n   transition-event\n   {:as internal-action :keys [action event event-delay]}]\n  (when-not scheduler\n    (throw (ex-info\n               \"Delayed fsm without scheduler configured\"\n             {:action internal-action})))\n  (cond\n    (= action :fsm/schedule-event)\n    (let [event-delay (if (int? event-delay)\n                        event-delay\n                        (event-delay state transition-event))]\n      (fsm.d/schedule scheduler event event-delay))\n\n    (= action :fsm/unschedule-event)\n    (fsm.d/unschedule scheduler event)\n\n    :else\n    (throw (ex-info (str \"Unknown internal action \" action) internal-action))))\n\n(defn- execute\n  \"Execute the actions/entry/exit functions when transitioning.\"\n  ([fsm state event]\n   (execute fsm state event nil))\n  ([fsm state event {:keys [debug]}]\n   (reduce (fn [new-state action]\n             (if (internal-action? action)\n               (do\n                 (execute-internal-action fsm new-state event action)\n                 new-state)\n               (let [retval (action new-state event)]\n                 (if (instance? ContextAssignment retval)\n                   (.-v retval)\n                   new-state))))\n           (cond-> state\n             (not debug)\n             (dissoc :_actions))\n           (:_actions state))))\n\n(def PathElement\n  \"Schema of an element of a expanded path. We need the\n  transitions/exit/entry information to:\n  1. transitions: in a compound node, decide which level handles\n     the event\n  2. :id of each level to resolve the target state node.\n  3. entry/exit: collect the actions during a transtion transition.\"\n  [:map {:closed true}\n   [:id [:maybe keyword?]]\n   T_Transitions\n   T_Entry\n   T_Exit])\n\n(defn- parallel? [node]\n  (some-> (:type node)\n          (= :parallel)))\n\n(defn- compound? [node]\n  (contains? node :initial))\n\n(defn- atomic? [node]\n  (and (not (parallel? node))\n       (not (compound? node))))\n\n(defn path->_state\n  \"Calculate the _state value based on the node paths.\n\n  In our internal code, we need to represent the current state as a series of\n  nodes, but when presenting the current state to the user we need to extract the\n  simplest form.\"\n  [xs]\n  (let [indexed-xs (u/with-index (rest xs))\n        ret (->> indexed-xs\n                 (reduce\n                   (fn [accu [node i]]\n                     (if (parallel? node)\n                       (let [para-state (u/map-vals path->_state\n                                                    (:regions node))]\n                         (if (zero? i)\n                           ;; If the root is a para node: {:p1 :s1 :p2 :s2}\n                           [para-state]\n                           ;; If the non-root is a para node: {:p1 {:p2 :s2 :p3\n                           ;; :s3}}\n                           (update accu\n                                   (dec i)\n                                   (fn [id]\n                                     {id para-state}))))\n                       (conj accu (:id node))))\n                   []))]\n    (u/devectorize ret)))\n\n(defn check-or-throw [x k v & {:keys [] :as map}]\n  (when (nil? x)\n    (throw (ex-info (str \"Unknown fsm \" (name k) \" \" v) (assoc map k v)))))\n\n\n(defn resolve-target\n  \"Resolve the given transition target given the current state context.\n\n  Rules for resolving the target:\n  - If the target is nil, it's the same as the current state, a.k.a self-transition\n\n  - If the target is a vector and the first element is :>, it's an absolute path\n\n    (f :whatever [:> :s2]) => [:s2]\n\n  - If the target is a vector and the first element is not :>, it's an relative path\n\n    (f [:s1] [:s2]) => :s2\n    (f [:s1 :s1.1] [:s1.2]) => [:s1 :s1.2]\n\n  - If the target is a keyword, it's the same as an one-element vector\n\n    (f [:s1] :s2) => :s2\n    (f [:s1 :s1.1] :s1.2) => [:s1 :s1.2]\n\n  - If the target is a vector and the first element is :., it's a\n    child state of current node:\n\n    (f [:s1] [:. :s1.1]) => [:s1 :s1.1]\n\n  E.g. given current state [:s1 :s1.1] and a target of :s1.2, it\n  should resolve to [:s1 :s1.2]\"\n  [base target]\n  (let [base (u/ensure-vector base)\n        parent (vec (drop-last base))]\n    (cond\n      (nil? target)\n      base\n\n      (keyword? target)\n      (conj parent target)\n\n      (not (sequential? target))\n      (throw (ex-info \"Invalid fsm target\" {:target target}))\n\n      (= (first target) :>)\n      (vec (next target))\n\n      (= (first target) :.)\n      (vec (concat base (drop 1 target)))\n\n      :else\n      (vec (concat parent target)))))\n\n(defn absolute-target? [target]\n  (and (sequential? target)\n       (= (first target) :>)))\n\n(defn is-prefix? [short long]\n  (let [n (count short)]\n    (and (<= n (count long))\n         (= short (take n long)))))\n\n(defn external-self-transition-actions\n  \"Calculate the actions for an external self-transition.\n\n  if handler is on [:s1 :s1.1]\n  and current state is [:s1 :s1.1 :s1.1.1]\n  then we shall exit s1.1.1 s1.1 and entry s1.1 s1.1.1 again\n\n  if handler is on [:s1]\n  and current state is [:s1 :s1.1 :s1.1.1]\n  then we shall exit s1.1.1 s1.1 s1 and entry s1 s1.1 s1.1.1 again\n\n  if handler is on [:s2]\n  and current state is [:s2]\n  then we shall exit s2 and entry s2 again\n\n  if handler is on []\n  and current state is [:s2]\n  then we shall exit s2 Machine and entry Machine s2 again\n  \"\n  [handler nodes])\n\n(defn has-eventless-transition? [nodes]\n  (boolean (some #(get-in % [:on :fsm/always]) nodes)))\n\n(defn- updatev-last\n  \"Update the last element of a vector\"\n  [v f & args]\n  (apply update v (dec (count v)) f args))\n\n(def RT_NodePath\n  [:vector :keyword])\n\n(def RT_Node\n  [:map\n   [:path RT_NodePath]\n   [:on {:optional true} [:map-of :keyword :any]]\n   [:type :enum [:atomic :compound :parallel]]\n   [:entry {:optional true} :any]\n   [:exit {:optional true} :any]])\n\n(def RT_TX\n  [:map {:closed true}\n   [:source {:optional true} RT_NodePath]\n   [:target {:optional true} RT_NodePath]\n   [:domain {:optional true} RT_NodePath]\n   [:guard {:optional true} [:vector :fn]]\n   [:actions {:optional true} [:vector :fn]]])\n\n(def T_Configuration\n  [:set RT_NodePath])\n\n(defn add-node-type [node]\n  (let [type (cond\n               (parallel? node)\n               :parallel\n\n               (compound? node)\n               :compound\n\n               :else\n               :atomic)]\n    (assoc node :type type)))\n\n(defn resolve-node\n  ([root path]\n   (resolve-node root path false))\n  ([root path full?]\n   ;; [:s1 :s1.1]\n   (let [node (let [path (u/ensure-vector path)\n                    node (reduce\n                           (fn [current-root k]\n                             (cond\n                               (parallel? current-root)\n                               (get-in current-root [:regions k])\n\n                               (compound? current-root)\n                               (get-in current-root [:states k])\n\n                               :else\n                               (reduced nil)))\n                           root\n                           path)]\n                (some-> node\n                        (add-node-type)\n                        (assoc :path path)))]\n     (if full?\n       node\n       (some-> node\n               (select-keys [:on :entry :exit :type :path]))))))\n\n(defn _state->nodes [_state]\n  (loop [[head & more] (u/ensure-vector _state)\n         prefix []\n         ret (sorted-set)]\n    (cond\n      (keyword? head)\n      (let [current (conj prefix head)\n            ret (conj ret current)]\n        (if (seq more)\n          (recur more current ret)\n          ret))\n\n      (map? head)\n      (do\n        (assert (empty? more)\n          \"invalid _state, parallel state must be the last one\")\n        (into ret (mapcat (fn [[k v]]\n                            (let [prefix (conj prefix k)]\n                              (cons prefix\n                                    (map #(into prefix %) (_state->nodes v)))))\n                          head))))))\n\n(defn _state->configuration\n  ;; We always resolve the `_state` in a JIT manner, so the user has the\n  ;; flexibility to pass in a literal `_state` (and context) as data, instead of\n  ;; forcing the user to keep track of an opaque \"State\" object like xstate.\n  ;;\n  ;; E.g. the user pass in `[:s1 :s1.1]` then we would get a set of two nodes:\n  ;; - `[:s1]`\n  ;; - `[:s1 :s1.1]`\n  [fsm _state &\n   {:keys [no-resolve?]\n    :as _opt}]\n  (let [_state (u/ensure-vector _state)]\n    (let [paths (conj (_state->nodes _state) [])\n          ;; Always reslove to ensure all nodes are resolvable in the fsm. TODO:\n          ;; throw an exc here if resolve-node returns nil?\n          nodes (mapv #(resolve-node fsm %) paths)]\n      (if no-resolve?\n        paths\n        nodes))))\n\n(defn backtrack-ancestors-as-paths\n  \"Return a (maybe lazy) sequence of the node path with all its ancestors, starting from the\n  node and goes up.\"\n  [fsm path]\n  (reductions (fn [accu _]\n                (vec (drop-last accu)))\n              path\n              (range (count path))))\n\n(defn backtrack-ancestors-as-nodes\n  \"Like backtrack-ancestors-as-paths but resolves the paths into nodes.\"\n  [fsm path]\n  ;; [:s1 :s1.1 :s1.1.1]\n  (->> (backtrack-ancestors-as-paths fsm path)\n       (map #(resolve-node fsm %))))\n\n(defn find-least-common-compound-ancessor [fsm path1 path2]\n  (u/find-first (fn [anc]\n                  (is-prefix? anc path1))\n                (backtrack-ancestors-as-paths fsm path2)))\n\n(defn get-tx-domain\n  [fsm {:keys [source target] :as tx}]\n  (cond\n    ;; internal self transition\n    (nil? target)\n    nil\n\n    ;; external self transition\n    (= source target)\n    source\n\n    :else\n    (find-least-common-compound-ancessor fsm source target)))\n\n(defn select-one-tx\n  \"Given an atomic node and an event, find the first satistifed transition by\n  walking from the node and then its ancestors, until the root.\n\n  Return a two-tuple:\n  - The first element is the a boolean indicates whether any transition is found at\n    all (regarding it's satisfied or not)\n  - The second element is the found transition, if any.\n  \"\n  [fsm\n   {:keys [path]\n    :as node} state\n   {:keys [type]\n    :as event} input-event]\n  (let [first-satisfied-tx (fn [txs]\n                             (some (fn [{:keys [guard]\n                                         :as tx}]\n                                     (when (or (not guard)\n                                               (guard state input-event))\n                                       (dissoc tx :guard)))\n                                   txs))\n        found (volatile! false)\n        tx (when-let [{:keys [source target]\n                       :as tx}\n                      (some (fn [{:keys [path]\n                                  :as node}]\n                              (when-let [txs (seq (get-in node [:on type]))]\n                                (vreset! found true)\n                                (when-let [tx (first-satisfied-tx txs)]\n                                  (assoc tx :source path))))\n                            (backtrack-ancestors-as-nodes fsm (:path node)))]\n             (let [target-resolved (when target\n                                     (resolve-target source target))\n                   tx (-> tx\n                          (assoc :target target-resolved)\n                          (assoc :external? (or (absolute-target? target)\n                                                (= target-resolved source))))]\n               (assoc tx :domain (get-tx-domain fsm tx))))]\n    [@found tx]))\n\n(defn get-initial-path [{:keys [path initial] :as _node}]\n  (let [initial (u/ensure-vector initial)\n        initial (if (= (first initial) :.)\n                  (next initial)\n                  initial)]\n    (into path initial)))\n\n(defn add-ancestors-to-entry-set\n  [fsm domain path external?]\n  (->> (backtrack-ancestors-as-paths fsm path)\n       (take-while (fn [path]\n                     (and (not= path [])\n                          ;; exclude the domain node when not external,\n                          (or external?\n                              (not= domain path))\n                          (is-prefix? domain path))))))\n\n(defn compute-entry-set\n  [fsm txs]\n  (let [get-tx-entry-set\n        (fn [{:keys [target domain external?]\n              :as _tx}]\n          ;; target=nil means internal self-transtion, where no entry/exit would\n          ;; happen\n          (when target\n            (loop [entry-set #{target}\n                   seeds entry-set]\n              (let [exist? #(contains? entry-set %)\n                    new\n                    (->>\n                      seeds\n                      (map #(resolve-node fsm % true))\n                      (map\n                        (fn [{:keys [type path]\n                              :as node}]\n                          (remove exist?\n                            (concat\n                              (add-ancestors-to-entry-set fsm\n                                                          domain\n                                                          path\n                                                          external?)\n                              (case type\n                                :parallel\n                                (let [regions\n                                      (->> (:regions node)\n                                           keys\n                                           (map #(conj path %)))]\n                                  regions)\n\n                                :compound\n                                ;; for compound node that has no descedents in the\n                                ;; entry set, add its initial state to the next\n                                ;; seeds of next round of iteration.\n                                (when-not (some (fn [x]\n                                                  (and (not= path x)\n                                                       (is-prefix? path x)))\n                                                entry-set)\n                                  [(get-initial-path node)])\n\n                                ;; an atomic node, nothing to add for it.\n                                nil)))))\n                      (reduce concat))\n\n                    new (clojure.set/difference (set new) entry-set)]\n                (if-not (empty? new)\n                  (recur\n                    ;; include the new nodes\n                    (into entry-set new)\n                    ;; new the new nodes in this iteration as the new seeds\n                    new)\n                  entry-set)))))]\n    (->> (map get-tx-entry-set txs)\n         (reduce into (sorted-set)))))\n\n(defn get-actions [fsm path k]\n  (let [node (resolve-node fsm path)]\n    (k node)))\n\n(defn get-entry-actions [fsm entry-set]\n  (->> entry-set\n       (mapcat #(get-actions fsm % :entry))))\n\n(defn simple-state [x]\n  (if (and (sequential? x)\n           (= (count x) 1))\n    (first x)\n    x))\n\n(defn configuration->_state\n  \"Represent the current configuration in a user-friendly form. It's the reverse\n  operation of `_state->configuration`.\n  \"\n  [fsm configuration]\n   (-> (loop [paths configuration\n              node fsm\n              _state []\n              parent-compound? false]\n         (let [paths (into [] (remove empty? paths))]\n           (cond\n             (parallel? node)\n             (let [children (:regions node)\n                   groups (group-by first paths)\n                   parallel-state\n                   (u/map-kv-vals (fn [k region]\n                                    (configuration->_state region\n                                                           (map\n                                                             ;; remove the common\n                                                             ;; prefix\n                                                             next\n                                                             (get groups k))))\n                                  children)]\n               ;; If the parent node of the parallel node is a compound node (i.e.\n               ;; the parallel node is not the root), the notation is a\n               ;; single-valued map, e.g. [:s1 {:s1.1 {:p1 :x :p2 :y}}]\n               (if parent-compound?\n                 (updatev-last _state\n                               (fn [k]\n                                 {k parallel-state}))\n                 parallel-state))\n\n             (compound? node)\n             (do\n               (let [ks (set (map first paths))\n                     k (first ks)]\n                 (assert (= (count ks) 1) (str \"invalid paths: \" paths))\n                 (let [paths (remove empty? (map next paths))]\n                   (if (seq paths)\n                     (recur\n                       paths\n                       (get-in node [:states k])\n                       (conj _state k)\n                       true)\n                     (conj _state k)))))\n\n             :else\n             ;; some atomic node\n             (conj _state (ffirst paths)))))\n       simple-state))\n\n(defn -do-transition\n  [fsm\n   {:keys [_state]\n    :as state} event input-event\n   ignore-unknown-event?]\n  (let [configuration (_state->configuration fsm _state)\n        atomic-nodes (filter #(= (:type %) :atomic) configuration)\n        txs (->> atomic-nodes\n                 (map #(select-one-tx fsm % state event input-event)))\n        _ (when-not (->> txs\n                         (map first)\n                         (some identity))\n            (throw (ex-info (str \"fsm \" (:id fsm) \" got unknown event \" (:type event))\n                            {:_state _state})))\n        txs (->> txs\n                 (map second)\n                 (remove nil?))]\n    (if (not (seq? txs))\n      [_state [] false]\n      (let [exit-set (->> configuration\n                          ;; all active nodes that is covered by some tx domain\n                          ;; should\n                          ;; exit itself.\n                          (filter (fn [{:keys [path]\n                                        :as node}]\n                                    (some\n                                      (fn [{:keys [target domain external?]\n                                            :as tx}]\n                                        (cond\n                                          (= path [])\n                                          ;; only exit the root when the target is\n                                          ;; the root itself\n                                          (and external?\n                                               (= target []))\n\n                                          (= domain path)\n                                          ;; only include the domain itself\n                                          ;; when it's an external transition\n                                          external?\n\n                                          :else\n                                          (is-prefix? domain path)))\n                                      txs)))\n                          (map :path)\n                          (into (sorted-set)))\n            entry-set (compute-entry-set fsm txs)\n            exit-actions (->> exit-set\n                              reverse\n                              (mapcat #(get-actions fsm % :exit)))\n            entry-actions (get-entry-actions fsm entry-set)\n            tx-actions (->> txs\n                            (mapcat :actions))\n            actions (concat exit-actions tx-actions entry-actions)\n            ;; _ #p exit-set\n            ;; _ #p entry-set\n            new-configuration (-> (->> (map :path configuration)\n                                       (into #{}))\n                                  (clojure.set/difference exit-set)\n                                  (clojure.set/union entry-set))\n            new-value (configuration->_state fsm new-configuration)]\n        [new-value actions\n         (has-eventless-transition? (map #(resolve-node fsm %)\n                                      entry-set))]))))\n\n(defn -do-init\n  [fsm]\n  (let [tx            {:source    []\n                       :target    []\n                       :external? true\n                       :domain    []}\n        entry-set     (compute-entry-set fsm [tx])\n        entry-actions (get-entry-actions fsm entry-set)\n        _state        (configuration->_state fsm entry-set)]\n    [_state entry-actions]))\n\n(defn initialize\n  ([fsm]\n   (initialize fsm nil))\n  ([{:keys [initial type]\n     :as fsm}\n    {:keys [exec debug context]\n     :or {exec true\n          context nil}\n     :as _opts}]\n   (let [context (if (some? context)\n                   context\n                   (:context fsm))\n         event {:type :fsm/init}\n         [_state actions] (-do-init fsm)\n         state (assoc context\n                 :_state _state\n                 :_actions actions)]\n     (if exec\n       (execute fsm state event {:debug debug})\n       state))))\n\n(defn -transition-once\n  \"Do the transition, but would not follow new eventless transitions defined on\n  the target state.\"\n  [fsm state event\n   {:keys [exec debug input-event ignore-unknown-event?]\n    :or {exec true}}]\n  (let [;; input-event is set to the original event when event is :fsm/always for\n        ;; eventless transitions. We pass both along because even in eventless\n        ;; transitions, the actions function may want to access the original event\n        ;; instead of :fsm/always\n        input-event\n        (or input-event event)\n\n        [new-value actions _pending-eventless-tx?]\n        (-do-transition fsm\n                        state\n                        event\n                        input-event\n                        ignore-unknown-event?)\n\n        new-state (assoc state\n                    :_state new-value\n                    :_pending-eventless-tx? _pending-eventless-tx?\n                    :_prev-state (:_state state)\n                    :_actions actions)]\n    (if exec\n      (execute\n        fsm\n        new-state\n        input-event\n        {:debug debug})\n      new-state)))\n\n(defn -transition-impl\n  \"Return the new state and the actions to execute.\"\n  [fsm state input-event opts]\n  ;; The loop is used to execute eventless transitions.\n  (loop [i 0\n         state (dissoc state :_actions)\n         actions []]\n\n    (when (> i 10)\n      ;; Prevent bugs in application's code that two states uses eventless\n      ;; transitions and the states jumps back and forth between them.\n      (throw (ex-info (str \"Possible dead loop on event\" (:type input-event))\n                      {:state (:_state state)})))\n\n    (let [event\n          (if (zero? i)\n            input-event\n            ;; The first iteration of the loop is the real input event, while the\n            ;; following ones are eventless transitions.\n            {:type :fsm/always})\n\n          {:keys [_actions _pending-eventless-tx?]\n           :as state}\n          (-transition-once fsm state event opts)\n\n          actions\n          (if _actions\n            (into actions _actions)\n            actions)]\n      (if _pending-eventless-tx?\n        (recur (inc i) (dissoc state :_pending-eventless-tx?) actions)\n        [state actions]))))\n\n(defn transition\n  \"Given a machine with its current state, trigger a transition to the\n  next state based on the given event.\n\n  The nature and purpose of the transition impl is to get two outputs:\n  - the new state\n  - the actions to execute\n\n  By default it executes all actions, unless the `exec` opt is false,\n  in which case it is a pure function.\"\n  ([fsm state event]\n   (transition fsm state event nil))\n  ([fsm state event\n    {:as opts\n     :keys [exec debug]\n     :or {exec true}}]\n   (let\n     [input-event\n      (canon-event event)\n\n      opts\n      (assoc opts :input-event input-event)\n\n      [new-state actions]\n      (-transition-impl\n        fsm\n        (dissoc state :_actions)\n        input-event\n        opts)]\n     ;; get rid of the internal fields\n     (cond-> (dissoc new-state :_pending-eventless-tx? :_prev-state)\n       (or (not exec) debug)\n       (assoc :_actions actions)))))\n\n(defn- valid-target? [node path]\n  (try\n    (when-not (resolve-node node path)\n      (throw (ex-info \"node not found\" {:path path ::type :invalid-path})))\n    true\n    (catch #?(:clj clojure.lang.ExceptionInfo :cljs js/Error) e\n      (if (= (::type (ex-data e)) :invalid-path)\n        false\n        (throw e)))))\n\n(defn validate-targets\n  \"Walk the fsm and try to resolve all transition targets. Raise an\n  exception if any target is invalid.\"\n  ([root]\n   (validate-targets root root []))\n  ([root node current-path]\n   (do\n     (let [transitions (mapcat identity (-> node :on vals))\n           targets (->> transitions\n                        (map :target)\n                        ;; nil target target means self-transition,\n                        ;; which is always valid.\n                        (remove nil?))]\n       (when (seq targets)\n         (doseq [target targets\n                 :let [target (resolve-target current-path target)]]\n           (when-not (valid-target? root target)\n             (throw (ex-info (str \"Invalid target \" target)\n                      {:target target :state current-path}))))))\n     (when-let [initial (:initial node)]\n       (let [initial-node (get-in node [:states initial])]\n         (when-not initial-node\n           (throw (ex-info (str \"Invalid initial target \" initial)\n                    {:initial initial :state current-path})))))\n     (doseq [[name child] (:states node)]\n       (validate-targets root child (conj current-path name)))\n     (when (parallel? node)\n       (doseq [[name child] (:regions node)]\n         (validate-targets root child (conj current-path name)))))))\n\n(defn matches [state value]\n  (let [v1 (u/ensure-vector (:value state))\n        v2 (u/ensure-vector value)]\n    (is-prefix? v2 v1)))\n\n(comment\n  (ma/validate keyword? :a)\n\n  (def m1\n    {:id :foo\n     :initial :s1\n     :states {:s1 {:on {:e1 :s2\n                        :e12 {:target :s3\n                              :actions :a12}}}\n              :s2 {:on {:e2 {:target :s3\n                             :actions [:a31 :a32]}}}}})\n  (machine m1)\n  (ma/validate T_Machine m1)\n  (ma/explain T_Machine m1)\n  (ma/validate T_Machine (machine m1))\n  (ma/explain T_Machine (machine m1))\n\n  ())\n"]}