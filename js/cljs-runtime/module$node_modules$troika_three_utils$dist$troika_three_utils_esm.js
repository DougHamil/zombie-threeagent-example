shadow$provide.module$node_modules$troika_three_utils$dist$troika_three_utils_esm=function(global,require,module,exports){function expandShaderIncludes(source){return source.replace(/^[ \t]*#include +<([\w\d./]+)>/gm,function(match,include){return(include=_three.ShaderChunk[include])?expandShaderIncludes(include):match})}function createDerivedMaterial(baseMaterial,options){const optionsKey=getKeyForOptions(options);let ctorsByDerivation=CONSTRUCTOR_CACHE.get(baseMaterial);ctorsByDerivation||CONSTRUCTOR_CACHE.set(baseMaterial,
ctorsByDerivation=Object.create(null));if(ctorsByDerivation[optionsKey])return new ctorsByDerivation[optionsKey];const privateBeforeCompileProp=`_onBeforeCompile${optionsKey}`,onBeforeCompile=function(shaderInfo){baseMaterial.onBeforeCompile.call(this,shaderInfo);const cacheKey=optionsKey+"|||"+shaderInfo.vertexShader+"|||"+shaderInfo.fragmentShader;var upgradedShaders=SHADER_UPGRADE_CACHE[cacheKey];upgradedShaders||(upgradedShaders=upgradeShaders(shaderInfo,options,optionsKey),upgradedShaders=SHADER_UPGRADE_CACHE[cacheKey]=
upgradedShaders);shaderInfo.vertexShader=upgradedShaders.vertexShader;shaderInfo.fragmentShader=upgradedShaders.fragmentShader;assign(shaderInfo.uniforms,this.uniforms);options.timeUniform&&(shaderInfo.uniforms[options.timeUniform]={get value(){return Date.now()-epoch}});if(this[privateBeforeCompileProp])this[privateBeforeCompileProp](shaderInfo)},DerivedMaterial=function(){return derive(options.chained?baseMaterial:baseMaterial.clone())},derive=function(base){const derived=Object.create(base,descriptor);
Object.defineProperty(derived,"baseMaterial",{value:baseMaterial});Object.defineProperty(derived,"id",{value:materialInstanceId++});var JSCompiler_inline_result=4294967295*Math.random()|0;const d1=4294967295*Math.random()|0,d2=4294967295*Math.random()|0,d3=4294967295*Math.random()|0;JSCompiler_inline_result=(_lut[JSCompiler_inline_result&255]+_lut[JSCompiler_inline_result>>8&255]+_lut[JSCompiler_inline_result>>16&255]+_lut[JSCompiler_inline_result>>24&255]+"-"+_lut[d1&255]+_lut[d1>>8&255]+"-"+_lut[d1>>
16&15|64]+_lut[d1>>24&255]+"-"+_lut[d2&63|128]+_lut[d2>>8&255]+"-"+_lut[d2>>16&255]+_lut[d2>>24&255]+_lut[d3&255]+_lut[d3>>8&255]+_lut[d3>>16&255]+_lut[d3>>24&255]).toUpperCase();derived.uuid=JSCompiler_inline_result;derived.uniforms=assign({},base.uniforms,options.uniforms);derived.defines=assign({},base.defines,options.defines);derived.defines[`TROIKA_DERIVED_MATERIAL_${optionsKey}`]="";derived.extensions=assign({},base.extensions,options.extensions);derived._listeners=void 0;return derived},descriptor=
{constructor:{value:DerivedMaterial},isDerivedMaterial:{value:!0},customProgramCacheKey:{writable:!0,configurable:!0,value:function(){return optionsKey}},onBeforeCompile:{get(){return onBeforeCompile},set(fn){this[privateBeforeCompileProp]=fn}},copy:{writable:!0,configurable:!0,value:function(source){baseMaterial.copy.call(this,source);baseMaterial.isShaderMaterial||baseMaterial.isDerivedMaterial||(assign(this.extensions,source.extensions),assign(this.defines,source.defines),assign(this.uniforms,
_three.UniformsUtils.clone(source.uniforms)));return this}},clone:{writable:!0,configurable:!0,value:function(){const newBase=new baseMaterial.constructor;return derive(newBase).copy(this)}},getDepthMaterial:{writable:!0,configurable:!0,value:function(){let depthMaterial=this._depthMaterial;depthMaterial||(depthMaterial=this._depthMaterial=createDerivedMaterial(baseMaterial.isDerivedMaterial?baseMaterial.getDepthMaterial():new _three.MeshDepthMaterial({depthPacking:_three.RGBADepthPacking}),options),
depthMaterial.defines.IS_DEPTH_MATERIAL="",depthMaterial.uniforms=this.uniforms);return depthMaterial}},getDistanceMaterial:{writable:!0,configurable:!0,value:function(){let distanceMaterial=this._distanceMaterial;distanceMaterial||(distanceMaterial=this._distanceMaterial=createDerivedMaterial(baseMaterial.isDerivedMaterial?baseMaterial.getDistanceMaterial():new _three.MeshDistanceMaterial,options),distanceMaterial.defines.IS_DISTANCE_MATERIAL="",distanceMaterial.uniforms=this.uniforms);return distanceMaterial}},
dispose:{writable:!0,configurable:!0,value(){const {_depthMaterial,_distanceMaterial}=this;_depthMaterial&&_depthMaterial.dispose();_distanceMaterial&&_distanceMaterial.dispose();baseMaterial.dispose.call(this)}}};ctorsByDerivation[optionsKey]=DerivedMaterial;return new DerivedMaterial}function upgradeShaders({vertexShader,fragmentShader},options,key){let {vertexDefs,vertexMainIntro,vertexMainOutro,vertexTransform,fragmentDefs,fragmentMainIntro,fragmentMainOutro,fragmentColorTransform,customRewriter,
timeUniform}=options;vertexDefs=vertexDefs||"";vertexMainIntro=vertexMainIntro||"";vertexMainOutro=vertexMainOutro||"";fragmentDefs=fragmentDefs||"";fragmentMainIntro=fragmentMainIntro||"";fragmentMainOutro=fragmentMainOutro||"";if(vertexTransform||customRewriter)vertexShader=expandShaderIncludes(vertexShader);if(fragmentColorTransform||customRewriter)fragmentShader=fragmentShader.replace(/^[ \t]*#include <((?:tonemapping|encodings|fog|premultiplied_alpha|dithering)_fragment)>/gm,"\n//!BEGIN_POST_CHUNK $1\n$\x26\n//!END_POST_CHUNK\n"),
fragmentShader=expandShaderIncludes(fragmentShader);customRewriter&&(fragmentShader=customRewriter({vertexShader,fragmentShader}),vertexShader=fragmentShader.vertexShader,fragmentShader=fragmentShader.fragmentShader);if(fragmentColorTransform){let postChunks=[];fragmentShader=fragmentShader.replace(/^\/\/!BEGIN_POST_CHUNK[^]+?^\/\/!END_POST_CHUNK/gm,match=>{postChunks.push(match);return""});fragmentMainOutro=`${fragmentColorTransform}\n${postChunks.join("\n")}\n${fragmentMainOutro}`}timeUniform&&
(options=`\nuniform float ${timeUniform};\n`,vertexDefs=options+vertexDefs,fragmentDefs=options+fragmentDefs);vertexTransform&&(vertexDefs=`${vertexDefs}
void troikaVertexTransform${key}(inout vec3 position, inout vec3 normal, inout vec2 uv) {
  ${vertexTransform}
}
`,vertexMainIntro=`
troika_position_${key} = vec3(position);
troika_normal_${key} = vec3(normal);
troika_uv_${key} = vec2(uv);
troikaVertexTransform${key}(troika_position_${key}, troika_normal_${key}, troika_uv_${key});
${vertexMainIntro}
`,vertexShader=`vec3 troika_position_${key};
vec3 troika_normal_${key};
vec2 troika_uv_${key};
${vertexShader}
`.replace(/\b(position|normal|uv)\b/g,(match,match1,index,fullStr)=>/\battribute\s+vec[23]\s+$/.test(fullStr.substr(0,index))?match1:`troika_${match1}_${key}`));vertexShader=injectIntoShaderCode(vertexShader,key,vertexDefs,vertexMainIntro,vertexMainOutro);fragmentShader=injectIntoShaderCode(fragmentShader,key,fragmentDefs,fragmentMainIntro,fragmentMainOutro);return{vertexShader,fragmentShader}}function injectIntoShaderCode(shaderCode,id,defs,intro,outro){if(intro||outro||defs)shaderCode=shaderCode.replace(voidMainRegExp,
`
${defs}
void troikaOrigMain${id}() {`),shaderCode+=`
void main() {
  ${intro}
  troikaOrigMain${id}();
  ${outro}
}`;return shaderCode}function optionsJsonReplacer(key,value){return"uniforms"===key?void 0:"function"===typeof value?value.toString():value}function getKeyForOptions(options){options=JSON.stringify(options,optionsJsonReplacer);let id=optionsHashesToIds.get(options);null==id&&optionsHashesToIds.set(options,id=++_idCtr);return id}Object.defineProperty(exports,"__esModule",{value:!0});exports.createDerivedMaterial=createDerivedMaterial;exports.expandShaderIncludes=expandShaderIncludes;exports.getShaderUniformTypes=
function(shader){let uniformRE=/\buniform\s+(int|float|vec[234])\s+([A-Za-z_][\w]*)/g,uniforms=Object.create(null),match;for(;null!==(match=uniformRE.exec(shader));)uniforms[match[2]]=match[1];return uniforms};exports.getShadersForMaterial=function(material){let builtinType=MATERIAL_TYPES_TO_SHADERS[material.type];return builtinType?_three.ShaderLib[builtinType]:material};exports.invertMatrix4=function(srcMatrix,tgtMatrix=new _three.Matrix4){"function"===typeof tgtMatrix.invert?tgtMatrix.copy(srcMatrix).invert():
tgtMatrix.getInverse(srcMatrix);return tgtMatrix};exports.voidMainRegExp=exports.BezierMesh=void 0;var _three=require("module$node_modules$three$build$three_module");const voidMainRegExp=/\bvoid\s+main\s*\(\s*\)\s*{/g;exports.voidMainRegExp=voidMainRegExp;const _lut=[];for(global=0;256>global;global++)_lut[global]=(16>global?"0":"")+global.toString(16);const assign=Object.assign||function(){let target=arguments[0];for(let i=1,len=arguments.length;i<len;i++){let source=arguments[i];if(source)for(let prop in source)source.hasOwnProperty(prop)&&
(target[prop]=source[prop])}return target},epoch=Date.now(),CONSTRUCTOR_CACHE=new WeakMap,SHADER_UPGRADE_CACHE=new Map;let materialInstanceId=1E10,_idCtr=0;const optionsHashesToIds=new Map,MATERIAL_TYPES_TO_SHADERS={MeshDepthMaterial:"depth",MeshDistanceMaterial:"distanceRGBA",MeshNormalMaterial:"normal",MeshBasicMaterial:"basic",MeshLambertMaterial:"lambert",MeshPhongMaterial:"phong",MeshToonMaterial:"toon",MeshStandardMaterial:"physical",MeshPhysicalMaterial:"physical",MeshMatcapMaterial:"matcap",
LineBasicMaterial:"basic",LineDashedMaterial:"dashed",PointsMaterial:"points",ShadowMaterial:"shadow",SpriteMaterial:"sprite"};let geometry=null;const defaultBaseMaterial=new _three.MeshStandardMaterial({color:16777215,side:_three.DoubleSide});class BezierMesh extends _three.Mesh{static getGeometry(){return geometry||(geometry=(new _three.CylinderBufferGeometry(1,1,1,6,64)).translate(0,.5,0))}constructor(){super(BezierMesh.getGeometry(),defaultBaseMaterial);this.pointA=new _three.Vector3;this.controlA=
new _three.Vector3;this.controlB=new _three.Vector3;this.pointB=new _three.Vector3;this.radius=.01;this.dashArray=new _three.Vector2;this.dashOffset=0;this.frustumCulled=!1}get material(){let derivedMaterial=this._derivedMaterial;const baseMaterial=this._baseMaterial||this._defaultMaterial||(this._defaultMaterial=defaultBaseMaterial.clone());derivedMaterial&&derivedMaterial.baseMaterial===baseMaterial||(derivedMaterial=this._derivedMaterial=createDerivedMaterial(baseMaterial,{chained:!0,uniforms:{pointA:{value:new _three.Vector3},
controlA:{value:new _three.Vector3},controlB:{value:new _three.Vector3},pointB:{value:new _three.Vector3},radius:{value:.01},dashing:{value:new _three.Vector3}},vertexDefs:"\nuniform vec3 pointA;\nuniform vec3 controlA;\nuniform vec3 controlB;\nuniform vec3 pointB;\nuniform float radius;\nvarying float bezierT;\n\nvec3 cubicBezier(vec3 p1, vec3 c1, vec3 c2, vec3 p2, float t) {\n  float t2 \x3d 1.0 - t;\n  float b0 \x3d t2 * t2 * t2;\n  float b1 \x3d 3.0 * t * t2 * t2;\n  float b2 \x3d 3.0 * t * t * t2;\n  float b3 \x3d t * t * t;\n  return b0 * p1 + b1 * c1 + b2 * c2 + b3 * p2;\n}\n\nvec3 cubicBezierDerivative(vec3 p1, vec3 c1, vec3 c2, vec3 p2, float t) {\n  float t2 \x3d 1.0 - t;\n  return -3.0 * p1 * t2 * t2 +\n    c1 * (3.0 * t2 * t2 - 6.0 * t2 * t) +\n    c2 * (6.0 * t2 * t - 3.0 * t * t) +\n    3.0 * p2 * t * t;\n}\n",
vertexTransform:'\nfloat t \x3d position.y;\nbezierT \x3d t;\nvec3 bezierCenterPos \x3d cubicBezier(pointA, controlA, controlB, pointB, t);\nvec3 bezierDir \x3d normalize(cubicBezierDerivative(pointA, controlA, controlB, pointB, t));\n\n// Make "sideways" always perpendicular to the camera ray; this ensures that any twists\n// in the cylinder occur where you won\'t see them: \nvec3 viewDirection \x3d normalMatrix * vec3(0.0, 0.0, 1.0);\nif (bezierDir \x3d\x3d viewDirection) {\n  bezierDir \x3d normalize(cubicBezierDerivative(pointA, controlA, controlB, pointB, t \x3d\x3d 1.0 ? t - 0.0001 : t + 0.0001));\n}\nvec3 sideways \x3d normalize(cross(bezierDir, viewDirection));\nvec3 upish \x3d normalize(cross(sideways, bezierDir));\n\n// Build a matrix for transforming this disc in the cylinder:\nmat4 discTx;\ndiscTx[0].xyz \x3d sideways * radius;\ndiscTx[1].xyz \x3d bezierDir * radius;\ndiscTx[2].xyz \x3d upish * radius;\ndiscTx[3].xyz \x3d bezierCenterPos;\ndiscTx[3][3] \x3d 1.0;\n\n// Apply transform, ignoring original y\nposition \x3d (discTx * vec4(position.x, 0.0, position.z, 1.0)).xyz;\nnormal \x3d normalize(mat3(discTx) * normal);\n',
fragmentDefs:"\nuniform vec3 dashing;\nvarying float bezierT;\n",fragmentMainIntro:"\nif (dashing.x + dashing.y \x3e 0.0) {\n  float dashFrac \x3d mod(bezierT - dashing.z, dashing.x + dashing.y);\n  if (dashFrac \x3e dashing.x) {\n    discard;\n  }\n}\n"}),baseMaterial.addEventListener("dispose",function onDispose(){baseMaterial.removeEventListener("dispose",onDispose);derivedMaterial.dispose()}));return derivedMaterial}set material(baseMaterial){this._baseMaterial=baseMaterial}get customDepthMaterial(){return this.material.getDepthMaterial()}get customDistanceMaterial(){return this.material.getDistanceMaterial()}onBeforeRender(shaderInfo){({uniforms:shaderInfo}=
this.material);const {pointA,controlA,controlB,pointB,radius,dashArray,dashOffset}=this;shaderInfo.pointA.value.copy(pointA);shaderInfo.controlA.value.copy(controlA);shaderInfo.controlB.value.copy(controlB);shaderInfo.pointB.value.copy(pointB);shaderInfo.radius.value=radius;shaderInfo.dashing.value.set(dashArray.x,dashArray.y,dashOffset||0)}raycast(raycaster,intersects){}}exports.BezierMesh=BezierMesh}
//# sourceMappingURL=module$node_modules$troika_three_utils$dist$troika_three_utils_esm.js.map
