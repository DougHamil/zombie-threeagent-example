shadow$provide.module$node_modules$three$examples$jsm$loaders$GLTFLoader=function(global,require,module,exports){function GLTFRegistry(){let objects={};return{get:function(key){return objects[key]},add:function(key,object){objects[key]=object},remove:function(key){delete objects[key]},removeAll:function(){objects={}}}}function resolveURL(url,path){if("string"!==typeof url||""===url)return"";/^https?:\/\//i.test(path)&&/^\//.test(url)&&(path=path.replace(/(^https?:\/\/[^\/]+).*/i,"$1"));return/^(https?:)?\/\//i.test(url)||
/^data:.*,.*$/i.test(url)||/^blob:.*$/i.test(url)?url:path+url}function createDefaultMaterial(cache){void 0===cache.DefaultMaterial&&(cache.DefaultMaterial=new _three.MeshStandardMaterial({color:16777215,emissive:0,metalness:1,roughness:1,transparent:!1,depthTest:!0,side:_three.FrontSide}));return cache.DefaultMaterial}function addUnknownExtensionsToUserData(knownExtensions,object,objectDef){for(const name in objectDef.extensions)void 0===knownExtensions[name]&&(object.userData.gltfExtensions=object.userData.gltfExtensions||
{},object.userData.gltfExtensions[name]=objectDef.extensions[name])}function assignExtrasToUserData(object,gltfDef){void 0!==gltfDef.extras&&("object"===typeof gltfDef.extras?Object.assign(object.userData,gltfDef.extras):console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, "+gltfDef.extras))}function addMorphTargets(geometry,targets,parser){let hasMorphPosition=!1,hasMorphNormal=!1;for(let i=0,il=targets.length;i<il;i++){var target=targets[i];void 0!==target.POSITION&&(hasMorphPosition=
!0);void 0!==target.NORMAL&&(hasMorphNormal=!0);if(hasMorphPosition&&hasMorphNormal)break}if(!hasMorphPosition&&!hasMorphNormal)return Promise.resolve(geometry);target=[];const pendingNormalAccessors=[];for(let i=0,il=targets.length;i<il;i++){var target$jscomp$0=targets[i];if(hasMorphPosition){const pendingAccessor=void 0!==target$jscomp$0.POSITION?parser.getDependency("accessor",target$jscomp$0.POSITION):geometry.attributes.position;target.push(pendingAccessor)}hasMorphNormal&&(target$jscomp$0=void 0!==
target$jscomp$0.NORMAL?parser.getDependency("accessor",target$jscomp$0.NORMAL):geometry.attributes.normal,pendingNormalAccessors.push(target$jscomp$0))}return Promise.all([Promise.all(target),Promise.all(pendingNormalAccessors)]).then(function(accessors){const morphPositions=accessors[0];accessors=accessors[1];hasMorphPosition&&(geometry.morphAttributes.position=morphPositions);hasMorphNormal&&(geometry.morphAttributes.normal=accessors);geometry.morphTargetsRelative=!0;return geometry})}function createPrimitiveKey(primitiveDef){const dracoExtension=
primitiveDef.extensions&&primitiveDef.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION];return dracoExtension?"draco:"+dracoExtension.bufferView+":"+dracoExtension.indices+":"+createAttributesKey(dracoExtension.attributes):primitiveDef.indices+":"+createAttributesKey(primitiveDef.attributes)+":"+primitiveDef.mode}function createAttributesKey(attributes){let attributesKey="";const keys=Object.keys(attributes).sort();for(let i=0,il=keys.length;i<il;i++)attributesKey+=keys[i]+":"+attributes[keys[i]]+
";";return attributesKey}function getNormalizedComponentScale(constructor){switch(constructor){case Int8Array:return 1/127;case Uint8Array:return 1/255;case Int16Array:return 1/32767;case Uint16Array:return 1/65535;default:throw Error("THREE.GLTFLoader: Unsupported normalized accessor component type.");}}function buildNodeHierachy(nodeId,parentObject,json,parser){const nodeDef=json.nodes[nodeId];return parser.getDependency("node",nodeId).then(function(node){if(void 0===nodeDef.skin)return node;let skinEntry;
return parser.getDependency("skin",nodeDef.skin).then(function(skin){skinEntry=skin;skin=[];for(let i=0,il=skinEntry.joints.length;i<il;i++)skin.push(parser.getDependency("node",skinEntry.joints[i]));return Promise.all(skin)}).then(function(jointNodes){node.traverse(function(mesh){if(mesh.isMesh){var bones=[],boneInverses=[];for(let j=0,jl=jointNodes.length;j<jl;j++){var jointNode=jointNodes[j];jointNode?(bones.push(jointNode),jointNode=new _three.Matrix4,void 0!==skinEntry.inverseBindMatrices&&jointNode.fromArray(skinEntry.inverseBindMatrices.array,
16*j),boneInverses.push(jointNode)):console.warn('THREE.GLTFLoader: Joint "%s" could not be found.',skinEntry.joints[j])}mesh.bind(new _three.Skeleton(bones,boneInverses),mesh.matrixWorld)}});return node})}).then(function(node){parentObject.add(node);const pending=[];if(nodeDef.children){const children=nodeDef.children;for(let i=0,il=children.length;i<il;i++)pending.push(buildNodeHierachy(children[i],node,json,parser))}return Promise.all(pending)})}function computeBounds(geometry,primitiveDef,parser){var attributes=
primitiveDef.attributes;const box=new _three.Box3;if(void 0!==attributes.POSITION){attributes=parser.json.accessors[attributes.POSITION];var min$jscomp$0=attributes.min,max$jscomp$0=attributes.max;if(void 0!==min$jscomp$0&&void 0!==max$jscomp$0){box.set(new _three.Vector3(min$jscomp$0[0],min$jscomp$0[1],min$jscomp$0[2]),new _three.Vector3(max$jscomp$0[0],max$jscomp$0[1],max$jscomp$0[2]));attributes.normalized&&(attributes=getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[attributes.componentType]),
box.min.multiplyScalar(attributes),box.max.multiplyScalar(attributes));primitiveDef=primitiveDef.targets;if(void 0!==primitiveDef){attributes=new _three.Vector3;min$jscomp$0=new _three.Vector3;for(let i=0,il=primitiveDef.length;i<il;i++)if(max$jscomp$0=primitiveDef[i],void 0!==max$jscomp$0.POSITION){max$jscomp$0=parser.json.accessors[max$jscomp$0.POSITION];const min=max$jscomp$0.min,max=max$jscomp$0.max;void 0!==min&&void 0!==max?(min$jscomp$0.setX(Math.max(Math.abs(min[0]),Math.abs(max[0]))),min$jscomp$0.setY(Math.max(Math.abs(min[1]),
Math.abs(max[1]))),min$jscomp$0.setZ(Math.max(Math.abs(min[2]),Math.abs(max[2]))),max$jscomp$0.normalized&&(max$jscomp$0=getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[max$jscomp$0.componentType]),min$jscomp$0.multiplyScalar(max$jscomp$0)),attributes.max(min$jscomp$0)):console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")}box.expandByVector(attributes)}geometry.boundingBox=box;parser=new _three.Sphere;box.getCenter(parser.center);parser.radius=box.min.distanceTo(box.max)/
2;geometry.boundingSphere=parser}else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")}}function addPrimitiveAttributes(geometry,primitiveDef,parser){function assignAttributeAccessor(accessorIndex,attributeName){return parser.getDependency("accessor",accessorIndex).then(function(accessor){geometry.setAttribute(attributeName,accessor)})}var attributes=primitiveDef.attributes;const pending=[];for(const gltfAttributeName in attributes){const threeAttributeName=ATTRIBUTES[gltfAttributeName]||
gltfAttributeName.toLowerCase();threeAttributeName in geometry.attributes||pending.push(assignAttributeAccessor(attributes[gltfAttributeName],threeAttributeName))}void 0===primitiveDef.indices||geometry.index||(attributes=parser.getDependency("accessor",primitiveDef.indices).then(function(accessor){geometry.setIndex(accessor)}),pending.push(attributes));assignExtrasToUserData(geometry,primitiveDef);computeBounds(geometry,primitiveDef,parser);return Promise.all(pending).then(function(){return void 0!==
primitiveDef.targets?addMorphTargets(geometry,primitiveDef.targets,parser):geometry})}function toTrianglesDrawMode(geometry,drawMode){var index=geometry.getIndex();if(null===index){var indices=[];index=geometry.getAttribute("position");if(void 0!==index){for(var i=0;i<index.count;i++)indices.push(i);geometry.setIndex(indices);index=geometry.getIndex()}else return console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."),geometry}i=index.count-
2;indices=[];if(drawMode===_three.TriangleFanDrawMode)for(drawMode=1;drawMode<=i;drawMode++)indices.push(index.getX(0)),indices.push(index.getX(drawMode)),indices.push(index.getX(drawMode+1));else for(drawMode=0;drawMode<i;drawMode++)0===drawMode%2?(indices.push(index.getX(drawMode)),indices.push(index.getX(drawMode+1)),indices.push(index.getX(drawMode+2))):(indices.push(index.getX(drawMode+2)),indices.push(index.getX(drawMode+1)),indices.push(index.getX(drawMode)));indices.length/3!==i&&console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
geometry=geometry.clone();geometry.setIndex(indices);return geometry}Object.defineProperty(exports,"__esModule",{value:!0});exports.GLTFLoader=void 0;var _three=require("module$node_modules$three$build$three_module");class GLTFLoader extends _three.Loader{constructor(manager){super(manager);this.meshoptDecoder=this.ktx2Loader=this.dracoLoader=null;this.pluginCallbacks=[];this.register(function(parser){return new GLTFMaterialsClearcoatExtension(parser)});this.register(function(parser){return new GLTFTextureBasisUExtension(parser)});
this.register(function(parser){return new GLTFTextureWebPExtension(parser)});this.register(function(parser){return new GLTFMaterialsTransmissionExtension(parser)});this.register(function(parser){return new GLTFMaterialsVolumeExtension(parser)});this.register(function(parser){return new GLTFMaterialsIorExtension(parser)});this.register(function(parser){return new GLTFMaterialsSpecularExtension(parser)});this.register(function(parser){return new GLTFLightsExtension(parser)});this.register(function(parser){return new GLTFMeshoptCompression(parser)})}load(url,
onLoad,onProgress,onError){const scope=this;let resourcePath;resourcePath=""!==this.resourcePath?this.resourcePath:""!==this.path?this.path:_three.LoaderUtils.extractUrlBase(url);this.manager.itemStart(url);const _onError=function(e){onError?onError(e):console.error(e);scope.manager.itemError(url);scope.manager.itemEnd(url)},loader=new _three.FileLoader(this.manager);loader.setPath(this.path);loader.setResponseType("arraybuffer");loader.setRequestHeader(this.requestHeader);loader.setWithCredentials(this.withCredentials);
loader.load(url,function(data){try{scope.parse(data,resourcePath,function(gltf){onLoad(gltf);scope.manager.itemEnd(url)},_onError)}catch(e){_onError(e)}},onProgress,_onError)}setDRACOLoader(dracoLoader){this.dracoLoader=dracoLoader;return this}setDDSLoader(){throw Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".');}setKTX2Loader(ktx2Loader){this.ktx2Loader=ktx2Loader;return this}setMeshoptDecoder(meshoptDecoder){this.meshoptDecoder=meshoptDecoder;
return this}register(callback){-1===this.pluginCallbacks.indexOf(callback)&&this.pluginCallbacks.push(callback);return this}unregister(callback){-1!==this.pluginCallbacks.indexOf(callback)&&this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(callback),1);return this}parse(data,path,onLoad,onError){const extensions={},plugins={};if("string"!==typeof data)if("glTF"===_three.LoaderUtils.decodeText(new Uint8Array(data,0,4))){try{extensions[EXTENSIONS.KHR_BINARY_GLTF]=new GLTFBinaryExtension(data)}catch(error){onError&&
onError(error);return}data=extensions[EXTENSIONS.KHR_BINARY_GLTF].content}else data=_three.LoaderUtils.decodeText(new Uint8Array(data));data=JSON.parse(data);if(void 0===data.asset||2>data.asset.version[0])onError&&onError(Error("THREE.GLTFLoader: Unsupported asset. glTF versions \x3e\x3d2.0 are supported."));else{path=new GLTFParser(data,{path:path||this.resourcePath||"",crossOrigin:this.crossOrigin,requestHeader:this.requestHeader,manager:this.manager,ktx2Loader:this.ktx2Loader,meshoptDecoder:this.meshoptDecoder});
path.fileLoader.setRequestHeader(this.requestHeader);for(var i=0;i<this.pluginCallbacks.length;i++){var plugin=this.pluginCallbacks[i](path);plugins[plugin.name]=plugin;extensions[plugin.name]=!0}if(data.extensionsUsed)for(i=0;i<data.extensionsUsed.length;++i){plugin=data.extensionsUsed[i];const extensionsRequired=data.extensionsRequired||[];switch(plugin){case EXTENSIONS.KHR_MATERIALS_UNLIT:extensions[plugin]=new GLTFMaterialsUnlitExtension;break;case EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:extensions[plugin]=
new GLTFMaterialsPbrSpecularGlossinessExtension;break;case EXTENSIONS.KHR_DRACO_MESH_COMPRESSION:extensions[plugin]=new GLTFDracoMeshCompressionExtension(data,this.dracoLoader);break;case EXTENSIONS.KHR_TEXTURE_TRANSFORM:extensions[plugin]=new GLTFTextureTransformExtension;break;case EXTENSIONS.KHR_MESH_QUANTIZATION:extensions[plugin]=new GLTFMeshQuantizationExtension;break;default:0<=extensionsRequired.indexOf(plugin)&&void 0===plugins[plugin]&&console.warn('THREE.GLTFLoader: Unknown extension "'+
plugin+'".')}}path.setExtensions(extensions);path.setPlugins(plugins);path.parse(onLoad,onError)}}}exports.GLTFLoader=GLTFLoader;const EXTENSIONS={KHR_BINARY_GLTF:"KHR_binary_glTF",KHR_DRACO_MESH_COMPRESSION:"KHR_draco_mesh_compression",KHR_LIGHTS_PUNCTUAL:"KHR_lights_punctual",KHR_MATERIALS_CLEARCOAT:"KHR_materials_clearcoat",KHR_MATERIALS_IOR:"KHR_materials_ior",KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:"KHR_materials_pbrSpecularGlossiness",KHR_MATERIALS_SPECULAR:"KHR_materials_specular",KHR_MATERIALS_TRANSMISSION:"KHR_materials_transmission",
KHR_MATERIALS_UNLIT:"KHR_materials_unlit",KHR_MATERIALS_VOLUME:"KHR_materials_volume",KHR_TEXTURE_BASISU:"KHR_texture_basisu",KHR_TEXTURE_TRANSFORM:"KHR_texture_transform",KHR_MESH_QUANTIZATION:"KHR_mesh_quantization",EXT_TEXTURE_WEBP:"EXT_texture_webp",EXT_MESHOPT_COMPRESSION:"EXT_meshopt_compression"};class GLTFLightsExtension{constructor(parser){this.parser=parser;this.name=EXTENSIONS.KHR_LIGHTS_PUNCTUAL;this.cache={refs:{},uses:{}}}_markDefs(){const parser=this.parser,nodeDefs=this.parser.json.nodes||
[];for(let nodeIndex=0,nodeLength=nodeDefs.length;nodeIndex<nodeLength;nodeIndex++){const nodeDef=nodeDefs[nodeIndex];nodeDef.extensions&&nodeDef.extensions[this.name]&&void 0!==nodeDef.extensions[this.name].light&&parser._addNodeRef(this.cache,nodeDef.extensions[this.name].light)}}_loadLight(lightIndex){const parser=this.parser,cacheKey="light:"+lightIndex;var dependency=parser.cache.get(cacheKey);if(dependency)return dependency;dependency=parser.json;dependency=((dependency.extensions&&dependency.extensions[this.name]||
{}).lights||[])[lightIndex];var lightNode=new _three.Color(16777215);void 0!==dependency.color&&lightNode.fromArray(dependency.color);const range=void 0!==dependency.range?dependency.range:0;switch(dependency.type){case "directional":lightNode=new _three.DirectionalLight(lightNode);lightNode.target.position.set(0,0,-1);lightNode.add(lightNode.target);break;case "point":lightNode=new _three.PointLight(lightNode);lightNode.distance=range;break;case "spot":lightNode=new _three.SpotLight(lightNode);lightNode.distance=
range;dependency.spot=dependency.spot||{};dependency.spot.innerConeAngle=void 0!==dependency.spot.innerConeAngle?dependency.spot.innerConeAngle:0;dependency.spot.outerConeAngle=void 0!==dependency.spot.outerConeAngle?dependency.spot.outerConeAngle:Math.PI/4;lightNode.angle=dependency.spot.outerConeAngle;lightNode.penumbra=1-dependency.spot.innerConeAngle/dependency.spot.outerConeAngle;lightNode.target.position.set(0,0,-1);lightNode.add(lightNode.target);break;default:throw Error("THREE.GLTFLoader: Unexpected light type: "+
dependency.type);}lightNode.position.set(0,0,0);lightNode.decay=2;void 0!==dependency.intensity&&(lightNode.intensity=dependency.intensity);lightNode.name=parser.createUniqueName(dependency.name||"light_"+lightIndex);dependency=Promise.resolve(lightNode);parser.cache.add(cacheKey,dependency);return dependency}createNodeAttachment(nodeIndex){const self=this,parser=this.parser;nodeIndex=parser.json.nodes[nodeIndex];const lightIndex=(nodeIndex.extensions&&nodeIndex.extensions[this.name]||{}).light;return void 0===
lightIndex?null:this._loadLight(lightIndex).then(function(light){return parser._getNodeRef(self.cache,lightIndex,light)})}}class GLTFMaterialsUnlitExtension{constructor(){this.name=EXTENSIONS.KHR_MATERIALS_UNLIT}getMaterialType(){return _three.MeshBasicMaterial}extendParams(materialParams,materialDef,parser){const pending=[];materialParams.color=new _three.Color(1,1,1);materialParams.opacity=1;if(materialDef=materialDef.pbrMetallicRoughness){if(Array.isArray(materialDef.baseColorFactor)){const array=
materialDef.baseColorFactor;materialParams.color.fromArray(array);materialParams.opacity=array[3]}void 0!==materialDef.baseColorTexture&&pending.push(parser.assignTexture(materialParams,"map",materialDef.baseColorTexture))}return Promise.all(pending)}}class GLTFMaterialsClearcoatExtension{constructor(parser){this.parser=parser;this.name=EXTENSIONS.KHR_MATERIALS_CLEARCOAT}getMaterialType(materialIndex){materialIndex=this.parser.json.materials[materialIndex];return materialIndex.extensions&&materialIndex.extensions[this.name]?
_three.MeshPhysicalMaterial:null}extendMaterialParams(materialIndex,materialParams){var parser=this.parser,materialDef=parser.json.materials[materialIndex];if(!materialDef.extensions||!materialDef.extensions[this.name])return Promise.resolve();materialIndex=[];materialDef=materialDef.extensions[this.name];void 0!==materialDef.clearcoatFactor&&(materialParams.clearcoat=materialDef.clearcoatFactor);void 0!==materialDef.clearcoatTexture&&materialIndex.push(parser.assignTexture(materialParams,"clearcoatMap",
materialDef.clearcoatTexture));void 0!==materialDef.clearcoatRoughnessFactor&&(materialParams.clearcoatRoughness=materialDef.clearcoatRoughnessFactor);void 0!==materialDef.clearcoatRoughnessTexture&&materialIndex.push(parser.assignTexture(materialParams,"clearcoatRoughnessMap",materialDef.clearcoatRoughnessTexture));void 0!==materialDef.clearcoatNormalTexture&&(materialIndex.push(parser.assignTexture(materialParams,"clearcoatNormalMap",materialDef.clearcoatNormalTexture)),void 0!==materialDef.clearcoatNormalTexture.scale&&
(parser=materialDef.clearcoatNormalTexture.scale,materialParams.clearcoatNormalScale=new _three.Vector2(parser,-parser)));return Promise.all(materialIndex)}}class GLTFMaterialsTransmissionExtension{constructor(parser){this.parser=parser;this.name=EXTENSIONS.KHR_MATERIALS_TRANSMISSION}getMaterialType(materialIndex){materialIndex=this.parser.json.materials[materialIndex];return materialIndex.extensions&&materialIndex.extensions[this.name]?_three.MeshPhysicalMaterial:null}extendMaterialParams(materialIndex,
materialParams){const parser=this.parser;var materialDef=parser.json.materials[materialIndex];if(!materialDef.extensions||!materialDef.extensions[this.name])return Promise.resolve();materialIndex=[];materialDef=materialDef.extensions[this.name];void 0!==materialDef.transmissionFactor&&(materialParams.transmission=materialDef.transmissionFactor);void 0!==materialDef.transmissionTexture&&materialIndex.push(parser.assignTexture(materialParams,"transmissionMap",materialDef.transmissionTexture));return Promise.all(materialIndex)}}
class GLTFMaterialsVolumeExtension{constructor(parser){this.parser=parser;this.name=EXTENSIONS.KHR_MATERIALS_VOLUME}getMaterialType(materialIndex){materialIndex=this.parser.json.materials[materialIndex];return materialIndex.extensions&&materialIndex.extensions[this.name]?_three.MeshPhysicalMaterial:null}extendMaterialParams(materialIndex,materialParams){var parser=this.parser,materialDef=parser.json.materials[materialIndex];if(!materialDef.extensions||!materialDef.extensions[this.name])return Promise.resolve();
materialIndex=[];materialDef=materialDef.extensions[this.name];materialParams.thickness=void 0!==materialDef.thicknessFactor?materialDef.thicknessFactor:0;void 0!==materialDef.thicknessTexture&&materialIndex.push(parser.assignTexture(materialParams,"thicknessMap",materialDef.thicknessTexture));materialParams.attenuationDistance=materialDef.attenuationDistance||0;parser=materialDef.attenuationColor||[1,1,1];materialParams.attenuationTint=new _three.Color(parser[0],parser[1],parser[2]);return Promise.all(materialIndex)}}
class GLTFMaterialsIorExtension{constructor(parser){this.parser=parser;this.name=EXTENSIONS.KHR_MATERIALS_IOR}getMaterialType(materialIndex){materialIndex=this.parser.json.materials[materialIndex];return materialIndex.extensions&&materialIndex.extensions[this.name]?_three.MeshPhysicalMaterial:null}extendMaterialParams(materialIndex,materialParams){materialIndex=this.parser.json.materials[materialIndex];if(!materialIndex.extensions||!materialIndex.extensions[this.name])return Promise.resolve();materialIndex=
materialIndex.extensions[this.name];materialParams.ior=void 0!==materialIndex.ior?materialIndex.ior:1.5;return Promise.resolve()}}class GLTFMaterialsSpecularExtension{constructor(parser){this.parser=parser;this.name=EXTENSIONS.KHR_MATERIALS_SPECULAR}getMaterialType(materialIndex){materialIndex=this.parser.json.materials[materialIndex];return materialIndex.extensions&&materialIndex.extensions[this.name]?_three.MeshPhysicalMaterial:null}extendMaterialParams(materialIndex,materialParams){const parser=
this.parser;var materialDef=parser.json.materials[materialIndex];if(!materialDef.extensions||!materialDef.extensions[this.name])return Promise.resolve();materialIndex=[];materialDef=materialDef.extensions[this.name];materialParams.specularIntensity=void 0!==materialDef.specularFactor?materialDef.specularFactor:1;void 0!==materialDef.specularTexture&&materialIndex.push(parser.assignTexture(materialParams,"specularIntensityMap",materialDef.specularTexture));const colorArray=materialDef.specularColorFactor||
[1,1,1];materialParams.specularTint=new _three.Color(colorArray[0],colorArray[1],colorArray[2]);void 0!==materialDef.specularColorTexture&&materialIndex.push(parser.assignTexture(materialParams,"specularTintMap",materialDef.specularColorTexture).then(function(texture){texture.encoding=_three.sRGBEncoding}));return Promise.all(materialIndex)}}class GLTFTextureBasisUExtension{constructor(parser){this.parser=parser;this.name=EXTENSIONS.KHR_TEXTURE_BASISU}loadTexture(textureIndex){const parser=this.parser,
json=parser.json;var textureDef=json.textures[textureIndex];if(!textureDef.extensions||!textureDef.extensions[this.name])return null;textureDef=json.images[textureDef.extensions[this.name].source];const loader=parser.options.ktx2Loader;if(!loader){if(json.extensionsRequired&&0<=json.extensionsRequired.indexOf(this.name))throw Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");return null}return parser.loadTextureImage(textureIndex,textureDef,loader)}}class GLTFTextureWebPExtension{constructor(parser){this.parser=
parser;this.name=EXTENSIONS.EXT_TEXTURE_WEBP;this.isSupported=null}loadTexture(textureIndex){const name=this.name,parser=this.parser,json=parser.json;var textureDef=json.textures[textureIndex];if(!textureDef.extensions||!textureDef.extensions[name])return null;const source=json.images[textureDef.extensions[name].source];let loader=parser.textureLoader;source.uri&&(textureDef=parser.options.manager.getHandler(source.uri),null!==textureDef&&(loader=textureDef));return this.detectSupport().then(function(isSupported){if(isSupported)return parser.loadTextureImage(textureIndex,
source,loader);if(json.extensionsRequired&&0<=json.extensionsRequired.indexOf(name))throw Error("THREE.GLTFLoader: WebP required by asset but unsupported.");return parser.loadTexture(textureIndex)})}detectSupport(){this.isSupported||(this.isSupported=new Promise(function(resolve){const image=new Image;image.src="data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA";image.onload=image.onerror=function(){resolve(1===image.height)}}));return this.isSupported}}class GLTFMeshoptCompression{constructor(parser){this.name=
EXTENSIONS.EXT_MESHOPT_COMPRESSION;this.parser=parser}loadBufferView(index){const json=this.parser.json;index=json.bufferViews[index];if(index.extensions&&index.extensions[this.name]){const extensionDef=index.extensions[this.name];index=this.parser.getDependency("buffer",extensionDef.buffer);const decoder=this.parser.options.meshoptDecoder;if(!decoder||!decoder.supported){if(json.extensionsRequired&&0<=json.extensionsRequired.indexOf(this.name))throw Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");
return null}return Promise.all([index,decoder.ready]).then(function(res){const byteOffset=extensionDef.byteOffset||0,byteLength=extensionDef.byteLength||0,count=extensionDef.count,stride=extensionDef.byteStride,result=new ArrayBuffer(count*stride);res=new Uint8Array(res[0],byteOffset,byteLength);decoder.decodeGltfBuffer(new Uint8Array(result),count,stride,res,extensionDef.mode,extensionDef.filter);return result})}return null}}class GLTFBinaryExtension{constructor(data){this.name=EXTENSIONS.KHR_BINARY_GLTF;
this.body=this.content=null;var headerView=new DataView(data,0,12);this.header={magic:_three.LoaderUtils.decodeText(new Uint8Array(data.slice(0,4))),version:headerView.getUint32(4,!0),length:headerView.getUint32(8,!0)};if("glTF"!==this.header.magic)throw Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");if(2>this.header.version)throw Error("THREE.GLTFLoader: Legacy binary file detected.");headerView=this.header.length-12;const chunkView=new DataView(data,12);let chunkIndex=0;for(;chunkIndex<
headerView;){const chunkLength=chunkView.getUint32(chunkIndex,!0);chunkIndex+=4;var chunkType=chunkView.getUint32(chunkIndex,!0);chunkIndex+=4;1313821514===chunkType?(chunkType=new Uint8Array(data,12+chunkIndex,chunkLength),this.content=_three.LoaderUtils.decodeText(chunkType)):5130562===chunkType&&(chunkType=12+chunkIndex,this.body=data.slice(chunkType,chunkType+chunkLength));chunkIndex+=chunkLength}if(null===this.content)throw Error("THREE.GLTFLoader: JSON content not found.");}}class GLTFDracoMeshCompressionExtension{constructor(json,
dracoLoader){if(!dracoLoader)throw Error("THREE.GLTFLoader: No DRACOLoader instance provided.");this.name=EXTENSIONS.KHR_DRACO_MESH_COMPRESSION;this.json=json;this.dracoLoader=dracoLoader;this.dracoLoader.preload()}decodePrimitive(primitive,parser){const json=this.json,dracoLoader=this.dracoLoader,bufferViewIndex=primitive.extensions[this.name].bufferView,gltfAttributeMap=primitive.extensions[this.name].attributes,threeAttributeMap={},attributeNormalizedMap={},attributeTypeMap={};for(var attributeName$jscomp$0 in gltfAttributeMap){var threeAttributeName=
ATTRIBUTES[attributeName$jscomp$0]||attributeName$jscomp$0.toLowerCase();threeAttributeMap[threeAttributeName]=gltfAttributeMap[attributeName$jscomp$0]}for(const attributeName in primitive.attributes)attributeName$jscomp$0=ATTRIBUTES[attributeName]||attributeName.toLowerCase(),void 0!==gltfAttributeMap[attributeName]&&(threeAttributeName=json.accessors[primitive.attributes[attributeName]],attributeTypeMap[attributeName$jscomp$0]=WEBGL_COMPONENT_TYPES[threeAttributeName.componentType],attributeNormalizedMap[attributeName$jscomp$0]=
!0===threeAttributeName.normalized);return parser.getDependency("bufferView",bufferViewIndex).then(function(bufferView){return new Promise(function(resolve){dracoLoader.decodeDracoFile(bufferView,function(geometry){for(const attributeName in geometry.attributes){const attribute=geometry.attributes[attributeName],normalized=attributeNormalizedMap[attributeName];void 0!==normalized&&(attribute.normalized=normalized)}resolve(geometry)},threeAttributeMap,attributeTypeMap)})})}}class GLTFTextureTransformExtension{constructor(){this.name=
EXTENSIONS.KHR_TEXTURE_TRANSFORM}extendTexture(texture,transform){void 0!==transform.texCoord&&console.warn('THREE.GLTFLoader: Custom UV sets in "'+this.name+'" extension not yet supported.');if(void 0===transform.offset&&void 0===transform.rotation&&void 0===transform.scale)return texture;texture=texture.clone();void 0!==transform.offset&&texture.offset.fromArray(transform.offset);void 0!==transform.rotation&&(texture.rotation=transform.rotation);void 0!==transform.scale&&texture.repeat.fromArray(transform.scale);
texture.needsUpdate=!0;return texture}}class GLTFMeshStandardSGMaterial extends _three.MeshStandardMaterial{constructor(params){super();this.isGLTFSpecularGlossinessMaterial=!0;const uniforms={specular:{value:(new _three.Color).setHex(16777215)},glossiness:{value:1},specularMap:{value:null},glossinessMap:{value:null}};this._extraUniforms=uniforms;this.onBeforeCompile=function(shader){for(const uniformName in uniforms)shader.uniforms[uniformName]=uniforms[uniformName];shader.fragmentShader=shader.fragmentShader.replace("uniform float roughness;",
"uniform vec3 specular;").replace("uniform float metalness;","uniform float glossiness;").replace("#include \x3croughnessmap_pars_fragment\x3e","#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif").replace("#include \x3cmetalnessmap_pars_fragment\x3e","#ifdef USE_GLOSSINESSMAP\n\tuniform sampler2D glossinessMap;\n#endif").replace("#include \x3croughnessmap_fragment\x3e","vec3 specularFactor \x3d specular;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular \x3d texture2D( specularMap, vUv );\n\ttexelSpecular \x3d sRGBToLinear( texelSpecular );\n\t// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture\n\tspecularFactor *\x3d texelSpecular.rgb;\n#endif").replace("#include \x3cmetalnessmap_fragment\x3e",
"float glossinessFactor \x3d glossiness;\n#ifdef USE_GLOSSINESSMAP\n\tvec4 texelGlossiness \x3d texture2D( glossinessMap, vUv );\n\t// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture\n\tglossinessFactor *\x3d texelGlossiness.a;\n#endif").replace("#include \x3clights_physical_fragment\x3e","PhysicalMaterial material;\nmaterial.diffuseColor \x3d diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );\nvec3 dxy \x3d max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness \x3d max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness \x3d max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.\nmaterial.roughness +\x3d geometryRoughness;\nmaterial.roughness \x3d min( material.roughness, 1.0 );\nmaterial.specularColor \x3d specularFactor;")};
Object.defineProperties(this,{specular:{get:function(){return uniforms.specular.value},set:function(v){uniforms.specular.value=v}},specularMap:{get:function(){return uniforms.specularMap.value},set:function(v){(uniforms.specularMap.value=v)?this.defines.USE_SPECULARMAP="":delete this.defines.USE_SPECULARMAP}},glossiness:{get:function(){return uniforms.glossiness.value},set:function(v){uniforms.glossiness.value=v}},glossinessMap:{get:function(){return uniforms.glossinessMap.value},set:function(v){(uniforms.glossinessMap.value=
v)?(this.defines.USE_GLOSSINESSMAP="",this.defines.USE_UV=""):(delete this.defines.USE_GLOSSINESSMAP,delete this.defines.USE_UV)}}});delete this.metalness;delete this.roughness;delete this.metalnessMap;delete this.roughnessMap;this.setValues(params)}copy(source){super.copy(source);this.specularMap=source.specularMap;this.specular.copy(source.specular);this.glossinessMap=source.glossinessMap;this.glossiness=source.glossiness;delete this.metalness;delete this.roughness;delete this.metalnessMap;delete this.roughnessMap;
return this}}class GLTFMaterialsPbrSpecularGlossinessExtension{constructor(){this.name=EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS;this.specularGlossinessParams="color map lightMap lightMapIntensity aoMap aoMapIntensity emissive emissiveIntensity emissiveMap bumpMap bumpScale normalMap normalMapType displacementMap displacementScale displacementBias specularMap specular glossinessMap glossiness alphaMap envMap envMapIntensity refractionRatio".split(" ")}getMaterialType(){return GLTFMeshStandardSGMaterial}extendParams(materialParams,
materialDef,parser){var pbrSpecularGlossiness=materialDef.extensions[this.name];materialParams.color=new _three.Color(1,1,1);materialParams.opacity=1;materialDef=[];if(Array.isArray(pbrSpecularGlossiness.diffuseFactor)){const array=pbrSpecularGlossiness.diffuseFactor;materialParams.color.fromArray(array);materialParams.opacity=array[3]}void 0!==pbrSpecularGlossiness.diffuseTexture&&materialDef.push(parser.assignTexture(materialParams,"map",pbrSpecularGlossiness.diffuseTexture));materialParams.emissive=
new _three.Color(0,0,0);materialParams.glossiness=void 0!==pbrSpecularGlossiness.glossinessFactor?pbrSpecularGlossiness.glossinessFactor:1;materialParams.specular=new _three.Color(1,1,1);Array.isArray(pbrSpecularGlossiness.specularFactor)&&materialParams.specular.fromArray(pbrSpecularGlossiness.specularFactor);void 0!==pbrSpecularGlossiness.specularGlossinessTexture&&(pbrSpecularGlossiness=pbrSpecularGlossiness.specularGlossinessTexture,materialDef.push(parser.assignTexture(materialParams,"glossinessMap",
pbrSpecularGlossiness)),materialDef.push(parser.assignTexture(materialParams,"specularMap",pbrSpecularGlossiness)));return Promise.all(materialDef)}createMaterial(materialParams){const material=new GLTFMeshStandardSGMaterial(materialParams);material.fog=!0;material.color=materialParams.color;material.map=void 0===materialParams.map?null:materialParams.map;material.lightMap=null;material.lightMapIntensity=1;material.aoMap=void 0===materialParams.aoMap?null:materialParams.aoMap;material.aoMapIntensity=
1;material.emissive=materialParams.emissive;material.emissiveIntensity=1;material.emissiveMap=void 0===materialParams.emissiveMap?null:materialParams.emissiveMap;material.bumpMap=void 0===materialParams.bumpMap?null:materialParams.bumpMap;material.bumpScale=1;material.normalMap=void 0===materialParams.normalMap?null:materialParams.normalMap;material.normalMapType=_three.TangentSpaceNormalMap;materialParams.normalScale&&(material.normalScale=materialParams.normalScale);material.displacementMap=null;
material.displacementScale=1;material.displacementBias=0;material.specularMap=void 0===materialParams.specularMap?null:materialParams.specularMap;material.specular=materialParams.specular;material.glossinessMap=void 0===materialParams.glossinessMap?null:materialParams.glossinessMap;material.glossiness=materialParams.glossiness;material.alphaMap=null;material.envMap=void 0===materialParams.envMap?null:materialParams.envMap;material.envMapIntensity=1;material.refractionRatio=.98;return material}}class GLTFMeshQuantizationExtension{constructor(){this.name=
EXTENSIONS.KHR_MESH_QUANTIZATION}}class GLTFCubicSplineInterpolant extends _three.Interpolant{constructor(parameterPositions,sampleValues,sampleSize,resultBuffer){super(parameterPositions,sampleValues,sampleSize,resultBuffer)}copySampleValue_(index){const result=this.resultBuffer,values=this.sampleValues,valueSize=this.valueSize;index=index*valueSize*3+valueSize;for(let i=0;i!==valueSize;i++)result[i]=values[index+i];return result}}GLTFCubicSplineInterpolant.prototype.beforeStart_=GLTFCubicSplineInterpolant.prototype.copySampleValue_;
GLTFCubicSplineInterpolant.prototype.afterEnd_=GLTFCubicSplineInterpolant.prototype.copySampleValue_;GLTFCubicSplineInterpolant.prototype.interpolate_=function(i1,t0,t,t1){const result=this.resultBuffer,values=this.sampleValues,stride=this.valueSize,stride2=2*stride;var stride3=3*stride;t1-=t0;t0=(t-t0)/t1;t=t0*t0;var ppp=t*t0;i1*=stride3;stride3=i1-stride3;const s2=-2*ppp+3*t;ppp-=t;const s0=1-s2;t0=ppp-t+t0;for(t=0;t!==stride;t++)result[t]=s0*values[stride3+t+stride]+t0*values[stride3+t+stride2]*
t1+s2*values[i1+t+stride]+ppp*values[i1+t]*t1;return result};const _q=new _three.Quaternion;class GLTFCubicSplineQuaternionInterpolant extends GLTFCubicSplineInterpolant{interpolate_(i1,t0,t,t1){i1=super.interpolate_(i1,t0,t,t1);_q.fromArray(i1).normalize().toArray(i1);return i1}}const WEBGL_COMPONENT_TYPES={5120:Int8Array,5121:Uint8Array,5122:Int16Array,5123:Uint16Array,5125:Uint32Array,5126:Float32Array},WEBGL_FILTERS={9728:_three.NearestFilter,9729:_three.LinearFilter,9984:_three.NearestMipmapNearestFilter,
9985:_three.LinearMipmapNearestFilter,9986:_three.NearestMipmapLinearFilter,9987:_three.LinearMipmapLinearFilter},WEBGL_WRAPPINGS={33071:_three.ClampToEdgeWrapping,33648:_three.MirroredRepeatWrapping,10497:_three.RepeatWrapping},WEBGL_TYPE_SIZES={SCALAR:1,VEC2:2,VEC3:3,VEC4:4,MAT2:4,MAT3:9,MAT4:16},ATTRIBUTES={POSITION:"position",NORMAL:"normal",TANGENT:"tangent",TEXCOORD_0:"uv",TEXCOORD_1:"uv2",COLOR_0:"color",WEIGHTS_0:"skinWeight",JOINTS_0:"skinIndex"},PATH_PROPERTIES={scale:"scale",translation:"position",
rotation:"quaternion",weights:"morphTargetInfluences"},INTERPOLATION={CUBICSPLINE:void 0,LINEAR:_three.InterpolateLinear,STEP:_three.InterpolateDiscrete};class GLTFParser{constructor(json={},options={}){this.json=json;this.extensions={};this.plugins={};this.options=options;this.cache=new GLTFRegistry;this.associations=new Map;this.primitiveCache={};this.meshCache={refs:{},uses:{}};this.cameraCache={refs:{},uses:{}};this.lightCache={refs:{},uses:{}};this.textureCache={};this.nodeNamesUsed={};"undefined"!==
typeof createImageBitmap&&!1===/Firefox/.test(navigator.userAgent)?this.textureLoader=new _three.ImageBitmapLoader(this.options.manager):this.textureLoader=new _three.TextureLoader(this.options.manager);this.textureLoader.setCrossOrigin(this.options.crossOrigin);this.textureLoader.setRequestHeader(this.options.requestHeader);this.fileLoader=new _three.FileLoader(this.options.manager);this.fileLoader.setResponseType("arraybuffer");"use-credentials"===this.options.crossOrigin&&this.fileLoader.setWithCredentials(!0)}setExtensions(extensions){this.extensions=
extensions}setPlugins(plugins){this.plugins=plugins}parse(onLoad,onError){const parser=this,json=this.json,extensions=this.extensions;this.cache.removeAll();this._invokeAll(function(ext){return ext._markDefs&&ext._markDefs()});Promise.all(this._invokeAll(function(ext){return ext.beforeRoot&&ext.beforeRoot()})).then(function(){return Promise.all([parser.getDependencies("scene"),parser.getDependencies("animation"),parser.getDependencies("camera")])}).then(function(dependencies){const result={scene:dependencies[0][json.scene||
0],scenes:dependencies[0],animations:dependencies[1],cameras:dependencies[2],asset:json.asset,parser,userData:{}};addUnknownExtensionsToUserData(extensions,result,json);assignExtrasToUserData(result,json);Promise.all(parser._invokeAll(function(ext){return ext.afterRoot&&ext.afterRoot(result)})).then(function(){onLoad(result)})}).catch(onError)}_markDefs(){const nodeDefs=this.json.nodes||[];var skinDefs=this.json.skins||[];const meshDefs=this.json.meshes||[];for(let skinIndex=0,skinLength=skinDefs.length;skinIndex<
skinLength;skinIndex++){const joints=skinDefs[skinIndex].joints;for(let i=0,il=joints.length;i<il;i++)nodeDefs[joints[i]].isBone=!0}for(let nodeIndex=0,nodeLength=nodeDefs.length;nodeIndex<nodeLength;nodeIndex++)skinDefs=nodeDefs[nodeIndex],void 0!==skinDefs.mesh&&(this._addNodeRef(this.meshCache,skinDefs.mesh),void 0!==skinDefs.skin&&(meshDefs[skinDefs.mesh].isSkinnedMesh=!0)),void 0!==skinDefs.camera&&this._addNodeRef(this.cameraCache,skinDefs.camera)}_addNodeRef(cache,index){void 0!==index&&(void 0===
cache.refs[index]&&(cache.refs[index]=cache.uses[index]=0),cache.refs[index]++)}_getNodeRef(cache,index,object){if(1>=cache.refs[index])return object;object=object.clone();object.name+="_instance_"+cache.uses[index]++;return object}_invokeOne(func){const extensions=Object.values(this.plugins);extensions.push(this);for(let i=0;i<extensions.length;i++){const result=func(extensions[i]);if(result)return result}return null}_invokeAll(func){const extensions=Object.values(this.plugins);extensions.unshift(this);
const pending=[];for(let i=0;i<extensions.length;i++){const result=func(extensions[i]);result&&pending.push(result)}return pending}getDependency(type,index){const cacheKey=type+":"+index;let dependency=this.cache.get(cacheKey);if(!dependency){switch(type){case "scene":dependency=this.loadScene(index);break;case "node":dependency=this.loadNode(index);break;case "mesh":dependency=this._invokeOne(function(ext){return ext.loadMesh&&ext.loadMesh(index)});break;case "accessor":dependency=this.loadAccessor(index);
break;case "bufferView":dependency=this._invokeOne(function(ext){return ext.loadBufferView&&ext.loadBufferView(index)});break;case "buffer":dependency=this.loadBuffer(index);break;case "material":dependency=this._invokeOne(function(ext){return ext.loadMaterial&&ext.loadMaterial(index)});break;case "texture":dependency=this._invokeOne(function(ext){return ext.loadTexture&&ext.loadTexture(index)});break;case "skin":dependency=this.loadSkin(index);break;case "animation":dependency=this.loadAnimation(index);
break;case "camera":dependency=this.loadCamera(index);break;default:throw Error("Unknown type: "+type);}this.cache.add(cacheKey,dependency)}return dependency}getDependencies(type){let dependencies=this.cache.get(type);if(!dependencies){const parser=this;dependencies=Promise.all((this.json[type+("mesh"===type?"es":"s")]||[]).map(function(def,index){return parser.getDependency(type,index)}));this.cache.add(type,dependencies)}return dependencies}loadBuffer(bufferIndex){const bufferDef=this.json.buffers[bufferIndex],
loader=this.fileLoader;if(bufferDef.type&&"arraybuffer"!==bufferDef.type)throw Error("THREE.GLTFLoader: "+bufferDef.type+" buffer type is not supported.");if(void 0===bufferDef.uri&&0===bufferIndex)return Promise.resolve(this.extensions[EXTENSIONS.KHR_BINARY_GLTF].body);const options=this.options;return new Promise(function(resolve,reject){loader.load(resolveURL(bufferDef.uri,options.path),resolve,void 0,function(){reject(Error('THREE.GLTFLoader: Failed to load buffer "'+bufferDef.uri+'".'))})})}loadBufferView(bufferViewIndex){const bufferViewDef=
this.json.bufferViews[bufferViewIndex];return this.getDependency("buffer",bufferViewDef.buffer).then(function(buffer){const byteOffset=bufferViewDef.byteOffset||0;return buffer.slice(byteOffset,byteOffset+(bufferViewDef.byteLength||0))})}loadAccessor(accessorIndex){const parser=this,json=this.json,accessorDef=this.json.accessors[accessorIndex];if(void 0===accessorDef.bufferView&&void 0===accessorDef.sparse)return Promise.resolve(null);accessorIndex=[];void 0!==accessorDef.bufferView?accessorIndex.push(this.getDependency("bufferView",
accessorDef.bufferView)):accessorIndex.push(null);void 0!==accessorDef.sparse&&(accessorIndex.push(this.getDependency("bufferView",accessorDef.sparse.indices.bufferView)),accessorIndex.push(this.getDependency("bufferView",accessorDef.sparse.values.bufferView)));return Promise.all(accessorIndex).then(function(bufferViews){var bufferView=bufferViews[0];const itemSize=WEBGL_TYPE_SIZES[accessorDef.type],TypedArray=WEBGL_COMPONENT_TYPES[accessorDef.componentType];var elementBytes=TypedArray.BYTES_PER_ELEMENT,
byteOffset=accessorDef.byteOffset||0,byteStride=void 0!==accessorDef.bufferView?json.bufferViews[accessorDef.bufferView].byteStride:void 0;const normalized=!0===accessorDef.normalized;if(byteStride&&byteStride!==elementBytes*itemSize){var array=Math.floor(byteOffset/byteStride);const ibCacheKey="InterleavedBuffer:"+accessorDef.bufferView+":"+accessorDef.componentType+":"+array+":"+accessorDef.count;let ib=parser.cache.get(ibCacheKey);ib||(array=new TypedArray(bufferView,array*byteStride,accessorDef.count*
byteStride/elementBytes),ib=new _three.InterleavedBuffer(array,byteStride/elementBytes),parser.cache.add(ibCacheKey,ib));elementBytes=new _three.InterleavedBufferAttribute(ib,itemSize,byteOffset%byteStride/elementBytes,normalized)}else array=null===bufferView?new TypedArray(accessorDef.count*itemSize):new TypedArray(bufferView,byteOffset,accessorDef.count*itemSize),elementBytes=new _three.BufferAttribute(array,itemSize,normalized);if(void 0!==accessorDef.sparse){byteStride=accessorDef.sparse.values.byteOffset||
0;byteOffset=new WEBGL_COMPONENT_TYPES[accessorDef.sparse.indices.componentType](bufferViews[1],accessorDef.sparse.indices.byteOffset||0,accessorDef.sparse.count*WEBGL_TYPE_SIZES.SCALAR);bufferViews=new TypedArray(bufferViews[2],byteStride,accessorDef.sparse.count*itemSize);null!==bufferView&&(elementBytes=new _three.BufferAttribute(elementBytes.array.slice(),elementBytes.itemSize,elementBytes.normalized));for(let i=0,il=byteOffset.length;i<il;i++)if(bufferView=byteOffset[i],elementBytes.setX(bufferView,
bufferViews[i*itemSize]),2<=itemSize&&elementBytes.setY(bufferView,bufferViews[i*itemSize+1]),3<=itemSize&&elementBytes.setZ(bufferView,bufferViews[i*itemSize+2]),4<=itemSize&&elementBytes.setW(bufferView,bufferViews[i*itemSize+3]),5<=itemSize)throw Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.");}return elementBytes})}loadTexture(textureIndex){var json=this.json,options=this.options;json=json.images[json.textures[textureIndex].source];let loader=this.textureLoader;json.uri&&
(options=options.manager.getHandler(json.uri),null!==options&&(loader=options));return this.loadTextureImage(textureIndex,json,loader)}loadTextureImage(textureIndex,source,loader){const parser=this,json=this.json,options=this.options,textureDef=json.textures[textureIndex],cacheKey=(source.uri||source.bufferView)+":"+textureDef.sampler;if(this.textureCache[cacheKey])return this.textureCache[cacheKey];const URL=self.URL||self.webkitURL;let sourceURI=source.uri||"",isObjectURL=!1,hasAlpha=!0;var isJPEG=
0<sourceURI.search(/\.jpe?g($|\?)/i)||0===sourceURI.search(/^data:image\/jpeg/);if("image/jpeg"===source.mimeType||isJPEG)hasAlpha=!1;if(void 0!==source.bufferView)sourceURI=parser.getDependency("bufferView",source.bufferView).then(function(bufferView){if("image/png"===source.mimeType){const colorType=(new DataView(bufferView,25,1)).getUint8(0,!1);hasAlpha=6===colorType||4===colorType||3===colorType}isObjectURL=!0;bufferView=new Blob([bufferView],{type:source.mimeType});return sourceURI=URL.createObjectURL(bufferView)});
else if(void 0===source.uri)throw Error("THREE.GLTFLoader: Image "+textureIndex+" is missing URI and bufferView");isJPEG=Promise.resolve(sourceURI).then(function(sourceURI){return new Promise(function(resolve,reject){let onLoad=resolve;!0===loader.isImageBitmapLoader&&(onLoad=function(imageBitmap){imageBitmap=new _three.Texture(imageBitmap);imageBitmap.needsUpdate=!0;resolve(imageBitmap)});loader.load(resolveURL(sourceURI,options.path),onLoad,void 0,reject)})}).then(function(texture){!0===isObjectURL&&
URL.revokeObjectURL(sourceURI);texture.flipY=!1;textureDef.name&&(texture.name=textureDef.name);hasAlpha||(texture.format=_three.RGBFormat);const sampler=(json.samplers||{})[textureDef.sampler]||{};texture.magFilter=WEBGL_FILTERS[sampler.magFilter]||_three.LinearFilter;texture.minFilter=WEBGL_FILTERS[sampler.minFilter]||_three.LinearMipmapLinearFilter;texture.wrapS=WEBGL_WRAPPINGS[sampler.wrapS]||_three.RepeatWrapping;texture.wrapT=WEBGL_WRAPPINGS[sampler.wrapT]||_three.RepeatWrapping;parser.associations.set(texture,
{type:"textures",index:textureIndex});return texture}).catch(function(){console.error("THREE.GLTFLoader: Couldn't load texture",sourceURI);return null});return this.textureCache[cacheKey]=isJPEG}assignTexture(materialParams,mapName,mapDef){const parser=this;return this.getDependency("texture",mapDef.index).then(function(texture){void 0===mapDef.texCoord||0==mapDef.texCoord||"aoMap"===mapName&&1==mapDef.texCoord||console.warn("THREE.GLTFLoader: Custom UV set "+mapDef.texCoord+" for texture "+mapName+
" not yet supported.");if(parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM]){const transform=void 0!==mapDef.extensions?mapDef.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM]:void 0;if(transform){const gltfReference=parser.associations.get(texture);texture=parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM].extendTexture(texture,transform);parser.associations.set(texture,gltfReference)}}return materialParams[mapName]=texture})}assignFinalMaterial(mesh){const geometry=mesh.geometry;let material=mesh.material;
const useVertexTangents=void 0!==geometry.attributes.tangent,useVertexColors=void 0!==geometry.attributes.color,useFlatShading=void 0===geometry.attributes.normal;if(mesh.isPoints){var cacheKey="PointsMaterial:"+material.uuid,pointsMaterial=this.cache.get(cacheKey);pointsMaterial||(pointsMaterial=new _three.PointsMaterial,_three.Material.prototype.copy.call(pointsMaterial,material),pointsMaterial.color.copy(material.color),pointsMaterial.map=material.map,pointsMaterial.sizeAttenuation=!1,this.cache.add(cacheKey,
pointsMaterial));material=pointsMaterial}else mesh.isLine&&(cacheKey="LineBasicMaterial:"+material.uuid,pointsMaterial=this.cache.get(cacheKey),pointsMaterial||(pointsMaterial=new _three.LineBasicMaterial,_three.Material.prototype.copy.call(pointsMaterial,material),pointsMaterial.color.copy(material.color),this.cache.add(cacheKey,pointsMaterial)),material=pointsMaterial);if(useVertexTangents||useVertexColors||useFlatShading)cacheKey="ClonedMaterial:"+material.uuid+":",material.isGLTFSpecularGlossinessMaterial&&
(cacheKey+="specular-glossiness:"),useVertexTangents&&(cacheKey+="vertex-tangents:"),useVertexColors&&(cacheKey+="vertex-colors:"),useFlatShading&&(cacheKey+="flat-shading:"),pointsMaterial=this.cache.get(cacheKey),pointsMaterial||(pointsMaterial=material.clone(),useVertexColors&&(pointsMaterial.vertexColors=!0),useFlatShading&&(pointsMaterial.flatShading=!0),useVertexTangents&&(pointsMaterial.normalScale&&(pointsMaterial.normalScale.y*=-1),pointsMaterial.clearcoatNormalScale&&(pointsMaterial.clearcoatNormalScale.y*=
-1)),this.cache.add(cacheKey,pointsMaterial),this.associations.set(pointsMaterial,this.associations.get(material))),material=pointsMaterial;material.aoMap&&void 0===geometry.attributes.uv2&&void 0!==geometry.attributes.uv&&geometry.setAttribute("uv2",geometry.attributes.uv);mesh.material=material}getMaterialType(){return _three.MeshStandardMaterial}loadMaterial(materialIndex){const parser=this,extensions=this.extensions,materialDef=this.json.materials[materialIndex];let materialType;const materialParams=
{};var materialExtensions=materialDef.extensions||{};const pending=[];if(materialExtensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS])materialExtensions=extensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS],materialType=materialExtensions.getMaterialType(),pending.push(materialExtensions.extendParams(materialParams,materialDef,parser));else if(materialExtensions[EXTENSIONS.KHR_MATERIALS_UNLIT])materialExtensions=extensions[EXTENSIONS.KHR_MATERIALS_UNLIT],materialType=materialExtensions.getMaterialType(),
pending.push(materialExtensions.extendParams(materialParams,materialDef,parser));else{materialExtensions=materialDef.pbrMetallicRoughness||{};materialParams.color=new _three.Color(1,1,1);materialParams.opacity=1;if(Array.isArray(materialExtensions.baseColorFactor)){const array=materialExtensions.baseColorFactor;materialParams.color.fromArray(array);materialParams.opacity=array[3]}void 0!==materialExtensions.baseColorTexture&&pending.push(parser.assignTexture(materialParams,"map",materialExtensions.baseColorTexture));
materialParams.metalness=void 0!==materialExtensions.metallicFactor?materialExtensions.metallicFactor:1;materialParams.roughness=void 0!==materialExtensions.roughnessFactor?materialExtensions.roughnessFactor:1;void 0!==materialExtensions.metallicRoughnessTexture&&(pending.push(parser.assignTexture(materialParams,"metalnessMap",materialExtensions.metallicRoughnessTexture)),pending.push(parser.assignTexture(materialParams,"roughnessMap",materialExtensions.metallicRoughnessTexture)));materialType=this._invokeOne(function(ext){return ext.getMaterialType&&
ext.getMaterialType(materialIndex)});pending.push(Promise.all(this._invokeAll(function(ext){return ext.extendMaterialParams&&ext.extendMaterialParams(materialIndex,materialParams)})))}!0===materialDef.doubleSided&&(materialParams.side=_three.DoubleSide);materialExtensions=materialDef.alphaMode||"OPAQUE";"BLEND"===materialExtensions?(materialParams.transparent=!0,materialParams.depthWrite=!1):(materialParams.format=_three.RGBFormat,materialParams.transparent=!1,"MASK"===materialExtensions&&(materialParams.alphaTest=
void 0!==materialDef.alphaCutoff?materialDef.alphaCutoff:.5));void 0!==materialDef.normalTexture&&materialType!==_three.MeshBasicMaterial&&(pending.push(parser.assignTexture(materialParams,"normalMap",materialDef.normalTexture)),materialParams.normalScale=new _three.Vector2(1,-1),void 0!==materialDef.normalTexture.scale&&materialParams.normalScale.set(materialDef.normalTexture.scale,-materialDef.normalTexture.scale));void 0!==materialDef.occlusionTexture&&materialType!==_three.MeshBasicMaterial&&
(pending.push(parser.assignTexture(materialParams,"aoMap",materialDef.occlusionTexture)),void 0!==materialDef.occlusionTexture.strength&&(materialParams.aoMapIntensity=materialDef.occlusionTexture.strength));void 0!==materialDef.emissiveFactor&&materialType!==_three.MeshBasicMaterial&&(materialParams.emissive=(new _three.Color).fromArray(materialDef.emissiveFactor));void 0!==materialDef.emissiveTexture&&materialType!==_three.MeshBasicMaterial&&pending.push(parser.assignTexture(materialParams,"emissiveMap",
materialDef.emissiveTexture));return Promise.all(pending).then(function(){let material;material=materialType===GLTFMeshStandardSGMaterial?extensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(materialParams):new materialType(materialParams);materialDef.name&&(material.name=materialDef.name);material.map&&(material.map.encoding=_three.sRGBEncoding);material.emissiveMap&&(material.emissiveMap.encoding=_three.sRGBEncoding);assignExtrasToUserData(material,materialDef);parser.associations.set(material,
{type:"materials",index:materialIndex});materialDef.extensions&&addUnknownExtensionsToUserData(extensions,material,materialDef);return material})}createUniqueName(originalName){let name=originalName=_three.PropertyBinding.sanitizeNodeName(originalName||"");for(let i=1;this.nodeNamesUsed[name];++i)name=originalName+"_"+i;this.nodeNamesUsed[name]=!0;return name}loadGeometries(primitives){function createDracoPrimitive(primitive){return extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(primitive,
parser).then(function(geometry){return addPrimitiveAttributes(geometry,primitive,parser)})}const parser=this,extensions=this.extensions,cache=this.primitiveCache,pending=[];for(let i=0,il=primitives.length;i<il;i++){const primitive=primitives[i],cacheKey=createPrimitiveKey(primitive);var cached=cache[cacheKey];cached?pending.push(cached.promise):(cached=primitive.extensions&&primitive.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION]?createDracoPrimitive(primitive):addPrimitiveAttributes(new _three.BufferGeometry,
primitive,parser),cache[cacheKey]={primitive,promise:cached},pending.push(cached))}return Promise.all(pending)}loadMesh(meshIndex){const parser=this,extensions=this.extensions,meshDef$jscomp$0=this.json.meshes[meshIndex],primitives=meshDef$jscomp$0.primitives,pending=[];for(let i=0,il=primitives.length;i<il;i++){const material=void 0===primitives[i].material?createDefaultMaterial(this.cache):this.getDependency("material",primitives[i].material);pending.push(material)}pending.push(parser.loadGeometries(primitives));
return Promise.all(pending).then(function(results){var materials=results.slice(0,results.length-1);const geometries=results[results.length-1];results=[];for(let i$jscomp$0=0,il$jscomp$0=geometries.length;i$jscomp$0<il$jscomp$0;i$jscomp$0++){var geometry=geometries[i$jscomp$0];const primitive=primitives[i$jscomp$0];var mesh=void 0;mesh=materials[i$jscomp$0];if(4===primitive.mode||5===primitive.mode||6===primitive.mode||void 0===primitive.mode)mesh=!0===meshDef$jscomp$0.isSkinnedMesh?new _three.SkinnedMesh(geometry,
mesh):new _three.Mesh(geometry,mesh),!0!==mesh.isSkinnedMesh||mesh.geometry.attributes.skinWeight.normalized||mesh.normalizeSkinWeights(),5===primitive.mode?mesh.geometry=toTrianglesDrawMode(mesh.geometry,_three.TriangleStripDrawMode):6===primitive.mode&&(mesh.geometry=toTrianglesDrawMode(mesh.geometry,_three.TriangleFanDrawMode));else if(1===primitive.mode)mesh=new _three.LineSegments(geometry,mesh);else if(3===primitive.mode)mesh=new _three.Line(geometry,mesh);else if(2===primitive.mode)mesh=new _three.LineLoop(geometry,
mesh);else if(0===primitive.mode)mesh=new _three.Points(geometry,mesh);else throw Error("THREE.GLTFLoader: Primitive mode unsupported: "+primitive.mode);if(0<Object.keys(mesh.geometry.morphAttributes).length){geometry=mesh;var meshDef=meshDef$jscomp$0;geometry.updateMorphTargets();if(void 0!==meshDef.weights)for(let i=0,il=meshDef.weights.length;i<il;i++)geometry.morphTargetInfluences[i]=meshDef.weights[i];if(meshDef.extras&&Array.isArray(meshDef.extras.targetNames))if(meshDef=meshDef.extras.targetNames,
geometry.morphTargetInfluences.length===meshDef.length){geometry.morphTargetDictionary={};for(let i=0,il=meshDef.length;i<il;i++)geometry.morphTargetDictionary[meshDef[i]]=i}else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.")}mesh.name=parser.createUniqueName(meshDef$jscomp$0.name||"mesh_"+meshIndex);assignExtrasToUserData(mesh,meshDef$jscomp$0);primitive.extensions&&addUnknownExtensionsToUserData(extensions,mesh,primitive);parser.assignFinalMaterial(mesh);results.push(mesh)}if(1===
results.length)return results[0];materials=new _three.Group;for(let i=0,il=results.length;i<il;i++)materials.add(results[i]);return materials})}loadCamera(cameraIndex){let camera;cameraIndex=this.json.cameras[cameraIndex];const params=cameraIndex[cameraIndex.type];if(params)return"perspective"===cameraIndex.type?camera=new _three.PerspectiveCamera(_three.MathUtils.radToDeg(params.yfov),params.aspectRatio||1,params.znear||1,params.zfar||2E6):"orthographic"===cameraIndex.type&&(camera=new _three.OrthographicCamera(-params.xmag,
params.xmag,params.ymag,-params.ymag,params.znear,params.zfar)),cameraIndex.name&&(camera.name=this.createUniqueName(cameraIndex.name)),assignExtrasToUserData(camera,cameraIndex),Promise.resolve(camera);console.warn("THREE.GLTFLoader: Missing camera parameters.")}loadSkin(skinIndex){skinIndex=this.json.skins[skinIndex];const skinEntry={joints:skinIndex.joints};return void 0===skinIndex.inverseBindMatrices?Promise.resolve(skinEntry):this.getDependency("accessor",skinIndex.inverseBindMatrices).then(function(accessor){skinEntry.inverseBindMatrices=
accessor;return skinEntry})}loadAnimation(animationIndex){const animationDef=this.json.animations[animationIndex],pendingNodes=[],pendingInputAccessors=[],pendingOutputAccessors=[],pendingSamplers=[],pendingTargets=[];for(let i=0,il=animationDef.channels.length;i<il;i++){var channel=animationDef.channels[i];const sampler=animationDef.samplers[channel.sampler];channel=channel.target;const input=void 0!==animationDef.parameters?animationDef.parameters[sampler.input]:sampler.input,output=void 0!==animationDef.parameters?
animationDef.parameters[sampler.output]:sampler.output;pendingNodes.push(this.getDependency("node",void 0!==channel.node?channel.node:channel.id));pendingInputAccessors.push(this.getDependency("accessor",input));pendingOutputAccessors.push(this.getDependency("accessor",output));pendingSamplers.push(sampler);pendingTargets.push(channel)}return Promise.all([Promise.all(pendingNodes),Promise.all(pendingInputAccessors),Promise.all(pendingOutputAccessors),Promise.all(pendingSamplers),Promise.all(pendingTargets)]).then(function(dependencies){const nodes=
dependencies[0],inputAccessors=dependencies[1],outputAccessors=dependencies[2],samplers=dependencies[3];dependencies=dependencies[4];const tracks=[];for(let i=0,il=nodes.length;i<il;i++){var node=nodes[i];const inputAccessor=inputAccessors[i];var outputAccessor=outputAccessors[i];const sampler=samplers[i],target=dependencies[i];if(void 0===node)continue;node.updateMatrix();node.matrixAutoUpdate=!0;let TypedKeyframeTrack;switch(PATH_PROPERTIES[target.path]){case PATH_PROPERTIES.weights:TypedKeyframeTrack=
_three.NumberKeyframeTrack;break;case PATH_PROPERTIES.rotation:TypedKeyframeTrack=_three.QuaternionKeyframeTrack;break;default:TypedKeyframeTrack=_three.VectorKeyframeTrack}var targetName=node.name?node.name:node.uuid;const interpolation=void 0!==sampler.interpolation?INTERPOLATION[sampler.interpolation]:_three.InterpolateLinear,targetNames=[];PATH_PROPERTIES[target.path]===PATH_PROPERTIES.weights?node.traverse(function(object){!0===object.isMesh&&object.morphTargetInfluences&&targetNames.push(object.name?
object.name:object.uuid)}):targetNames.push(targetName);node=outputAccessor.array;if(outputAccessor.normalized){outputAccessor=getNormalizedComponentScale(node.constructor);targetName=new Float32Array(node.length);for(let j=0,jl=node.length;j<jl;j++)targetName[j]=node[j]*outputAccessor;node=targetName}for(let j=0,jl=targetNames.length;j<jl;j++)outputAccessor=new TypedKeyframeTrack(targetNames[j]+"."+PATH_PROPERTIES[target.path],inputAccessor.array,node,interpolation),"CUBICSPLINE"===sampler.interpolation&&
(outputAccessor.createInterpolant=function(result){return new (this instanceof _three.QuaternionKeyframeTrack?GLTFCubicSplineQuaternionInterpolant:GLTFCubicSplineInterpolant)(this.times,this.values,this.getValueSize()/3,result)},outputAccessor.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline=!0),tracks.push(outputAccessor)}return new _three.AnimationClip(animationDef.name?animationDef.name:"animation_"+animationIndex,void 0,tracks)})}createNodeMesh(nodeIndex){const parser=this,nodeDef=
this.json.nodes[nodeIndex];return void 0===nodeDef.mesh?null:parser.getDependency("mesh",nodeDef.mesh).then(function(mesh){mesh=parser._getNodeRef(parser.meshCache,nodeDef.mesh,mesh);void 0!==nodeDef.weights&&mesh.traverse(function(o){if(o.isMesh)for(let i=0,il=nodeDef.weights.length;i<il;i++)o.morphTargetInfluences[i]=nodeDef.weights[i]});return mesh})}loadNode(nodeIndex){const extensions=this.extensions,parser=this,nodeDef=this.json.nodes[nodeIndex],nodeName=nodeDef.name?parser.createUniqueName(nodeDef.name):
"";return function(){const pending=[],meshPromise=parser._invokeOne(function(ext){return ext.createNodeMesh&&ext.createNodeMesh(nodeIndex)});meshPromise&&pending.push(meshPromise);void 0!==nodeDef.camera&&pending.push(parser.getDependency("camera",nodeDef.camera).then(function(camera){return parser._getNodeRef(parser.cameraCache,nodeDef.camera,camera)}));parser._invokeAll(function(ext){return ext.createNodeAttachment&&ext.createNodeAttachment(nodeIndex)}).forEach(function(promise){pending.push(promise)});
return Promise.all(pending)}().then(function(objects){let node;node=!0===nodeDef.isBone?new _three.Bone:1<objects.length?new _three.Group:1===objects.length?objects[0]:new _three.Object3D;if(node!==objects[0])for(let i=0,il=objects.length;i<il;i++)node.add(objects[i]);nodeDef.name&&(node.userData.name=nodeDef.name,node.name=nodeName);assignExtrasToUserData(node,nodeDef);nodeDef.extensions&&addUnknownExtensionsToUserData(extensions,node,nodeDef);void 0!==nodeDef.matrix?(objects=new _three.Matrix4,
objects.fromArray(nodeDef.matrix),node.applyMatrix4(objects)):(void 0!==nodeDef.translation&&node.position.fromArray(nodeDef.translation),void 0!==nodeDef.rotation&&node.quaternion.fromArray(nodeDef.rotation),void 0!==nodeDef.scale&&node.scale.fromArray(nodeDef.scale));parser.associations.set(node,{type:"nodes",index:nodeIndex});return node})}loadScene(sceneIndex){const json=this.json;var extensions=this.extensions;sceneIndex=this.json.scenes[sceneIndex];const scene=new _three.Group;sceneIndex.name&&
(scene.name=this.createUniqueName(sceneIndex.name));assignExtrasToUserData(scene,sceneIndex);sceneIndex.extensions&&addUnknownExtensionsToUserData(extensions,scene,sceneIndex);extensions=sceneIndex.nodes||[];sceneIndex=[];for(let i=0,il=extensions.length;i<il;i++)sceneIndex.push(buildNodeHierachy(extensions[i],scene,json,this));return Promise.all(sceneIndex).then(function(){return scene})}}}
//# sourceMappingURL=module$node_modules$three$examples$jsm$loaders$GLTFLoader.js.map
