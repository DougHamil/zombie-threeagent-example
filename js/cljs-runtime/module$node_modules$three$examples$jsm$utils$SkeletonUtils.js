shadow$provide.module$node_modules$three$examples$jsm$utils$SkeletonUtils=function(global,require,module,exports){function retarget(target,source,options={}){var pos=new _three.Vector3;const quat=new _three.Quaternion,scale=new _three.Vector3,bindBoneMatrix=new _three.Matrix4,relativeMatrix=new _three.Matrix4,globalMatrix=new _three.Matrix4;options.preserveMatrix=void 0!==options.preserveMatrix?options.preserveMatrix:!0;options.preservePosition=void 0!==options.preservePosition?options.preservePosition:
!0;options.preserveHipPosition=void 0!==options.preserveHipPosition?options.preserveHipPosition:!1;options.useTargetMatrix=void 0!==options.useTargetMatrix?options.useTargetMatrix:!1;options.hip=void 0!==options.hip?options.hip:"hip";options.names=options.names||{};const sourceBones=source.isObject3D?source.skeleton.bones:getBones(source);source=target.isObject3D?target.skeleton.bones:getBones(target);let bindBones;var bone;let name;let bonesPosition;target.isObject3D?target.skeleton.pose():(options.useTargetMatrix=
!0,options.preserveMatrix=!1);if(options.preservePosition)for(bonesPosition=[],bone=0;bone<source.length;bone++)bonesPosition.push(source[bone].position.clone());if(options.preserveMatrix)for(target.updateMatrixWorld(),target.matrixWorld.identity(),bone=0;bone<target.children.length;++bone)target.children[bone].updateMatrixWorld(!0);if(options.offsets){bindBones=[];for(var i=0;i<source.length;++i)bone=source[i],name=options.names[bone.name]||bone.name,options.offsets&&options.offsets[name]&&(bone.matrix.multiply(options.offsets[name]),
bone.matrix.decompose(bone.position,bone.quaternion,bone.scale),bone.updateMatrixWorld()),bindBones.push(bone.matrixWorld.clone())}for(i=0;i<source.length;++i){bone=source[i];name=options.names[bone.name]||bone.name;var boneTo=getBoneByName(name,sourceBones);globalMatrix.copy(bone.matrixWorld);boneTo&&(boneTo.updateMatrixWorld(),options.useTargetMatrix?relativeMatrix.copy(boneTo.matrixWorld):(relativeMatrix.copy(target.matrixWorld).invert(),relativeMatrix.multiply(boneTo.matrixWorld)),scale.setFromMatrixScale(relativeMatrix),
relativeMatrix.scale(scale.set(1/scale.x,1/scale.y,1/scale.z)),globalMatrix.makeRotationFromQuaternion(quat.setFromRotationMatrix(relativeMatrix)),target.isObject3D&&(boneTo=source.indexOf(bone),boneTo=bindBones?bindBones[boneTo]:bindBoneMatrix.copy(target.skeleton.boneInverses[boneTo]).invert(),globalMatrix.multiply(boneTo)),globalMatrix.copyPosition(relativeMatrix));bone.parent&&bone.parent.isBone?(bone.matrix.copy(bone.parent.matrixWorld).invert(),bone.matrix.multiply(globalMatrix)):bone.matrix.copy(globalMatrix);
options.preserveHipPosition&&name===options.hip&&bone.matrix.setPosition(pos.set(0,bone.position.y,0));bone.matrix.decompose(bone.position,bone.quaternion,bone.scale);bone.updateMatrixWorld()}if(options.preservePosition)for(pos=0;pos<source.length;++pos)bone=source[pos],name=options.names[bone.name]||bone.name,name!==options.hip&&bone.position.copy(bonesPosition[pos]);options.preserveMatrix&&target.updateMatrixWorld(!0)}function getHelperFromSkeleton(skeleton){const source=new _three.SkeletonHelper(skeleton.bones[0]);
source.skeleton=skeleton;return source}function getBones(skeleton){return Array.isArray(skeleton)?skeleton:skeleton.bones}function getBoneByName(name,skeleton){for(let i=0,bones=getBones(skeleton);i<bones.length;i++)if(name===bones[i].name)return bones[i]}function getNearestBone(bone,names){for(;bone.isBone;){if(-1!==names.indexOf(bone.name))return bone;bone=bone.parent}}function parallelTraverse(a,b,callback){callback(a,b);for(let i=0;i<a.children.length;i++)parallelTraverse(a.children[i],b.children[i],
callback)}Object.defineProperty(exports,"__esModule",{value:!0});exports.retarget=retarget;exports.retargetClip=function(target,source,clip,options={}){options.useFirstFramePosition=void 0!==options.useFirstFramePosition?options.useFirstFramePosition:!1;options.fps=void 0!==options.fps?options.fps:30;options.names=options.names||[];source.isObject3D||(source=getHelperFromSkeleton(source));const numFrames=Math.round(options.fps/1E3*clip.duration*1E3),delta=1/options.fps,convertedTracks=[],mixer=new _three.AnimationMixer(source),
bones=getBones(target.skeleton),boneDatas=[];let positionOffset,bone;var boneTo;let name;mixer.clipAction(clip).play();mixer.update(0);source.updateMatrixWorld();for(let i=0;i<numFrames;++i){const time=i*delta;retarget(target,source,options);for(let j=0;j<bones.length;++j)if(name=options.names[bones[j].name]||bones[j].name,boneTo=getBoneByName(name,source.skeleton))bone=bones[j],boneTo=boneDatas[j]=boneDatas[j]||{bone},options.hip===name&&(boneTo.pos||(boneTo.pos={times:new Float32Array(numFrames),
values:new Float32Array(3*numFrames)}),options.useFirstFramePosition&&(0===i&&(positionOffset=bone.position.clone()),bone.position.sub(positionOffset)),boneTo.pos.times[i]=time,bone.position.toArray(boneTo.pos.values,3*i)),boneTo.quat||(boneTo.quat={times:new Float32Array(numFrames),values:new Float32Array(4*numFrames)}),boneTo.quat.times[i]=time,bone.quaternion.toArray(boneTo.quat.values,4*i);mixer.update(delta);source.updateMatrixWorld()}for(target=0;target<boneDatas.length;++target)if(boneTo=boneDatas[target])boneTo.pos&&
convertedTracks.push(new _three.VectorKeyframeTrack(".bones["+boneTo.bone.name+"].position",boneTo.pos.times,boneTo.pos.values)),convertedTracks.push(new _three.QuaternionKeyframeTrack(".bones["+boneTo.bone.name+"].quaternion",boneTo.quat.times,boneTo.quat.values));mixer.uncacheAction(clip);return new _three.AnimationClip(clip.name,-1,convertedTracks)};exports.getHelperFromSkeleton=getHelperFromSkeleton;exports.getSkeletonOffsets=function(target,source,options={}){const targetParentPos=new _three.Vector3,
targetPos=new _three.Vector3,sourceParentPos=new _three.Vector3,sourcePos=new _three.Vector3,targetDir=new _three.Vector2,sourceDir=new _three.Vector2;options.hip=void 0!==options.hip?options.hip:"hip";options.names=options.names||{};source.isObject3D||(source=getHelperFromSkeleton(source));const nameKeys=Object.keys(options.names),nameValues=Object.values(options.names);source=source.isObject3D?source.skeleton.bones:getBones(source);const bones=target.isObject3D?target.skeleton.bones:getBones(target),
offsets=[];var boneTo;let name,i;target.skeleton.pose();for(i=0;i<bones.length;++i)if(target=bones[i],name=options.names[target.name]||target.name,(boneTo=getBoneByName(name,source))&&name!==options.hip){const boneParent=getNearestBone(target.parent,nameKeys),boneToParent=getNearestBone(boneTo.parent,nameValues);boneParent.updateMatrixWorld();boneToParent.updateMatrixWorld();targetParentPos.setFromMatrixPosition(boneParent.matrixWorld);targetPos.setFromMatrixPosition(target.matrixWorld);sourceParentPos.setFromMatrixPosition(boneToParent.matrixWorld);
sourcePos.setFromMatrixPosition(boneTo.matrixWorld);targetDir.subVectors(new _three.Vector2(targetPos.x,targetPos.y),new _three.Vector2(targetParentPos.x,targetParentPos.y)).normalize();sourceDir.subVectors(new _three.Vector2(sourcePos.x,sourcePos.y),new _three.Vector2(sourceParentPos.x,sourceParentPos.y)).normalize();boneTo=targetDir.angle()-sourceDir.angle();boneTo=(new _three.Matrix4).makeRotationFromEuler(new _three.Euler(0,0,boneTo));target.matrix.multiply(boneTo);target.matrix.decompose(target.position,
target.quaternion,target.scale);target.updateMatrixWorld();offsets[name]=boneTo}return offsets};exports.renameBones=function(skeleton,names){skeleton=getBones(skeleton);for(let i=0;i<skeleton.length;++i){const bone=skeleton[i];names[bone.name]&&(bone.name=names[bone.name])}return this};exports.getBones=getBones;exports.getBoneByName=getBoneByName;exports.getNearestBone=getNearestBone;exports.findBoneTrackData=function(name,tracks){const regexp=/\[(.*)\]\.(.*)/,result={name};for(let i=0;i<tracks.length;++i){const trackData=
regexp.exec(tracks[i].name);trackData&&name===trackData[1]&&(result[trackData[2]]=i)}return result};exports.getEqualsBonesNames=function(skeleton,targetSkeleton){skeleton=getBones(skeleton);targetSkeleton=getBones(targetSkeleton);const bones=[];a:for(let i=0;i<skeleton.length;i++){const boneName=skeleton[i].name;for(let j=0;j<targetSkeleton.length;j++)if(boneName===targetSkeleton[j].name){bones.push(boneName);continue a}}return bones};exports.clone=function(source){const sourceLookup=new Map,cloneLookup=
new Map,clone=source.clone();parallelTraverse(source,clone,function(sourceNode,clonedNode){sourceLookup.set(clonedNode,sourceNode);cloneLookup.set(sourceNode,clonedNode)});clone.traverse(function(node){if(node.isSkinnedMesh){var sourceMesh=sourceLookup.get(node),sourceBones=sourceMesh.skeleton.bones;node.skeleton=sourceMesh.skeleton.clone();node.bindMatrix.copy(sourceMesh.bindMatrix);node.skeleton.bones=sourceBones.map(function(bone){return cloneLookup.get(bone)});node.bind(node.skeleton,node.bindMatrix)}});
return clone};var _three=require("module$node_modules$three$build$three_module")}
//# sourceMappingURL=module$node_modules$three$examples$jsm$utils$SkeletonUtils.js.map
