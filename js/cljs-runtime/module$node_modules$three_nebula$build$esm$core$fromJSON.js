shadow$provide.module$node_modules$three_nebula$build$esm$core$fromJSON=function(global,require,module,exports){function _getRequireWildcardCache(){if("function"!==typeof WeakMap)return null;var cache=new WeakMap;_getRequireWildcardCache=function(){return cache};return cache}function _interopRequireWildcard(obj){if(obj&&obj.__esModule)return obj;if(null===obj||"object"!==typeof obj&&"function"!==typeof obj)return{default:obj};var cache=_getRequireWildcardCache();if(cache&&cache.has(obj))return cache.get(obj);
var newObj={},hasPropertyDescriptor=Object.defineProperty&&Object.getOwnPropertyDescriptor,key;for(key in obj)if(Object.prototype.hasOwnProperty.call(obj,key)){var desc=hasPropertyDescriptor?Object.getOwnPropertyDescriptor(obj,key):null;desc&&(desc.get||desc.set)?Object.defineProperty(newObj,key,desc):newObj[key]=obj[key]}newObj.default=obj;cache&&cache.set(obj,newObj);return newObj}Object.defineProperty(exports,"__esModule",{value:!0});exports.default=void 0;var Behaviour=_interopRequireWildcard(require("module$node_modules$three_nebula$build$esm$behaviour$index")),
Initializer=_interopRequireWildcard(require("module$node_modules$three_nebula$build$esm$initializer$index")),_constants=require("module$node_modules$three_nebula$build$esm$constants$index"),_constants2=require("module$node_modules$three_nebula$build$esm$core$constants"),_Rate=function(obj){return obj&&obj.__esModule?obj:{default:obj}}(require("module$node_modules$three_nebula$build$esm$initializer$Rate"));const makeInitializers=(items,THREE)=>{const initializers=[];items.forEach(data=>{const {type,
properties}=data;if(!_constants2.SUPPORTED_JSON_INITIALIZER_TYPES.includes(type))throw Error(`The initializer type ${type} is invalid or not yet supported`);_constants2.INITIALIZER_TYPES_THAT_REQUIRE_THREE.includes(type)?initializers.push(Initializer[type].fromJSON(properties,THREE)):initializers.push(Initializer[type].fromJSON(properties))});return initializers},makeBehaviours=items=>{const behaviours=[];items.forEach(data=>{const {type,properties}=data;if(!_constants2.SUPPORTED_JSON_BEHAVIOUR_TYPES.includes(type))throw Error(`The behaviour type ${type} is invalid or not yet supported`);
behaviours.push(Behaviour[type].fromJSON(properties))});return behaviours};exports.default=(json,THREE,System,Emitter)=>{const {preParticles=_constants.POOL_MAX,integrationType=_constants.EULER,emitters=[]}=json,system=new System(THREE,preParticles,integrationType);emitters.forEach(data=>{const emitter=new Emitter,{rate,rotation,initializers,behaviours,emitterBehaviours=[],position,totalEmitTimes=Infinity,life=Infinity}=data;emitter.setRate(_Rate.default.fromJSON(rate)).setRotation(rotation).setInitializers(makeInitializers(initializers,
THREE)).setBehaviours(makeBehaviours(behaviours)).setEmitterBehaviours(makeBehaviours(emitterBehaviours)).setPosition(position).emit(totalEmitTimes,life);system.addEmitter(emitter)});return system}}
//# sourceMappingURL=module$node_modules$three_nebula$build$esm$core$fromJSON.js.map
