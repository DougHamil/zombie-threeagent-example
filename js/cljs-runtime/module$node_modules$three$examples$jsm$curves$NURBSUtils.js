shadow$provide.module$node_modules$three$examples$jsm$curves$NURBSUtils=function(global,require,module,exports){function findSpan(p,u,U){var n=U.length-p-1;if(u>=U[n])return n-1;if(u<=U[p])return p;let mid=Math.floor((p+n)/2);for(;u<U[mid]||u>=U[mid+1];)u<U[mid]?n=mid:p=mid,mid=Math.floor((p+n)/2);return mid}function calcBasisFunctions(span,u,p,U){const N=[],left=[],right=[];N[0]=1;for(let j=1;j<=p;++j){left[j]=u-U[span+1-j];right[j]=U[span+j]-u;let saved=0;for(let r=0;r<j;++r){const rv=right[r+1],
lv=left[j-r],temp=N[r]/(rv+lv);N[r]=saved+rv*temp;saved=lv*temp}N[j]=saved}return N}function calcBasisFunctionDerivatives(span,u,p,n,U){var zeroArr=[];for(var i=0;i<=p;++i)zeroArr[i]=0;i=[];for(var i$jscomp$0=0;i$jscomp$0<=n;++i$jscomp$0)i[i$jscomp$0]=zeroArr.slice(0);i$jscomp$0=[];for(var i$jscomp$1=0;i$jscomp$1<=p;++i$jscomp$1)i$jscomp$0[i$jscomp$1]=zeroArr.slice(0);i$jscomp$0[0][0]=1;i$jscomp$1=zeroArr.slice(0);var right=zeroArr.slice(0);for(var j=1;j<=p;++j){i$jscomp$1[j]=u-U[span+1-j];right[j]=
U[span+j]-u;var saved=0;for(var r=0;r<j;++r){var rv=right[r+1],lv=i$jscomp$1[j-r];i$jscomp$0[j][r]=rv+lv;const temp=i$jscomp$0[r][j-1]/i$jscomp$0[j][r];i$jscomp$0[r][j]=saved+rv*temp;saved=lv*temp}i$jscomp$0[j][j]=saved}for(span=0;span<=p;++span)i[0][span]=i$jscomp$0[span][p];for(span=0;span<=p;++span){u=0;U=1;i$jscomp$1=[];for(right=0;right<=p;++right)i$jscomp$1[right]=zeroArr.slice(0);i$jscomp$1[0][0]=1;for(right=1;right<=n;++right){j=0;saved=span-right;r=p-right;span>=right&&(i$jscomp$1[U][0]=
i$jscomp$1[u][0]/i$jscomp$0[r+1][saved],j=i$jscomp$1[U][0]*i$jscomp$0[saved][r]);lv=-1<=saved?1:-saved;for(rv=span-1<=r?right-1:p-span;lv<=rv;++lv)i$jscomp$1[U][lv]=(i$jscomp$1[u][lv]-i$jscomp$1[u][lv-1])/i$jscomp$0[r+1][saved+lv],j+=i$jscomp$1[U][lv]*i$jscomp$0[saved+lv][r];span<=r&&(i$jscomp$1[U][right]=-i$jscomp$1[u][right-1]/i$jscomp$0[r+1][span],j+=i$jscomp$1[U][right]*i$jscomp$0[span][r]);i[right][span]=j;j=u;u=U;U=j}}zeroArr=p;for(i$jscomp$0=1;i$jscomp$0<=n;++i$jscomp$0){for(span=0;span<=p;++span)i[i$jscomp$0][span]*=
zeroArr;zeroArr*=p-i$jscomp$0}return i}function calcBSplineDerivatives(p,U,P,u,nd){const du=nd<p?nd:p,CK=[],span=findSpan(p,u,U);U=calcBasisFunctionDerivatives(span,u,p,du,U);u=[];for(var i=0;i<P.length;++i){var point=P[i].clone();const w=point.w;point.x*=w;point.y*=w;point.z*=w;u[i]=point}for(P=0;P<=du;++P){i=u[span-p].clone().multiplyScalar(U[P][0]);for(point=1;point<=p;++point)i.add(u[span-p+point].clone().multiplyScalar(U[P][point]));CK[P]=i}for(p=du+1;p<=nd+1;++p)CK[p]=new _three.Vector4(0,0,
0);return CK}function calcKoverI(k,i){let nom=1;for(var j=2;j<=k;++j)nom*=j;j=1;for(var j$jscomp$0=2;j$jscomp$0<=i;++j$jscomp$0)j*=j$jscomp$0;for(j$jscomp$0=2;j$jscomp$0<=k-i;++j$jscomp$0)j*=j$jscomp$0;return nom/j}function calcRationalCurveDerivatives(Pders){const nd=Pders.length,Aders=[],wders=[];for(var i$jscomp$0=0;i$jscomp$0<nd;++i$jscomp$0){var point=Pders[i$jscomp$0];Aders[i$jscomp$0]=new _three.Vector3(point.x,point.y,point.z);wders[i$jscomp$0]=point.w}Pders=[];for(i$jscomp$0=0;i$jscomp$0<
nd;++i$jscomp$0){point=Aders[i$jscomp$0].clone();for(let i=1;i<=i$jscomp$0;++i)point.sub(Pders[i$jscomp$0-i].clone().multiplyScalar(calcKoverI(i$jscomp$0,i)*wders[i]));Pders[i$jscomp$0]=point.divideScalar(wders[0])}return Pders}Object.defineProperty(exports,"__esModule",{value:!0});exports.findSpan=findSpan;exports.calcBasisFunctions=calcBasisFunctions;exports.calcBSplinePoint=function(p,U,P,u){const span=findSpan(p,u,U);U=calcBasisFunctions(span,u,p,U);u=new _three.Vector4(0,0,0,0);for(let j=0;j<=
p;++j){const point=P[span-p+j],Nj=U[j],wNj=point.w*Nj;u.x+=point.x*wNj;u.y+=point.y*wNj;u.z+=point.z*wNj;u.w+=point.w*Nj}return u};exports.calcBasisFunctionDerivatives=calcBasisFunctionDerivatives;exports.calcBSplineDerivatives=calcBSplineDerivatives;exports.calcKoverI=calcKoverI;exports.calcRationalCurveDerivatives=calcRationalCurveDerivatives;exports.calcNURBSDerivatives=function(p,U,P,u,nd){p=calcBSplineDerivatives(p,U,P,u,nd);return calcRationalCurveDerivatives(p)};exports.calcSurfacePoint=function(p,
q,U,V,P,u,v,target){const uspan=findSpan(p,u,U),vspan=findSpan(q,v,V);U=calcBasisFunctions(uspan,u,p,U);V=calcBasisFunctions(vspan,v,q,V);v=[];for(u=0;u<=q;++u){v[u]=new _three.Vector4(0,0,0,0);for(let k=0;k<=p;++k){const point=P[uspan-p+k][vspan-q+u].clone(),w=point.w;point.x*=w;point.y*=w;point.z*=w;v[u].add(point.multiplyScalar(U[k]))}}p=new _three.Vector4(0,0,0,0);for(P=0;P<=q;++P)p.add(v[P].multiplyScalar(V[P]));p.divideScalar(p.w);target.set(p.x,p.y,p.z)};var _three=require("module$node_modules$three$build$three_module")}
//# sourceMappingURL=module$node_modules$three$examples$jsm$curves$NURBSUtils.js.map
