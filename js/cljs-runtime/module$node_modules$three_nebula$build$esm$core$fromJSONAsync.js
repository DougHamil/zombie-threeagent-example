shadow$provide.module$node_modules$three_nebula$build$esm$core$fromJSONAsync=function(global,require,module,exports){function _getRequireWildcardCache(){if("function"!==typeof WeakMap)return null;var cache=new WeakMap;_getRequireWildcardCache=function(){return cache};return cache}function _interopRequireWildcard(obj){if(obj&&obj.__esModule)return obj;if(null===obj||"object"!==typeof obj&&"function"!==typeof obj)return{default:obj};var cache=_getRequireWildcardCache();if(cache&&cache.has(obj))return cache.get(obj);
var newObj={},hasPropertyDescriptor=Object.defineProperty&&Object.getOwnPropertyDescriptor,key;for(key in obj)if(Object.prototype.hasOwnProperty.call(obj,key)){var desc=hasPropertyDescriptor?Object.getOwnPropertyDescriptor(obj,key):null;desc&&(desc.get||desc.set)?Object.defineProperty(newObj,key,desc):newObj[key]=obj[key]}newObj.default=obj;cache&&cache.set(obj,newObj);return newObj}function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj}}function ownKeys(object,enumerableOnly){var keys=
Object.keys(object);if(Object.getOwnPropertySymbols){var symbols=Object.getOwnPropertySymbols(object);enumerableOnly&&(symbols=symbols.filter(function(sym){return Object.getOwnPropertyDescriptor(object,sym).enumerable}));keys.push.apply(keys,symbols)}return keys}function _objectSpread(target){for(var i=1;i<arguments.length;i++){var source=null!=arguments[i]?arguments[i]:{};i%2?ownKeys(Object(source),!0).forEach(function(key){(0,_defineProperty2.default)(target,key,source[key])}):Object.getOwnPropertyDescriptors?
Object.defineProperties(target,Object.getOwnPropertyDescriptors(source)):ownKeys(Object(source)).forEach(function(key){Object.defineProperty(target,key,Object.getOwnPropertyDescriptor(source,key))})}return target}Object.defineProperty(exports,"__esModule",{value:!0});exports.default=void 0;var _defineProperty2=_interopRequireDefault(require("module$node_modules$$babel$runtime$helpers$defineProperty")),Behaviour=_interopRequireWildcard(require("module$node_modules$three_nebula$build$esm$behaviour$index")),
Initializer=_interopRequireWildcard(require("module$node_modules$three_nebula$build$esm$initializer$index")),_constants=require("module$node_modules$three_nebula$build$esm$constants$index"),_constants2=require("module$node_modules$three_nebula$build$esm$core$constants"),_Rate=_interopRequireDefault(require("module$node_modules$three_nebula$build$esm$initializer$Rate")),_Texture=_interopRequireDefault(require("module$node_modules$three_nebula$build$esm$initializer$Texture"));const DEFAULT_OPTIONS=
{shouldAutoEmit:!0},makeInitializers=(items,THREE)=>new Promise((resolve,reject)=>{if(!items.length)return resolve([]);const numberOfInitializers=items.length,madeInitializers=[],doNotRequireTextureLoading=items.filter(({properties})=>!properties.texture),doRequireTextureLoading=items.filter(({properties})=>properties.texture);doNotRequireTextureLoading.forEach(data=>{const {type,properties}=data;if(!_constants2.SUPPORTED_JSON_INITIALIZER_TYPES.includes(type))return reject(`The initializer type ${type} is invalid or not yet supported`);
_constants2.INITIALIZER_TYPES_THAT_REQUIRE_THREE.includes(type)?madeInitializers.push(Initializer[type].fromJSON(properties,THREE)):madeInitializers.push(Initializer[type].fromJSON(properties));if(madeInitializers.length===numberOfInitializers)return resolve(madeInitializers)});doRequireTextureLoading.forEach(data=>{const {type,properties,properties:{texture}}=data;data=new THREE.TextureLoader;if(!_constants2.SUPPORTED_JSON_INITIALIZER_TYPES.includes(type))return reject(`The initializer type ${type} is invalid or not yet supported`);
data.load(texture,loadedTexture=>{madeInitializers.push(_Texture.default.fromJSON(_objectSpread(_objectSpread({},properties),{},{loadedTexture}),THREE));if(madeInitializers.length===numberOfInitializers)return resolve(madeInitializers)},void 0,reject)})}),makeBehaviours=items=>new Promise((resolve,reject)=>{if(!items.length)return resolve([]);const numberOfBehaviours=items.length,madeBehaviours=[];items.forEach(data=>{const {type,properties}=data;if(!_constants2.SUPPORTED_JSON_BEHAVIOUR_TYPES.includes(type))return reject(`The behaviour type ${type} is invalid or not yet supported`);
madeBehaviours.push(Behaviour[type].fromJSON(properties));if(madeBehaviours.length===numberOfBehaviours)return resolve(madeBehaviours)})}),makeEmitters=(emitters,Emitter,THREE,shouldAutoEmit)=>new Promise((resolve,reject)=>{if(!emitters.length)return resolve([]);const madeEmitters=[],numberOfEmitters=emitters.length;if(!numberOfEmitters)return resolve(madeEmitters);emitters.forEach(data=>{const emitter$jscomp$0=new Emitter,{rate,rotation,initializers,behaviours,emitterBehaviours=[],position,totalEmitTimes=
Infinity,life=Infinity}=data;emitter$jscomp$0.setRate(_Rate.default.fromJSON(rate)).setRotation(rotation).setPosition(position);makeInitializers(initializers,THREE).then(madeInitializers=>{emitter$jscomp$0.setInitializers(madeInitializers);return makeBehaviours(behaviours)}).then(madeBehaviours=>{emitter$jscomp$0.setBehaviours(madeBehaviours);return makeBehaviours(emitterBehaviours)}).then(madeEmitterBehaviours=>{emitter$jscomp$0.setEmitterBehaviours(madeEmitterBehaviours);return Promise.resolve(emitter$jscomp$0)}).then(emitter=>
{madeEmitters.push(shouldAutoEmit?emitter.emit(totalEmitTimes,life):emitter.setTotalEmitTimes(totalEmitTimes).setLife(life));if(madeEmitters.length===numberOfEmitters)return resolve(madeEmitters)}).catch(reject)})});exports.default=(json,THREE,System,Emitter,options={})=>new Promise((resolve,reject)=>{const {preParticles=_constants.POOL_MAX,integrationType=_constants.EULER,emitters=[]}=json,system=new System(preParticles,integrationType),{shouldAutoEmit}=_objectSpread(_objectSpread({},DEFAULT_OPTIONS),
options);makeEmitters(emitters,Emitter,THREE,shouldAutoEmit).then(madeEmitters=>{const numberOfEmitters=madeEmitters.length;if(!numberOfEmitters)return resolve(system);madeEmitters.forEach(madeEmitter=>{system.addEmitter(madeEmitter);system.emitters.length===numberOfEmitters&&resolve(system)})}).catch(reject)})}
//# sourceMappingURL=module$node_modules$three_nebula$build$esm$core$fromJSONAsync.js.map
