shadow$provide.module$node_modules$three_nebula$build$esm$behaviour$Rotate=function(global,require,module,exports){Object.defineProperty(exports,"__esModule",{value:!0});exports.default=void 0;var _constants=require("module$node_modules$three_nebula$build$esm$constants$index"),_math=require("module$node_modules$three_nebula$build$esm$math$index");global=function(obj){return obj&&obj.__esModule?obj:{default:obj}}(require("module$node_modules$three_nebula$build$esm$behaviour$Behaviour"));var _ease=
require("module$node_modules$three_nebula$build$esm$ease$index"),_types=require("module$node_modules$three_nebula$build$esm$behaviour$types");class Rotate extends global.default{constructor(x,y,z,life,easing,isEnabled=!0){super(life,easing,_types.BEHAVIOUR_TYPE_ROTATE,isEnabled);this.reset(x,y,z)}get rotationType(){return this._rotationType}set rotationType(rotationType){this._rotationType=rotationType}reset(x,y,z,life,easing){this.x=x||0;this.y=y||0;this.z=z||0;void 0===x||"same"==x?this.rotationType=
"same":void 0==y?this.rotationType="set":void 0===z?this.rotationType="to":(this.rotationType="add",this.x=(0,_math.createSpan)(this.x*_constants.DR),this.y=(0,_math.createSpan)(this.y*_constants.DR),this.z=(0,_math.createSpan)(this.z*_constants.DR));life&&super.reset(life,easing)}initialize(particle){switch(this.rotationType){case "set":this._setRotation(particle.rotation,this.x);break;case "to":particle.transform.fR=particle.transform.fR||new _math.Vector3D;particle.transform.tR=particle.transform.tR||
new _math.Vector3D;this._setRotation(particle.transform.fR,this.x);this._setRotation(particle.transform.tR,this.y);break;case "add":particle.transform.addR=new _math.Vector3D(this.x.getValue(),this.y.getValue(),this.z.getValue())}}_setRotation(particleRotation,value){particleRotation=particleRotation||new _math.Vector3D;if("random"==value){value=_math.MathUtils.randomAToB(-_constants.PI,_constants.PI);var y=_math.MathUtils.randomAToB(-_constants.PI,_constants.PI),z=_math.MathUtils.randomAToB(-_constants.PI,
_constants.PI);particleRotation.set(value,y,z)}else value instanceof _math.Vector3D&&particleRotation.copy(value)}mutate(particle,time,index){this.energize(particle,time,index);switch(this.rotationType){case "same":particle.rotation||(particle.rotation=new _math.Vector3D);particle.rotation.eulerFromDir(particle.velocity);break;case "to":particle.rotation.x=_math.MathUtils.lerp(particle.transform.fR.x,particle.transform.tR.x,this.energy);particle.rotation.y=_math.MathUtils.lerp(particle.transform.fR.y,
particle.transform.tR.y,this.energy);particle.rotation.z=_math.MathUtils.lerp(particle.transform.fR.z,particle.transform.tR.z,this.energy);break;case "add":particle.rotation.add(particle.transform.addR)}}static fromJSON(json){const {x,y,z,life,easing,isEnabled=!0}=json;return new Rotate(x,y,z,life,(0,_ease.getEasingByName)(easing),isEnabled)}}exports.default=Rotate}
//# sourceMappingURL=module$node_modules$three_nebula$build$esm$behaviour$Rotate.js.map
