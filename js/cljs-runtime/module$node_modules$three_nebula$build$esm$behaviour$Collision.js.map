{
"version":3,
"file":"module$node_modules$three_nebula$build$esm$behaviour$Collision.js",
"lineCount":4,
"mappings":"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",
"sources":["node_modules/three-nebula/build/esm/behaviour/Collision.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$three_nebula$build$esm$behaviour$Collision\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _Behaviour = _interopRequireDefault(require(\"./Behaviour\"));\n\nvar _math = require(\"../math\");\n\nvar _types = require(\"./types\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Behaviour that causes particles to move away from other particles they collide with.\n */\nclass Collision extends _Behaviour.default {\n  /**\n   * Constructs a Collision behaviour instance.\n   *\n   * @param {Emitter} emitter - The emitter containing the particles to detect collisions against\n   * @param {boolean} useMass - Determiens whether to use mass or not\n   * @param {function} onCollide - Function to call when particles collide\n   * @param {number} life - The life of the particle\n   * @param {function} easing - The behaviour's decaying trend\n   * @param {boolean} [isEnabled=true] - Determines if the behaviour will be applied or not\n   * @return void\n   */\n  constructor(emitter, useMass, onCollide, life, easing, isEnabled = true) {\n    super(life, easing, _types.BEHAVIOUR_TYPE_COLLISION, isEnabled);\n    this.reset(emitter, useMass, onCollide);\n  }\n  /**\n   * Resets the behaviour properties.\n   *\n   * @param {Emitter} emitter - The emitter containing the particles to detect collisions against\n   * @param {boolean} useMass - Determiens whether to use mass or not\n   * @param {function} onCollide - Function to call when particles collide\n   * @param {number} life - The life of the particle\n   * @param {function} easing - The behaviour's decaying trend\n   * @return void\n   */\n\n\n  reset(emitter, useMass, onCollide, life, easing) {\n    this.emitter = emitter;\n    this.useMass = useMass;\n    this.onCollide = onCollide;\n    this.particles = [];\n    this.delta = new _math.Vector3D();\n    life && super.reset(life, easing);\n  }\n  /**\n   * Detects collisions with other particles and calls the\n   * onCollide function on colliding particles.\n   *\n   * @param {Particle} particle - the particle to apply the behaviour to\n   * @param {number} time - particle engine time\n   * @param {integer} index - the particle index\n   * @return void\n   */\n\n\n  mutate(particle, time, index) {\n    const particles = this.emitter ? this.emitter.particles.slice(index) : this.particles.slice(index);\n    let otherParticle, lengthSq, overlap, distance, averageMass1, averageMass2;\n    let i = particles.length;\n\n    while (i--) {\n      otherParticle = particles[i];\n\n      if (otherParticle == particle) {\n        continue;\n      }\n\n      this.delta.copy(otherParticle.position).sub(particle.position);\n      lengthSq = this.delta.lengthSq();\n      distance = particle.radius + otherParticle.radius;\n\n      if (lengthSq <= distance * distance) {\n        overlap = distance - Math.sqrt(lengthSq);\n        overlap += 0.5;\n        averageMass1 = this._getAverageMass(particle, otherParticle);\n        averageMass2 = this._getAverageMass(otherParticle, particle);\n        particle.position.add(this.delta.clone().normalize().scalar(overlap * -averageMass1));\n        otherParticle.position.add(this.delta.normalize().scalar(overlap * averageMass2));\n        this.onCollide && this.onCollide(particle, otherParticle);\n      }\n    }\n  }\n  /**\n   * Gets the average mass of both particles.\n   *\n   * @param {Particle} particleA - The first particle\n   * @param {Particle} particleB - The second particle\n   * @return {number}\n   */\n\n\n  _getAverageMass(particleA, particleB) {\n    return this.useMass ? particleB.mass / (particleA.mass + particleB.mass) : 0.5;\n  } // TODO\n\n\n  fromJSON(json) {} // eslint-disable-line\n\n\n}\n\nexports.default = Collision;\n};"],
"names":["shadow$provide","global","require","module","exports","Object","defineProperty","value","default","_Behaviour","_interopRequireDefault","obj","__esModule","_math","_types","Collision","constructor","emitter","useMass","onCollide","life","easing","isEnabled","BEHAVIOUR_TYPE_COLLISION","reset","particles","delta","Vector3D","mutate","particle","time","index","slice","averageMass2","i","length","otherParticle","copy","position","sub","lengthSq","distance","radius","overlap","Math","sqrt","averageMass1","_getAverageMass","add","clone","normalize","scalar","particleA","particleB","mass","fromJSON","json"]
}
