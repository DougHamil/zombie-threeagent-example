shadow$provide.module$node_modules$three_nebula$build$esm$behaviour$Collision=function(global,require,module,exports){Object.defineProperty(exports,"__esModule",{value:!0});exports.default=void 0;global=function(obj){return obj&&obj.__esModule?obj:{default:obj}}(require("module$node_modules$three_nebula$build$esm$behaviour$Behaviour"));var _math=require("module$node_modules$three_nebula$build$esm$math$index"),_types=require("module$node_modules$three_nebula$build$esm$behaviour$types");class Collision extends global.default{constructor(emitter,
useMass,onCollide,life,easing,isEnabled=!0){super(life,easing,_types.BEHAVIOUR_TYPE_COLLISION,isEnabled);this.reset(emitter,useMass,onCollide)}reset(emitter,useMass,onCollide,life,easing){this.emitter=emitter;this.useMass=useMass;this.onCollide=onCollide;this.particles=[];this.delta=new _math.Vector3D;life&&super.reset(life,easing)}mutate(particle,time,index){time=this.emitter?this.emitter.particles.slice(index):this.particles.slice(index);let averageMass2,i=time.length;for(;i--;)if(index=time[i],
index!=particle){this.delta.copy(index.position).sub(particle.position);var lengthSq=this.delta.lengthSq();var distance=particle.radius+index.radius;lengthSq<=distance*distance&&(lengthSq=distance-Math.sqrt(lengthSq),lengthSq+=.5,distance=this._getAverageMass(particle,index),averageMass2=this._getAverageMass(index,particle),particle.position.add(this.delta.clone().normalize().scalar(lengthSq*-distance)),index.position.add(this.delta.normalize().scalar(lengthSq*averageMass2)),this.onCollide&&this.onCollide(particle,
index))}}_getAverageMass(particleA,particleB){return this.useMass?particleB.mass/(particleA.mass+particleB.mass):.5}fromJSON(json){}}exports.default=Collision}
//# sourceMappingURL=module$node_modules$three_nebula$build$esm$behaviour$Collision.js.map
