shadow$provide.module$node_modules$three$examples$jsm$loaders$FBXLoader=function(global,require,module,exports){function _getRequireWildcardCache(){if("function"!==typeof WeakMap)return null;var cache=new WeakMap;_getRequireWildcardCache=function(){return cache};return cache}function getFbxVersion(text){if(text=text.match(/FBXVersion: (\d+)/))return parseInt(text[1]);throw Error("THREE.FBXLoader: Cannot find the version number for the file given.");}function convertFBXTimeToSeconds(time){return time/
46186158E3}function getData(polygonVertexIndex,polygonIndex,vertexIndex,infoObject){let index;switch(infoObject.mappingType){case "ByPolygonVertex":index=polygonVertexIndex;break;case "ByPolygon":index=polygonIndex;break;case "ByVertice":index=vertexIndex;break;case "AllSame":index=infoObject.indices[0];break;default:console.warn("THREE.FBXLoader: unknown attribute mapping type "+infoObject.mappingType)}"IndexToDirect"===infoObject.referenceType&&(index=infoObject.indices[index]);polygonVertexIndex=
index*infoObject.dataSize;polygonIndex=dataArray;vertexIndex=infoObject.buffer;infoObject=polygonVertexIndex+infoObject.dataSize;for(let i=polygonVertexIndex,j=0;i<infoObject;i++,j++)polygonIndex[j]=vertexIndex[i];return polygonIndex}function generateTransform(transformData){var lTranslationM=new _three.Matrix4;const lPreRotationM=new _three.Matrix4,lRotationM=new _three.Matrix4,lPostRotationM=new _three.Matrix4,lScalingM=new _three.Matrix4,lScalingPivotM=new _three.Matrix4,lScalingOffsetM=new _three.Matrix4,
lRotationOffsetM=new _three.Matrix4,lRotationPivotM=new _three.Matrix4,lParentGX=new _three.Matrix4;var lParentLX=new _three.Matrix4;const lGlobalT=new _three.Matrix4;var inheritType=transformData.inheritType?transformData.inheritType:0;transformData.translation&&lTranslationM.setPosition(tempVec.fromArray(transformData.translation));if(transformData.preRotation){var array=transformData.preRotation.map(_three.MathUtils.degToRad);array.push(transformData.eulerOrder);lPreRotationM.makeRotationFromEuler(tempEuler.fromArray(array))}transformData.rotation&&
(array=transformData.rotation.map(_three.MathUtils.degToRad),array.push(transformData.eulerOrder),lRotationM.makeRotationFromEuler(tempEuler.fromArray(array)));transformData.postRotation&&(array=transformData.postRotation.map(_three.MathUtils.degToRad),array.push(transformData.eulerOrder),lPostRotationM.makeRotationFromEuler(tempEuler.fromArray(array)),lPostRotationM.invert());transformData.scale&&lScalingM.scale(tempVec.fromArray(transformData.scale));transformData.scalingOffset&&lScalingOffsetM.setPosition(tempVec.fromArray(transformData.scalingOffset));
transformData.scalingPivot&&lScalingPivotM.setPosition(tempVec.fromArray(transformData.scalingPivot));transformData.rotationOffset&&lRotationOffsetM.setPosition(tempVec.fromArray(transformData.rotationOffset));transformData.rotationPivot&&lRotationPivotM.setPosition(tempVec.fromArray(transformData.rotationPivot));transformData.parentMatrixWorld&&(lParentLX.copy(transformData.parentMatrix),lParentGX.copy(transformData.parentMatrixWorld));array=lPreRotationM.clone().multiply(lRotationM).multiply(lPostRotationM);
const lParentGRM=new _three.Matrix4;lParentGRM.extractRotation(lParentGX);transformData=new _three.Matrix4;transformData.copyPosition(lParentGX);transformData=transformData.clone().invert().multiply(lParentGX);const lParentGSM=lParentGRM.clone().invert().multiply(transformData);transformData=new _three.Matrix4;0===inheritType?transformData.copy(lParentGRM).multiply(array).multiply(lParentGSM).multiply(lScalingM):1===inheritType?transformData.copy(lParentGRM).multiply(lParentGSM).multiply(array).multiply(lScalingM):
(lParentLX=(new _three.Matrix4).scale((new _three.Vector3).setFromMatrixScale(lParentLX)).clone().invert(),lParentLX=lParentGSM.clone().multiply(lParentLX),transformData.copy(lParentGRM).multiply(array).multiply(lParentLX).multiply(lScalingM));lParentLX=lRotationPivotM.clone().invert();inheritType=lScalingPivotM.clone().invert();lTranslationM=lTranslationM.clone().multiply(lRotationOffsetM).multiply(lRotationPivotM).multiply(lPreRotationM).multiply(lRotationM).multiply(lPostRotationM).multiply(lParentLX).multiply(lScalingOffsetM).multiply(lScalingPivotM).multiply(lScalingM).multiply(inheritType);
lTranslationM=(new _three.Matrix4).copyPosition(lTranslationM);lTranslationM=lParentGX.clone().multiply(lTranslationM);lGlobalT.copyPosition(lTranslationM);lTranslationM=lGlobalT.clone().multiply(transformData);lTranslationM.premultiply(lParentGX.invert());return lTranslationM}function getEulerOrder(order){order=order||0;const enums="ZYX YZX XZY ZXY YXZ XYZ".split(" ");return 6===order?(console.warn("THREE.FBXLoader: unsupported Euler Order: Spherical XYZ. Animations and rotations may be incorrect."),
enums[0]):enums[order]}function parseNumberArray(value){return value.split(",").map(function(val){return parseFloat(val)})}function convertArrayBufferToString(buffer,from,to){void 0===from&&(from=0);void 0===to&&(to=buffer.byteLength);return _three.LoaderUtils.decodeText(new Uint8Array(buffer,from,to))}function append(a,b){for(let i=0,j=a.length,l=b.length;i<l;i++,j++)a[j]=b[i]}function inject(a1,index,a2){return a1.slice(0,index).concat(a2).concat(a1.slice(index))}Object.defineProperty(exports,"__esModule",
{value:!0});exports.FBXLoader=void 0;var _three=require("module$node_modules$three$build$three_module"),fflate=function(obj){if(obj&&obj.__esModule)return obj;if(null===obj||"object"!==typeof obj&&"function"!==typeof obj)return{default:obj};var cache=_getRequireWildcardCache();if(cache&&cache.has(obj))return cache.get(obj);var newObj={},hasPropertyDescriptor=Object.defineProperty&&Object.getOwnPropertyDescriptor,key;for(key in obj)if(Object.prototype.hasOwnProperty.call(obj,key)){var desc=hasPropertyDescriptor?
Object.getOwnPropertyDescriptor(obj,key):null;desc&&(desc.get||desc.set)?Object.defineProperty(newObj,key,desc):newObj[key]=obj[key]}newObj.default=obj;cache&&cache.set(obj,newObj);return newObj}(require("module$node_modules$three$examples$jsm$libs$fflate_module")),_NURBSCurve=require("module$node_modules$three$examples$jsm$curves$NURBSCurve");let fbxTree,connections,sceneGraph;class FBXLoader extends _three.Loader{constructor(manager){super(manager)}load(url,onLoad,onProgress,onError){const scope=
this,path=""===scope.path?_three.LoaderUtils.extractUrlBase(url):scope.path,loader=new _three.FileLoader(this.manager);loader.setPath(scope.path);loader.setResponseType("arraybuffer");loader.setRequestHeader(scope.requestHeader);loader.setWithCredentials(scope.withCredentials);loader.load(url,function(buffer){try{onLoad(scope.parse(buffer,path))}catch(e){onError?onError(e):console.error(e),scope.manager.itemError(url)}},onProgress,onError)}parse(FBXBuffer,path){if(21<=FBXBuffer.byteLength&&"Kaydara FBX Binary  \x00"===
convertArrayBufferToString(FBXBuffer,0,21))fbxTree=(new BinaryParser).parse(FBXBuffer);else{FBXBuffer=convertArrayBufferToString(FBXBuffer);a:{var JSCompiler_inline_result=FBXBuffer;const CORRECT="Kaydara\\FBX\\Binary\\\\".split("");let cursor=0;for(let i=0;i<CORRECT.length;++i){const result=JSCompiler_inline_result[0];JSCompiler_inline_result=JSCompiler_inline_result.slice(cursor+1);cursor++;if(result===CORRECT[i]){JSCompiler_inline_result=!1;break a}}JSCompiler_inline_result=!0}if(!JSCompiler_inline_result)throw Error("THREE.FBXLoader: Unknown format.");
if(7E3>getFbxVersion(FBXBuffer))throw Error("THREE.FBXLoader: FBX version not supported, FileVersion: "+getFbxVersion(FBXBuffer));fbxTree=(new TextParser).parse(FBXBuffer)}path=(new _three.TextureLoader(this.manager)).setPath(this.resourcePath||path).setCrossOrigin(this.crossOrigin);return(new FBXTreeParser(path,this.manager)).parse(fbxTree)}}exports.FBXLoader=FBXLoader;class FBXTreeParser{constructor(textureLoader,manager){this.textureLoader=textureLoader;this.manager=manager}parse(){connections=
this.parseConnections();var images=this.parseImages();images=this.parseTextures(images);images=this.parseMaterials(images);const deformers=this.parseDeformers(),geometryMap=(new GeometryParser).parse(deformers);this.parseScene(deformers,geometryMap,images);return sceneGraph}parseConnections(){const connectionMap=new Map;"Connections"in fbxTree&&fbxTree.Connections.connections.forEach(function(rawConnection){var fromID=rawConnection[0];const toID=rawConnection[1];rawConnection=rawConnection[2];connectionMap.has(fromID)||
connectionMap.set(fromID,{parents:[],children:[]});const parentRelationship={ID:toID,relationship:rawConnection};connectionMap.get(fromID).parents.push(parentRelationship);connectionMap.has(toID)||connectionMap.set(toID,{parents:[],children:[]});fromID={ID:fromID,relationship:rawConnection};connectionMap.get(toID).children.push(fromID)});return connectionMap}parseImages(){const images={},blobs={};if("Video"in fbxTree.Objects){var videoNodes=fbxTree.Objects.Video;for(const nodeID in videoNodes){const videoNode=
videoNodes[nodeID];var id$jscomp$0=parseInt(nodeID);images[id$jscomp$0]=videoNode.RelativeFilename||videoNode.Filename;"Content"in videoNode&&(id$jscomp$0="string"===typeof videoNode.Content&&""!==videoNode.Content,videoNode.Content instanceof ArrayBuffer&&0<videoNode.Content.byteLength||id$jscomp$0)&&(id$jscomp$0=this.parseImage(videoNodes[nodeID]),blobs[videoNode.RelativeFilename||videoNode.Filename]=id$jscomp$0)}}for(const id in images)videoNodes=images[id],images[id]=void 0!==blobs[videoNodes]?
blobs[videoNodes]:images[id].split("\\").pop();return images}parseImage(videoNode){var content=videoNode.Content;videoNode=videoNode.RelativeFilename||videoNode.Filename;const extension=videoNode.slice(videoNode.lastIndexOf(".")+1).toLowerCase();switch(extension){case "bmp":videoNode="image/bmp";break;case "jpg":case "jpeg":videoNode="image/jpeg";break;case "png":videoNode="image/png";break;case "tif":videoNode="image/tiff";break;case "tga":null===this.manager.getHandler(".tga")&&console.warn("FBXLoader: TGA loader not found, skipping ",
videoNode);videoNode="image/tga";break;default:console.warn('FBXLoader: Image type "'+extension+'" is not supported.');return}if("string"===typeof content)return"data:"+videoNode+";base64,"+content;content=new Uint8Array(content);return window.URL.createObjectURL(new Blob([content],{type:videoNode}))}parseTextures(images){const textureMap=new Map;if("Texture"in fbxTree.Objects){const textureNodes=fbxTree.Objects.Texture;for(const nodeID in textureNodes){const texture=this.parseTexture(textureNodes[nodeID],
images);textureMap.set(parseInt(nodeID),texture)}}return textureMap}parseTexture(textureNode,images){images=this.loadTexture(textureNode,images);images.ID=textureNode.id;images.name=textureNode.attrName;const wrapModeU=textureNode.WrapModeU;var wrapModeV=textureNode.WrapModeV;wrapModeV=void 0!==wrapModeV?wrapModeV.value:0;images.wrapS=0===(void 0!==wrapModeU?wrapModeU.value:0)?_three.RepeatWrapping:_three.ClampToEdgeWrapping;images.wrapT=0===wrapModeV?_three.RepeatWrapping:_three.ClampToEdgeWrapping;
"Scaling"in textureNode&&(textureNode=textureNode.Scaling.value,images.repeat.x=textureNode[0],images.repeat.y=textureNode[1]);return images}loadTexture(textureNode,images){let fileName;const currentPath=this.textureLoader.path,children=connections.get(textureNode.id).children;void 0!==children&&0<children.length&&void 0!==images[children[0].ID]&&(fileName=images[children[0].ID],0!==fileName.indexOf("blob:")&&0!==fileName.indexOf("data:")||this.textureLoader.setPath(void 0));images=textureNode.FileName.slice(-3).toLowerCase();
"tga"===images?(images=this.manager.getHandler(".tga"),null===images?(console.warn("FBXLoader: TGA loader not found, creating placeholder texture for",textureNode.RelativeFilename),textureNode=new _three.Texture):(images.setPath(this.textureLoader.path),textureNode=images.load(fileName))):"psd"===images?(console.warn("FBXLoader: PSD textures are not supported, creating placeholder texture for",textureNode.RelativeFilename),textureNode=new _three.Texture):textureNode=this.textureLoader.load(fileName);
this.textureLoader.setPath(currentPath);return textureNode}parseMaterials(textureMap){const materialMap=new Map;if("Material"in fbxTree.Objects){const materialNodes=fbxTree.Objects.Material;for(const nodeID in materialNodes){const material=this.parseMaterial(materialNodes[nodeID],textureMap);null!==material&&materialMap.set(parseInt(nodeID),material)}}return materialMap}parseMaterial(materialNode,textureMap){const ID=materialNode.id,name=materialNode.attrName;var type=materialNode.ShadingModel;"object"===
typeof type&&(type=type.value);if(!connections.has(ID))return null;materialNode=this.parseParameters(materialNode,textureMap,ID);switch(type.toLowerCase()){case "phong":type=new _three.MeshPhongMaterial;break;case "lambert":type=new _three.MeshLambertMaterial;break;default:console.warn('THREE.FBXLoader: unknown material type "%s". Defaulting to MeshPhongMaterial.',type),type=new _three.MeshPhongMaterial}type.setValues(materialNode);type.name=name;return type}parseParameters(materialNode,textureMap,
ID){const parameters={};materialNode.BumpFactor&&(parameters.bumpScale=materialNode.BumpFactor.value);materialNode.Diffuse?parameters.color=(new _three.Color).fromArray(materialNode.Diffuse.value):!materialNode.DiffuseColor||"Color"!==materialNode.DiffuseColor.type&&"ColorRGB"!==materialNode.DiffuseColor.type||(parameters.color=(new _three.Color).fromArray(materialNode.DiffuseColor.value));materialNode.DisplacementFactor&&(parameters.displacementScale=materialNode.DisplacementFactor.value);materialNode.Emissive?
parameters.emissive=(new _three.Color).fromArray(materialNode.Emissive.value):!materialNode.EmissiveColor||"Color"!==materialNode.EmissiveColor.type&&"ColorRGB"!==materialNode.EmissiveColor.type||(parameters.emissive=(new _three.Color).fromArray(materialNode.EmissiveColor.value));materialNode.EmissiveFactor&&(parameters.emissiveIntensity=parseFloat(materialNode.EmissiveFactor.value));materialNode.Opacity&&(parameters.opacity=parseFloat(materialNode.Opacity.value));1>parameters.opacity&&(parameters.transparent=
!0);materialNode.ReflectionFactor&&(parameters.reflectivity=materialNode.ReflectionFactor.value);materialNode.Shininess&&(parameters.shininess=materialNode.Shininess.value);materialNode.Specular?parameters.specular=(new _three.Color).fromArray(materialNode.Specular.value):materialNode.SpecularColor&&"Color"===materialNode.SpecularColor.type&&(parameters.specular=(new _three.Color).fromArray(materialNode.SpecularColor.value));const scope=this;connections.get(ID).children.forEach(function(child){const type=
child.relationship;switch(type){case "Bump":parameters.bumpMap=scope.getTexture(textureMap,child.ID);break;case "Maya|TEX_ao_map":parameters.aoMap=scope.getTexture(textureMap,child.ID);break;case "DiffuseColor":case "Maya|TEX_color_map":parameters.map=scope.getTexture(textureMap,child.ID);void 0!==parameters.map&&(parameters.map.encoding=_three.sRGBEncoding);break;case "DisplacementColor":parameters.displacementMap=scope.getTexture(textureMap,child.ID);break;case "EmissiveColor":parameters.emissiveMap=
scope.getTexture(textureMap,child.ID);void 0!==parameters.emissiveMap&&(parameters.emissiveMap.encoding=_three.sRGBEncoding);break;case "NormalMap":case "Maya|TEX_normal_map":parameters.normalMap=scope.getTexture(textureMap,child.ID);break;case "ReflectionColor":parameters.envMap=scope.getTexture(textureMap,child.ID);void 0!==parameters.envMap&&(parameters.envMap.mapping=_three.EquirectangularReflectionMapping,parameters.envMap.encoding=_three.sRGBEncoding);break;case "SpecularColor":parameters.specularMap=
scope.getTexture(textureMap,child.ID);void 0!==parameters.specularMap&&(parameters.specularMap.encoding=_three.sRGBEncoding);break;case "TransparentColor":case "TransparencyFactor":parameters.alphaMap=scope.getTexture(textureMap,child.ID);parameters.transparent=!0;break;default:console.warn("THREE.FBXLoader: %s map is not supported in three.js, skipping texture.",type)}});return parameters}getTexture(textureMap,id){"LayeredTexture"in fbxTree.Objects&&id in fbxTree.Objects.LayeredTexture&&(console.warn("THREE.FBXLoader: layered textures are not supported in three.js. Discarding all but first layer."),
id=connections.get(id).children[0].ID);return textureMap.get(id)}parseDeformers(){const skeletons={},morphTargets={};if("Deformer"in fbxTree.Objects){const DeformerNodes=fbxTree.Objects.Deformer;for(const nodeID in DeformerNodes){var deformerNode=DeformerNodes[nodeID];const relationships=connections.get(parseInt(nodeID));"Skin"===deformerNode.attrType?(deformerNode=this.parseSkeleton(relationships,DeformerNodes),deformerNode.ID=nodeID,1<relationships.parents.length&&console.warn("THREE.FBXLoader: skeleton attached to more than one geometry is not supported."),
deformerNode.geometryID=relationships.parents[0].ID,skeletons[nodeID]=deformerNode):"BlendShape"===deformerNode.attrType&&(deformerNode={id:nodeID},deformerNode.rawTargets=this.parseMorphTargets(relationships,DeformerNodes),deformerNode.id=nodeID,1<relationships.parents.length&&console.warn("THREE.FBXLoader: morph target attached to more than one geometry is not supported."),morphTargets[nodeID]=deformerNode)}}return{skeletons,morphTargets}}parseSkeleton(relationships,deformerNodes){const rawBones=
[];relationships.children.forEach(function(child){const boneNode=deformerNodes[child.ID];"Cluster"===boneNode.attrType&&(child={ID:child.ID,indices:[],weights:[],transformLink:(new _three.Matrix4).fromArray(boneNode.TransformLink.a)},"Indexes"in boneNode&&(child.indices=boneNode.Indexes.a,child.weights=boneNode.Weights.a),rawBones.push(child))});return{rawBones,bones:[]}}parseMorphTargets(relationships,deformerNodes){const rawMorphTargets=[];for(let i=0;i<relationships.children.length;i++){const child$jscomp$0=
relationships.children[i],morphTargetNode=deformerNodes[child$jscomp$0.ID],rawMorphTarget={name:morphTargetNode.attrName,initialWeight:morphTargetNode.DeformPercent,id:morphTargetNode.id,fullWeights:morphTargetNode.FullWeights.a};if("BlendShapeChannel"!==morphTargetNode.attrType)return;rawMorphTarget.geoID=connections.get(parseInt(child$jscomp$0.ID)).children.filter(function(child){return void 0===child.relationship})[0].ID;rawMorphTargets.push(rawMorphTarget)}return rawMorphTargets}parseScene(deformers,
geometryMap,materialMap){sceneGraph=new _three.Group;const modelMap=this.parseModels(deformers.skeletons,geometryMap,materialMap),modelNodes=fbxTree.Objects.Model,scope=this;modelMap.forEach(function(model){scope.setLookAtProperties(model,modelNodes[model.ID]);connections.get(model.ID).parents.forEach(function(connection){connection=modelMap.get(connection.ID);void 0!==connection&&connection.add(model)});null===model.parent&&sceneGraph.add(model)});this.bindSkeleton(deformers.skeletons,geometryMap,
modelMap);this.createAmbientLight();sceneGraph.traverse(function(node){if(node.userData.transformData){node.parent&&(node.userData.transformData.parentMatrix=node.parent.matrix,node.userData.transformData.parentMatrixWorld=node.parent.matrixWorld);const transform=generateTransform(node.userData.transformData);node.applyMatrix4(transform);node.updateWorldMatrix()}});deformers=(new AnimationParser).parse();1===sceneGraph.children.length&&sceneGraph.children[0].isGroup&&(sceneGraph.children[0].animations=
deformers,sceneGraph=sceneGraph.children[0]);sceneGraph.animations=deformers}parseModels(skeletons,geometryMap,materialMap){const modelMap=new Map,modelNodes=fbxTree.Objects.Model;for(const nodeID in modelNodes){const id=parseInt(nodeID),node=modelNodes[nodeID],relationships=connections.get(id);let model=this.buildSkeleton(relationships,skeletons,id,node.attrName);if(!model){switch(node.attrType){case "Camera":model=this.createCamera(relationships);break;case "Light":model=this.createLight(relationships);
break;case "Mesh":model=this.createMesh(relationships,geometryMap,materialMap);break;case "NurbsCurve":model=this.createCurve(relationships,geometryMap);break;case "LimbNode":case "Root":model=new _three.Bone;break;default:model=new _three.Group}model.name=node.attrName?_three.PropertyBinding.sanitizeNodeName(node.attrName):"";model.ID=id}this.getTransformData(model,node);modelMap.set(id,model)}return modelMap}buildSkeleton(relationships,skeletons,id,name){let bone=null;relationships.parents.forEach(function(parent){for(const ID in skeletons){const skeleton=
skeletons[ID];skeleton.rawBones.forEach(function(rawBone,i){if(rawBone.ID===parent.ID){const subBone=bone;bone=new _three.Bone;bone.matrixWorld.copy(rawBone.transformLink);bone.name=name?_three.PropertyBinding.sanitizeNodeName(name):"";bone.ID=id;skeleton.bones[i]=bone;null!==subBone&&bone.add(subBone)}})}});return bone}createCamera(relationships){let cameraAttribute;relationships.children.forEach(function(child){child=fbxTree.Objects.NodeAttribute[child.ID];void 0!==child&&(cameraAttribute=child)});
if(void 0===cameraAttribute)var model=new _three.Object3D;else{model=0;void 0!==cameraAttribute.CameraProjectionType&&1===cameraAttribute.CameraProjectionType.value&&(model=1);let nearClippingPlane=1;void 0!==cameraAttribute.NearPlane&&(nearClippingPlane=cameraAttribute.NearPlane.value/1E3);let farClippingPlane=1E3;void 0!==cameraAttribute.FarPlane&&(farClippingPlane=cameraAttribute.FarPlane.value/1E3);let width=window.innerWidth,height=window.innerHeight;void 0!==cameraAttribute.AspectWidth&&void 0!==
cameraAttribute.AspectHeight&&(width=cameraAttribute.AspectWidth.value,height=cameraAttribute.AspectHeight.value);const aspect=width/height;let fov=45;void 0!==cameraAttribute.FieldOfView&&(fov=cameraAttribute.FieldOfView.value);relationships=cameraAttribute.FocalLength?cameraAttribute.FocalLength.value:null;switch(model){case 0:model=new _three.PerspectiveCamera(fov,aspect,nearClippingPlane,farClippingPlane);null!==relationships&&model.setFocalLength(relationships);break;case 1:model=new _three.OrthographicCamera(-width/
2,width/2,height/2,-height/2,nearClippingPlane,farClippingPlane);break;default:console.warn("THREE.FBXLoader: Unknown camera type "+model+"."),model=new _three.Object3D}}return model}createLight(relationships){let lightAttribute;relationships.children.forEach(function(child){child=fbxTree.Objects.NodeAttribute[child.ID];void 0!==child&&(lightAttribute=child)});if(void 0===lightAttribute)relationships=new _three.Object3D;else{var type=void 0===lightAttribute.LightType?0:lightAttribute.LightType.value;
relationships=16777215;void 0!==lightAttribute.Color&&(relationships=(new _three.Color).fromArray(lightAttribute.Color.value));let intensity=void 0===lightAttribute.Intensity?1:lightAttribute.Intensity.value/100;void 0!==lightAttribute.CastLightOnObject&&0===lightAttribute.CastLightOnObject.value&&(intensity=0);let distance=0;void 0!==lightAttribute.FarAttenuationEnd&&(distance=void 0!==lightAttribute.EnableFarAttenuation&&0===lightAttribute.EnableFarAttenuation.value?0:lightAttribute.FarAttenuationEnd.value);
switch(type){case 0:relationships=new _three.PointLight(relationships,intensity,distance,1);break;case 1:relationships=new _three.DirectionalLight(relationships,intensity);break;case 2:type=Math.PI/3;void 0!==lightAttribute.InnerAngle&&(type=_three.MathUtils.degToRad(lightAttribute.InnerAngle.value));let penumbra=0;void 0!==lightAttribute.OuterAngle&&(penumbra=_three.MathUtils.degToRad(lightAttribute.OuterAngle.value),penumbra=Math.max(penumbra,1));relationships=new _three.SpotLight(relationships,
intensity,distance,type,penumbra,1);break;default:console.warn("THREE.FBXLoader: Unknown light type "+lightAttribute.LightType.value+", defaulting to a PointLight."),relationships=new _three.PointLight(relationships,intensity)}void 0!==lightAttribute.CastShadows&&1===lightAttribute.CastShadows.value&&(relationships.castShadow=!0)}return relationships}createMesh(relationships,geometryMap,materialMap){let geometry=null,material$jscomp$0=null;const materials=[];relationships.children.forEach(function(child){geometryMap.has(child.ID)&&
(geometry=geometryMap.get(child.ID));materialMap.has(child.ID)&&materials.push(materialMap.get(child.ID))});1<materials.length?material$jscomp$0=materials:0<materials.length?material$jscomp$0=materials[0]:(material$jscomp$0=new _three.MeshPhongMaterial({color:13421772}),materials.push(material$jscomp$0));"color"in geometry.attributes&&materials.forEach(function(material){material.vertexColors=!0});geometry.FBX_Deformer?(relationships=new _three.SkinnedMesh(geometry,material$jscomp$0),relationships.normalizeSkinWeights()):
relationships=new _three.Mesh(geometry,material$jscomp$0);return relationships}createCurve(relationships,geometryMap){relationships=relationships.children.reduce(function(geo,child){geometryMap.has(child.ID)&&(geo=geometryMap.get(child.ID));return geo},null);const material=new _three.LineBasicMaterial({color:3342591,linewidth:1});return new _three.Line(relationships,material)}getTransformData(model,modelNode){const transformData={};"InheritType"in modelNode&&(transformData.inheritType=parseInt(modelNode.InheritType.value));
transformData.eulerOrder="RotationOrder"in modelNode?getEulerOrder(modelNode.RotationOrder.value):"ZYX";"Lcl_Translation"in modelNode&&(transformData.translation=modelNode.Lcl_Translation.value);"PreRotation"in modelNode&&(transformData.preRotation=modelNode.PreRotation.value);"Lcl_Rotation"in modelNode&&(transformData.rotation=modelNode.Lcl_Rotation.value);"PostRotation"in modelNode&&(transformData.postRotation=modelNode.PostRotation.value);"Lcl_Scaling"in modelNode&&(transformData.scale=modelNode.Lcl_Scaling.value);
"ScalingOffset"in modelNode&&(transformData.scalingOffset=modelNode.ScalingOffset.value);"ScalingPivot"in modelNode&&(transformData.scalingPivot=modelNode.ScalingPivot.value);"RotationOffset"in modelNode&&(transformData.rotationOffset=modelNode.RotationOffset.value);"RotationPivot"in modelNode&&(transformData.rotationPivot=modelNode.RotationPivot.value);model.userData.transformData=transformData}setLookAtProperties(model,modelNode){"LookAtProperty"in modelNode&&connections.get(model.ID).children.forEach(function(child){"LookAtProperty"===
child.relationship&&(child=fbxTree.Objects.Model[child.ID],"Lcl_Translation"in child&&(child=child.Lcl_Translation.value,void 0!==model.target?(model.target.position.fromArray(child),sceneGraph.add(model.target)):model.lookAt((new _three.Vector3).fromArray(child))))})}bindSkeleton(skeletons,geometryMap,modelMap){const bindMatrices=this.parsePoseNodes();for(const ID in skeletons){const skeleton=skeletons[ID];connections.get(parseInt(skeleton.ID)).parents.forEach(function(parent){geometryMap.has(parent.ID)&&
connections.get(parent.ID).parents.forEach(function(geoConnParent){modelMap.has(geoConnParent.ID)&&modelMap.get(geoConnParent.ID).bind(new _three.Skeleton(skeleton.bones),bindMatrices[geoConnParent.ID])})})}}parsePoseNodes(){const bindMatrices={};if("Pose"in fbxTree.Objects){const BindPoseNode=fbxTree.Objects.Pose;for(const nodeID in BindPoseNode)if("BindPose"===BindPoseNode[nodeID].attrType){const poseNodes=BindPoseNode[nodeID].PoseNode;Array.isArray(poseNodes)?poseNodes.forEach(function(poseNode){bindMatrices[poseNode.Node]=
(new _three.Matrix4).fromArray(poseNode.Matrix.a)}):bindMatrices[poseNodes.Node]=(new _three.Matrix4).fromArray(poseNodes.Matrix.a)}}return bindMatrices}createAmbientLight(){if("GlobalSettings"in fbxTree&&"AmbientColor"in fbxTree.GlobalSettings){var ambientColor=fbxTree.GlobalSettings.AmbientColor.value,r=ambientColor[0];const g=ambientColor[1];ambientColor=ambientColor[2];if(0!==r||0!==g||0!==ambientColor)r=new _three.Color(r,g,ambientColor),sceneGraph.add(new _three.AmbientLight(r,1))}}}class GeometryParser{parse(deformers){const geometryMap=
new Map;if("Geometry"in fbxTree.Objects){const geoNodes=fbxTree.Objects.Geometry;for(const nodeID in geoNodes){var relationships=connections.get(parseInt(nodeID));relationships=this.parseGeometry(relationships,geoNodes[nodeID],deformers);geometryMap.set(parseInt(nodeID),relationships)}}return geometryMap}parseGeometry(relationships,geoNode,deformers){switch(geoNode.attrType){case "Mesh":return this.parseMeshGeometry(relationships,geoNode,deformers);case "NurbsCurve":return this.parseNurbsGeometry(geoNode)}}parseMeshGeometry(relationships,
geoNode,deformers){const skeletons=deformers.skeletons,morphTargets=[];var modelNodes=relationships.parents.map(function(parent){return fbxTree.Objects.Model[parent.ID]});if(0!==modelNodes.length){var skeleton$jscomp$0=relationships.children.reduce(function(skeleton,child){void 0!==skeletons[child.ID]&&(skeleton=skeletons[child.ID]);return skeleton},null);relationships.children.forEach(function(child){void 0!==deformers.morphTargets[child.ID]&&morphTargets.push(deformers.morphTargets[child.ID])});
relationships=modelNodes[0];modelNodes={};"RotationOrder"in relationships&&(modelNodes.eulerOrder=getEulerOrder(relationships.RotationOrder.value));"InheritType"in relationships&&(modelNodes.inheritType=parseInt(relationships.InheritType.value));"GeometricTranslation"in relationships&&(modelNodes.translation=relationships.GeometricTranslation.value);"GeometricRotation"in relationships&&(modelNodes.rotation=relationships.GeometricRotation.value);"GeometricScaling"in relationships&&(modelNodes.scale=
relationships.GeometricScaling.value);relationships=generateTransform(modelNodes);return this.genGeometry(geoNode,skeleton$jscomp$0,morphTargets,relationships)}}genGeometry(geoNode,skeleton,morphTargets,preTransform){const geo=new _three.BufferGeometry;geoNode.attrName&&(geo.name=geoNode.attrName);var geoInfo=this.parseGeoNode(geoNode,skeleton);const buffers=this.genBuffers(geoInfo);var positionAttribute=new _three.Float32BufferAttribute(buffers.vertex,3);positionAttribute.applyMatrix4(preTransform);
geo.setAttribute("position",positionAttribute);0<buffers.colors.length&&geo.setAttribute("color",new _three.Float32BufferAttribute(buffers.colors,3));skeleton&&(geo.setAttribute("skinIndex",new _three.Uint16BufferAttribute(buffers.weightsIndices,4)),geo.setAttribute("skinWeight",new _three.Float32BufferAttribute(buffers.vertexWeights,4)),geo.FBX_Deformer=skeleton);0<buffers.normal.length&&(skeleton=(new _three.Matrix3).getNormalMatrix(preTransform),positionAttribute=new _three.Float32BufferAttribute(buffers.normal,
3),positionAttribute.applyNormalMatrix(skeleton),geo.setAttribute("normal",positionAttribute));buffers.uvs.forEach(function(uvBuffer,i){uvBuffer="uv"+(i+1).toString();0===i&&(uvBuffer="uv");geo.setAttribute(uvBuffer,new _three.Float32BufferAttribute(buffers.uvs[i],2))});if(geoInfo.material&&"AllSame"!==geoInfo.material.mappingType){let prevMaterialIndex=buffers.materialIndex[0],startIndex=0;buffers.materialIndex.forEach(function(currentIndex,i){currentIndex!==prevMaterialIndex&&(geo.addGroup(startIndex,
i-startIndex,prevMaterialIndex),prevMaterialIndex=currentIndex,startIndex=i)});0<geo.groups.length&&(geoInfo=geo.groups[geo.groups.length-1],geoInfo=geoInfo.start+geoInfo.count,geoInfo!==buffers.materialIndex.length&&geo.addGroup(geoInfo,buffers.materialIndex.length-geoInfo,prevMaterialIndex));0===geo.groups.length&&geo.addGroup(0,buffers.materialIndex.length,buffers.materialIndex[0])}this.addMorphTargets(geo,geoNode,morphTargets,preTransform);return geo}parseGeoNode(geoNode,skeleton){const geoInfo=
{};geoInfo.vertexPositions=void 0!==geoNode.Vertices?geoNode.Vertices.a:[];geoInfo.vertexIndices=void 0!==geoNode.PolygonVertexIndex?geoNode.PolygonVertexIndex.a:[];geoNode.LayerElementColor&&(geoInfo.color=this.parseVertexColors(geoNode.LayerElementColor[0]));geoNode.LayerElementMaterial&&(geoInfo.material=this.parseMaterialIndices(geoNode.LayerElementMaterial[0]));geoNode.LayerElementNormal&&(geoInfo.normal=this.parseNormals(geoNode.LayerElementNormal[0]));if(geoNode.LayerElementUV){geoInfo.uv=
[];let i=0;for(;geoNode.LayerElementUV[i];)geoNode.LayerElementUV[i].UV&&geoInfo.uv.push(this.parseUVs(geoNode.LayerElementUV[i])),i++}geoInfo.weightTable={};null!==skeleton&&(geoInfo.skeleton=skeleton,skeleton.rawBones.forEach(function(rawBone,i){rawBone.indices.forEach(function(index,j){void 0===geoInfo.weightTable[index]&&(geoInfo.weightTable[index]=[]);geoInfo.weightTable[index].push({id:i,weight:rawBone.weights[j]})})}));return geoInfo}genBuffers(geoInfo){const buffers={vertex:[],normal:[],colors:[],
uvs:[],materialIndex:[],vertexWeights:[],weightsIndices:[]};let polygonIndex=0,faceLength=0,displayedWeightsWarning=!1,facePositionIndexes=[],faceNormals=[],faceColors=[],faceUVs=[],faceWeights=[],faceWeightIndices=[];const scope=this;geoInfo.vertexIndices.forEach(function(vertexIndex,polygonVertexIndex){let materialIndex,endOfFace=!1;0>vertexIndex&&(vertexIndex^=-1,endOfFace=!0);let weightIndices=[],weights=[];facePositionIndexes.push(3*vertexIndex,3*vertexIndex+1,3*vertexIndex+2);if(geoInfo.color){var data=
getData(polygonVertexIndex,polygonIndex,vertexIndex,geoInfo.color);faceColors.push(data[0],data[1],data[2])}if(geoInfo.skeleton){void 0!==geoInfo.weightTable[vertexIndex]&&geoInfo.weightTable[vertexIndex].forEach(function(wt){weights.push(wt.weight);weightIndices.push(wt.id)});if(4<weights.length){displayedWeightsWarning||(console.warn("THREE.FBXLoader: Vertex has more than 4 skinning weights assigned to vertex. Deleting additional weights."),displayedWeightsWarning=!0);const wIndex=[0,0,0,0],Weight=
[0,0,0,0];weights.forEach(function(weight,weightIndex){let currentWeight=weight,currentIndex=weightIndices[weightIndex];Weight.forEach(function(comparedWeight,comparedWeightIndex,comparedWeightArray){currentWeight>comparedWeight&&(comparedWeightArray[comparedWeightIndex]=currentWeight,currentWeight=comparedWeight,comparedWeight=wIndex[comparedWeightIndex],wIndex[comparedWeightIndex]=currentIndex,currentIndex=comparedWeight)})});weightIndices=wIndex;weights=Weight}for(;4>weights.length;)weights.push(0),
weightIndices.push(0);for(data=0;4>data;++data)faceWeights.push(weights[data]),faceWeightIndices.push(weightIndices[data])}geoInfo.normal&&(data=getData(polygonVertexIndex,polygonIndex,vertexIndex,geoInfo.normal),faceNormals.push(data[0],data[1],data[2]));geoInfo.material&&"AllSame"!==geoInfo.material.mappingType&&(materialIndex=getData(polygonVertexIndex,polygonIndex,vertexIndex,geoInfo.material)[0]);geoInfo.uv&&geoInfo.uv.forEach(function(uv,i){uv=getData(polygonVertexIndex,polygonIndex,vertexIndex,
uv);void 0===faceUVs[i]&&(faceUVs[i]=[]);faceUVs[i].push(uv[0]);faceUVs[i].push(uv[1])});faceLength++;endOfFace&&(scope.genFace(buffers,geoInfo,facePositionIndexes,materialIndex,faceNormals,faceColors,faceUVs,faceWeights,faceWeightIndices,faceLength),polygonIndex++,faceLength=0,facePositionIndexes=[],faceNormals=[],faceColors=[],faceUVs=[],faceWeights=[],faceWeightIndices=[])});return buffers}genFace(buffers,geoInfo,facePositionIndexes,materialIndex,faceNormals,faceColors,faceUVs,faceWeights,faceWeightIndices,
faceLength){for(let i=2;i<faceLength;i++)buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[0]]),buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[1]]),buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[2]]),buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[3*(i-1)]]),buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[3*(i-1)+1]]),buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[3*(i-1)+2]]),buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[3*
i]]),buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[3*i+1]]),buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[3*i+2]]),geoInfo.skeleton&&(buffers.vertexWeights.push(faceWeights[0]),buffers.vertexWeights.push(faceWeights[1]),buffers.vertexWeights.push(faceWeights[2]),buffers.vertexWeights.push(faceWeights[3]),buffers.vertexWeights.push(faceWeights[4*(i-1)]),buffers.vertexWeights.push(faceWeights[4*(i-1)+1]),buffers.vertexWeights.push(faceWeights[4*(i-1)+2]),buffers.vertexWeights.push(faceWeights[4*
(i-1)+3]),buffers.vertexWeights.push(faceWeights[4*i]),buffers.vertexWeights.push(faceWeights[4*i+1]),buffers.vertexWeights.push(faceWeights[4*i+2]),buffers.vertexWeights.push(faceWeights[4*i+3]),buffers.weightsIndices.push(faceWeightIndices[0]),buffers.weightsIndices.push(faceWeightIndices[1]),buffers.weightsIndices.push(faceWeightIndices[2]),buffers.weightsIndices.push(faceWeightIndices[3]),buffers.weightsIndices.push(faceWeightIndices[4*(i-1)]),buffers.weightsIndices.push(faceWeightIndices[4*(i-
1)+1]),buffers.weightsIndices.push(faceWeightIndices[4*(i-1)+2]),buffers.weightsIndices.push(faceWeightIndices[4*(i-1)+3]),buffers.weightsIndices.push(faceWeightIndices[4*i]),buffers.weightsIndices.push(faceWeightIndices[4*i+1]),buffers.weightsIndices.push(faceWeightIndices[4*i+2]),buffers.weightsIndices.push(faceWeightIndices[4*i+3])),geoInfo.color&&(buffers.colors.push(faceColors[0]),buffers.colors.push(faceColors[1]),buffers.colors.push(faceColors[2]),buffers.colors.push(faceColors[3*(i-1)]),buffers.colors.push(faceColors[3*
(i-1)+1]),buffers.colors.push(faceColors[3*(i-1)+2]),buffers.colors.push(faceColors[3*i]),buffers.colors.push(faceColors[3*i+1]),buffers.colors.push(faceColors[3*i+2])),geoInfo.material&&"AllSame"!==geoInfo.material.mappingType&&(buffers.materialIndex.push(materialIndex),buffers.materialIndex.push(materialIndex),buffers.materialIndex.push(materialIndex)),geoInfo.normal&&(buffers.normal.push(faceNormals[0]),buffers.normal.push(faceNormals[1]),buffers.normal.push(faceNormals[2]),buffers.normal.push(faceNormals[3*
(i-1)]),buffers.normal.push(faceNormals[3*(i-1)+1]),buffers.normal.push(faceNormals[3*(i-1)+2]),buffers.normal.push(faceNormals[3*i]),buffers.normal.push(faceNormals[3*i+1]),buffers.normal.push(faceNormals[3*i+2])),geoInfo.uv&&geoInfo.uv.forEach(function(uv,j){void 0===buffers.uvs[j]&&(buffers.uvs[j]=[]);buffers.uvs[j].push(faceUVs[j][0]);buffers.uvs[j].push(faceUVs[j][1]);buffers.uvs[j].push(faceUVs[j][2*(i-1)]);buffers.uvs[j].push(faceUVs[j][2*(i-1)+1]);buffers.uvs[j].push(faceUVs[j][2*i]);buffers.uvs[j].push(faceUVs[j][2*
i+1])})}addMorphTargets(parentGeo,parentGeoNode,morphTargets,preTransform){if(0!==morphTargets.length){parentGeo.morphTargetsRelative=!0;parentGeo.morphAttributes.position=[];var scope=this;morphTargets.forEach(function(morphTarget){morphTarget.rawTargets.forEach(function(rawTarget){const morphGeoNode=fbxTree.Objects.Geometry[rawTarget.geoID];void 0!==morphGeoNode&&scope.genMorphGeometry(parentGeo,parentGeoNode,morphGeoNode,preTransform,rawTarget.name)})})}}genMorphGeometry(parentGeo,parentGeoNode,
morphGeoNode,preTransform,name){parentGeoNode=void 0!==parentGeoNode.PolygonVertexIndex?parentGeoNode.PolygonVertexIndex.a:[];const morphPositionsSparse=void 0!==morphGeoNode.Vertices?morphGeoNode.Vertices.a:[],indices=void 0!==morphGeoNode.Indexes?morphGeoNode.Indexes.a:[],morphPositions=new Float32Array(3*parentGeo.attributes.position.count);for(let i=0;i<indices.length;i++){const morphIndex=3*indices[i];morphPositions[morphIndex]=morphPositionsSparse[3*i];morphPositions[morphIndex+1]=morphPositionsSparse[3*
i+1];morphPositions[morphIndex+2]=morphPositionsSparse[3*i+2]}parentGeoNode=this.genBuffers({vertexIndices:parentGeoNode,vertexPositions:morphPositions});parentGeoNode=new _three.Float32BufferAttribute(parentGeoNode.vertex,3);parentGeoNode.name=name||morphGeoNode.attrName;parentGeoNode.applyMatrix4(preTransform);parentGeo.morphAttributes.position.push(parentGeoNode)}parseNormals(NormalNode){const mappingType=NormalNode.MappingInformationType,referenceType=NormalNode.ReferenceInformationType,buffer=
NormalNode.Normals.a;let indexBuffer=[];"IndexToDirect"===referenceType&&("NormalIndex"in NormalNode?indexBuffer=NormalNode.NormalIndex.a:"NormalsIndex"in NormalNode&&(indexBuffer=NormalNode.NormalsIndex.a));return{dataSize:3,buffer,indices:indexBuffer,mappingType,referenceType}}parseUVs(UVNode){const mappingType=UVNode.MappingInformationType,referenceType=UVNode.ReferenceInformationType,buffer=UVNode.UV.a;let indexBuffer=[];"IndexToDirect"===referenceType&&(indexBuffer=UVNode.UVIndex.a);return{dataSize:2,
buffer,indices:indexBuffer,mappingType,referenceType}}parseVertexColors(ColorNode){const mappingType=ColorNode.MappingInformationType,referenceType=ColorNode.ReferenceInformationType,buffer=ColorNode.Colors.a;let indexBuffer=[];"IndexToDirect"===referenceType&&(indexBuffer=ColorNode.ColorIndex.a);return{dataSize:4,buffer,indices:indexBuffer,mappingType,referenceType}}parseMaterialIndices(MaterialNode){const mappingType=MaterialNode.MappingInformationType,referenceType=MaterialNode.ReferenceInformationType;
if("NoMappingInformation"===mappingType)return{dataSize:1,buffer:[0],indices:[0],mappingType:"AllSame",referenceType};MaterialNode=MaterialNode.Materials.a;const materialIndices=[];for(let i=0;i<MaterialNode.length;++i)materialIndices.push(i);return{dataSize:1,buffer:MaterialNode,indices:materialIndices,mappingType,referenceType}}parseNurbsGeometry(geoNode){if(void 0===_NURBSCurve.NURBSCurve)return console.error("THREE.FBXLoader: The loader relies on NURBSCurve for any nurbs present in the model. Nurbs will show up as empty geometry."),
new _three.BufferGeometry;var order=parseInt(geoNode.Order);if(isNaN(order))return console.error("THREE.FBXLoader: Invalid Order %s given for geometry ID: %s",geoNode.Order,geoNode.id),new _three.BufferGeometry;--order;const knots=geoNode.KnotVector.a,controlPoints=[],pointsValues=geoNode.Points.a;for(let i=0,l=pointsValues.length;i<l;i+=4)controlPoints.push((new _three.Vector4).fromArray(pointsValues,i));let endKnot;if("Closed"===geoNode.Form)controlPoints.push(controlPoints[0]);else if("Periodic"===
geoNode.Form){var startKnot=order;endKnot=knots.length-1-startKnot;for(geoNode=0;geoNode<order;++geoNode)controlPoints.push(controlPoints[geoNode])}startKnot=(new _NURBSCurve.NURBSCurve(order,knots,controlPoints,startKnot,endKnot)).getPoints(12*controlPoints.length);return(new _three.BufferGeometry).setFromPoints(startKnot)}}class AnimationParser{parse(){const animationClips=[],rawClips=this.parseClips();if(void 0!==rawClips)for(const key in rawClips){const clip=this.addClip(rawClips[key]);animationClips.push(clip)}return animationClips}parseClips(){if(void 0!==
fbxTree.Objects.AnimationCurve){var curveNodesMap=this.parseAnimationCurveNodes();this.parseAnimationCurves(curveNodesMap);curveNodesMap=this.parseAnimationLayers(curveNodesMap);return this.parseAnimStacks(curveNodesMap)}}parseAnimationCurveNodes(){const rawCurveNodes=fbxTree.Objects.AnimationCurveNode,curveNodesMap=new Map;for(const nodeID in rawCurveNodes){var rawCurveNode=rawCurveNodes[nodeID];null!==rawCurveNode.attrName.match(/S|R|T|DeformPercent/)&&(rawCurveNode={id:rawCurveNode.id,attr:rawCurveNode.attrName,
curves:{}},curveNodesMap.set(rawCurveNode.id,rawCurveNode))}return curveNodesMap}parseAnimationCurves(curveNodesMap){const rawCurves=fbxTree.Objects.AnimationCurve;for(const nodeID in rawCurves){const animationCurve={id:rawCurves[nodeID].id,times:rawCurves[nodeID].KeyTime.a.map(convertFBXTimeToSeconds),values:rawCurves[nodeID].KeyValueFloat.a};var relationships=connections.get(animationCurve.id);if(void 0!==relationships){const animationCurveID=relationships.parents[0].ID;relationships=relationships.parents[0].relationship;
relationships.match(/X/)?curveNodesMap.get(animationCurveID).curves.x=animationCurve:relationships.match(/Y/)?curveNodesMap.get(animationCurveID).curves.y=animationCurve:relationships.match(/Z/)?curveNodesMap.get(animationCurveID).curves.z=animationCurve:relationships.match(/d|DeformPercent/)&&curveNodesMap.has(animationCurveID)&&(curveNodesMap.get(animationCurveID).curves.morph=animationCurve)}}}parseAnimationLayers(curveNodesMap){var rawLayers=fbxTree.Objects.AnimationLayer;const layersMap=new Map;
for(const nodeID in rawLayers){const layerCurveNodes=[];rawLayers=connections.get(parseInt(nodeID));void 0!==rawLayers&&(rawLayers.children.forEach(function(child$jscomp$0,i){if(curveNodesMap.has(child$jscomp$0.ID)){const curveNode=curveNodesMap.get(child$jscomp$0.ID);if(void 0!==curveNode.curves.x||void 0!==curveNode.curves.y||void 0!==curveNode.curves.z){if(void 0===layerCurveNodes[i]){var modelID=connections.get(child$jscomp$0.ID).parents.filter(function(parent){return void 0!==parent.relationship})[0].ID;
if(void 0!==modelID){const rawModel=fbxTree.Objects.Model[modelID.toString()];if(void 0===rawModel){console.warn("THREE.FBXLoader: Encountered a unused curve.",child$jscomp$0);return}const node={modelName:rawModel.attrName?_three.PropertyBinding.sanitizeNodeName(rawModel.attrName):"",ID:rawModel.id,initialPosition:[0,0,0],initialRotation:[0,0,0],initialScale:[1,1,1]};sceneGraph.traverse(function(child){child.ID===rawModel.id&&(node.transform=child.matrix,child.userData.transformData&&(node.eulerOrder=
child.userData.transformData.eulerOrder))});node.transform||(node.transform=new _three.Matrix4);"PreRotation"in rawModel&&(node.preRotation=rawModel.PreRotation.value);"PostRotation"in rawModel&&(node.postRotation=rawModel.PostRotation.value);layerCurveNodes[i]=node}}layerCurveNodes[i]&&(layerCurveNodes[i][curveNode.attr]=curveNode)}else void 0!==curveNode.curves.morph&&(void 0===layerCurveNodes[i]&&(child$jscomp$0=connections.get(child$jscomp$0.ID).parents.filter(function(parent){return void 0!==
parent.relationship})[0].ID,modelID=connections.get(child$jscomp$0).parents[0].ID,modelID=connections.get(modelID).parents[0].ID,modelID=connections.get(modelID).parents[0].ID,modelID=fbxTree.Objects.Model[modelID],child$jscomp$0={modelName:modelID.attrName?_three.PropertyBinding.sanitizeNodeName(modelID.attrName):"",morphName:fbxTree.Objects.Deformer[child$jscomp$0].attrName},layerCurveNodes[i]=child$jscomp$0),layerCurveNodes[i][curveNode.attr]=curveNode)}}),layersMap.set(parseInt(nodeID),layerCurveNodes))}return layersMap}parseAnimStacks(layersMap){const rawStacks=
fbxTree.Objects.AnimationStack,rawClips={};for(const nodeID in rawStacks){var children=connections.get(parseInt(nodeID)).children;1<children.length&&console.warn("THREE.FBXLoader: Encountered an animation stack with multiple layers, this is currently not supported. Ignoring subsequent layers.");children=layersMap.get(children[0].ID);rawClips[nodeID]={name:rawStacks[nodeID].attrName,layer:children}}return rawClips}addClip(rawClip){let tracks=[];const scope=this;rawClip.layer.forEach(function(rawTracks){tracks=
tracks.concat(scope.generateTracks(rawTracks))});return new _three.AnimationClip(rawClip.name,-1,tracks)}generateTracks(rawTracks){const tracks=[];var initialPosition=new _three.Vector3,initialRotation=new _three.Quaternion,initialScale=new _three.Vector3;rawTracks.transform&&rawTracks.transform.decompose(initialPosition,initialRotation,initialScale);initialPosition=initialPosition.toArray();initialRotation=(new _three.Euler).setFromQuaternion(initialRotation,rawTracks.eulerOrder).toArray();initialScale=
initialScale.toArray();void 0!==rawTracks.T&&0<Object.keys(rawTracks.T.curves).length&&(initialPosition=this.generateVectorTrack(rawTracks.modelName,rawTracks.T.curves,initialPosition,"position"),void 0!==initialPosition&&tracks.push(initialPosition));void 0!==rawTracks.R&&0<Object.keys(rawTracks.R.curves).length&&(initialRotation=this.generateRotationTrack(rawTracks.modelName,rawTracks.R.curves,initialRotation,rawTracks.preRotation,rawTracks.postRotation,rawTracks.eulerOrder),void 0!==initialRotation&&
tracks.push(initialRotation));void 0!==rawTracks.S&&0<Object.keys(rawTracks.S.curves).length&&(initialScale=this.generateVectorTrack(rawTracks.modelName,rawTracks.S.curves,initialScale,"scale"),void 0!==initialScale&&tracks.push(initialScale));void 0!==rawTracks.DeformPercent&&(rawTracks=this.generateMorphTrack(rawTracks),void 0!==rawTracks&&tracks.push(rawTracks));return tracks}generateVectorTrack(modelName,curves,initialValue,type){const times=this.getTimesForAllAxes(curves);curves=this.getKeyframeTrackValues(times,
curves,initialValue);return new _three.VectorKeyframeTrack(modelName+"."+type,times,curves)}generateRotationTrack(modelName,curves,initialValue,preRotation,postRotation,eulerOrder){void 0!==curves.x&&(this.interpolateRotations(curves.x),curves.x.values=curves.x.values.map(_three.MathUtils.degToRad));void 0!==curves.y&&(this.interpolateRotations(curves.y),curves.y.values=curves.y.values.map(_three.MathUtils.degToRad));void 0!==curves.z&&(this.interpolateRotations(curves.z),curves.z.values=curves.z.values.map(_three.MathUtils.degToRad));
const times=this.getTimesForAllAxes(curves);curves=this.getKeyframeTrackValues(times,curves,initialValue);void 0!==preRotation&&(preRotation=preRotation.map(_three.MathUtils.degToRad),preRotation.push(eulerOrder),preRotation=(new _three.Euler).fromArray(preRotation),preRotation=(new _three.Quaternion).setFromEuler(preRotation));void 0!==postRotation&&(postRotation=postRotation.map(_three.MathUtils.degToRad),postRotation.push(eulerOrder),postRotation=(new _three.Euler).fromArray(postRotation),postRotation=
(new _three.Quaternion).setFromEuler(postRotation).invert());initialValue=new _three.Quaternion;const euler=new _three.Euler,quaternionValues=[];for(let i=0;i<curves.length;i+=3)euler.set(curves[i],curves[i+1],curves[i+2],eulerOrder),initialValue.setFromEuler(euler),void 0!==preRotation&&initialValue.premultiply(preRotation),void 0!==postRotation&&initialValue.multiply(postRotation),initialValue.toArray(quaternionValues,i/3*4);return new _three.QuaternionKeyframeTrack(modelName+".quaternion",times,
quaternionValues)}generateMorphTrack(rawTracks){const curves=rawTracks.DeformPercent.curves.morph,values=curves.values.map(function(val){return val/100}),morphNum=sceneGraph.getObjectByName(rawTracks.modelName).morphTargetDictionary[rawTracks.morphName];return new _three.NumberKeyframeTrack(rawTracks.modelName+".morphTargetInfluences["+morphNum+"]",curves.times,values)}getTimesForAllAxes(curves){let times=[];void 0!==curves.x&&(times=times.concat(curves.x.times));void 0!==curves.y&&(times=times.concat(curves.y.times));
void 0!==curves.z&&(times=times.concat(curves.z.times));times=times.sort(function(a,b){return a-b});if(1<times.length){curves=1;let lastValue=times[0];for(let i=1;i<times.length;i++){const currentValue=times[i];currentValue!==lastValue&&(lastValue=times[curves]=currentValue,curves++)}times=times.slice(0,curves)}return times}getKeyframeTrackValues(times,curves,initialValue){const values=[];let xIndex=-1,yIndex=-1,zIndex=-1;times.forEach(function(time){curves.x&&(xIndex=curves.x.times.indexOf(time));
curves.y&&(yIndex=curves.y.times.indexOf(time));curves.z&&(zIndex=curves.z.times.indexOf(time));-1!==xIndex?(time=curves.x.values[xIndex],values.push(time),initialValue[0]=time):values.push(initialValue[0]);-1!==yIndex?(time=curves.y.values[yIndex],values.push(time),initialValue[1]=time):values.push(initialValue[1]);-1!==zIndex?(time=curves.z.values[zIndex],values.push(time),initialValue[2]=time):values.push(initialValue[2])});return values}interpolateRotations(curve){for(let i=1;i<curve.values.length;i++){var initialValue=
curve.values[i-1],valuesSpan=curve.values[i]-initialValue,absoluteSpan=Math.abs(valuesSpan);if(180<=absoluteSpan){absoluteSpan/=180;valuesSpan/=absoluteSpan;initialValue+=valuesSpan;var initialTime=curve.times[i-1];absoluteSpan=(curve.times[i]-initialTime)/absoluteSpan;initialTime+=absoluteSpan;const interpolatedTimes=[],interpolatedValues=[];for(;initialTime<curve.times[i];)interpolatedTimes.push(initialTime),initialTime+=absoluteSpan,interpolatedValues.push(initialValue),initialValue+=valuesSpan;
curve.times=inject(curve.times,i,interpolatedTimes);curve.values=inject(curve.values,i,interpolatedValues)}}}}class TextParser{getPrevNode(){return this.nodeStack[this.currentIndent-2]}getCurrentNode(){return this.nodeStack[this.currentIndent-1]}getCurrentProp(){return this.currentProp}pushStack(node){this.nodeStack.push(node);this.currentIndent+=1}popStack(){this.nodeStack.pop();--this.currentIndent}setCurrentProp(val,name){this.currentProp=val;this.currentPropName=name}parse(text){this.currentIndent=
0;this.allNodes=new FBXTree;this.nodeStack=[];this.currentProp=[];this.currentPropName="";const scope=this,split=text.split(/[\r\n]+/);split.forEach(function(line,i){var matchComment=line.match(/^[\s\t]*;/),matchEmpty=line.match(/^[\s\t]*$/);if(!matchComment&&!matchEmpty){matchComment=line.match("^\\t{"+scope.currentIndent+"}(\\w+):(.*){","");matchEmpty=line.match("^\\t{"+scope.currentIndent+"}(\\w+):[\\s\\t\\r\\n](.*)");var matchEnd=line.match("^\\t{"+(scope.currentIndent-1)+"}}");matchComment?scope.parseNodeBegin(line,
matchComment):matchEmpty?scope.parseNodeProperty(line,matchEmpty,split[++i]):matchEnd?scope.popStack():line.match(/^[^\s\t}]/)&&scope.parseNodePropertyContinued(line)}});return this.allNodes}parseNodeBegin(line,property){line=property[1].trim().replace(/^"/,"").replace(/"$/,"");var nodeAttrs=property[2].split(",").map(function(attr){return attr.trim().replace(/^"/,"").replace(/"$/,"")});property={name:line};nodeAttrs=this.parseNodeAttr(nodeAttrs);const currentNode=this.getCurrentNode();0===this.currentIndent?
this.allNodes.add(line,property):line in currentNode?("PoseNode"===line?currentNode.PoseNode.push(property):void 0!==currentNode[line].id&&(currentNode[line]={},currentNode[line][currentNode[line].id]=currentNode[line]),""!==nodeAttrs.id&&(currentNode[line][nodeAttrs.id]=property)):"number"===typeof nodeAttrs.id?(currentNode[line]={},currentNode[line][nodeAttrs.id]=property):"Properties70"!==line&&(currentNode[line]="PoseNode"===line?[property]:property);"number"===typeof nodeAttrs.id&&(property.id=
nodeAttrs.id);""!==nodeAttrs.name&&(property.attrName=nodeAttrs.name);""!==nodeAttrs.type&&(property.attrType=nodeAttrs.type);this.pushStack(property)}parseNodeAttr(attrs){let id=attrs[0];""!==attrs[0]&&(id=parseInt(attrs[0]),isNaN(id)&&(id=attrs[0]));let name="",type="";1<attrs.length&&(name=attrs[1].replace(/^(\w+)::/,""),type=attrs[2]);return{id,name,type}}parseNodeProperty(line,property,contentLine){var propName=property[1].replace(/^"/,"").replace(/"$/,"").trim();property=property[2].replace(/^"/,
"").replace(/"$/,"").trim();"Content"===propName&&","===property&&(property=contentLine.replace(/"/g,"").replace(/,$/,"").trim());contentLine=this.getCurrentNode();if("Properties70"===contentLine.name)this.parseNodeSpecialProperty(line,propName,property);else{if("C"===propName){propName=property.split(",").slice(1);line=parseInt(propName[0]);const to=parseInt(propName[1]);let rest=property.split(",").slice(3);rest=rest.map(function(elem){return elem.trim().replace(/^"/,"")});propName="connections";
property=[line,to];append(property,rest);void 0===contentLine[propName]&&(contentLine[propName]=[])}"Node"===propName&&(contentLine.id=property);propName in contentLine&&Array.isArray(contentLine[propName])?contentLine[propName].push(property):"a"!==propName?contentLine[propName]=property:contentLine.a=property;this.setCurrentProp(contentLine,propName);"a"===propName&&","!==property.slice(-1)&&(contentLine.a=parseNumberArray(property))}}parseNodePropertyContinued(line){const currentNode=this.getCurrentNode();
currentNode.a+=line;","!==line.slice(-1)&&(currentNode.a=parseNumberArray(currentNode.a))}parseNodeSpecialProperty(line,propName,propValue){var props=propValue.split('",').map(function(prop){return prop.trim().replace(/^"/,"").replace(/\s/,"_")});line=props[0];propName=props[1];propValue=props[2];const innerPropFlag=props[3];props=props[4];switch(propName){case "int":case "enum":case "bool":case "ULongLong":case "double":case "Number":case "FieldOfView":props=parseFloat(props);break;case "Color":case "ColorRGB":case "Vector3D":case "Lcl_Translation":case "Lcl_Rotation":case "Lcl_Scaling":props=
parseNumberArray(props)}this.getPrevNode()[line]={type:propName,type2:propValue,flag:innerPropFlag,value:props};this.setCurrentProp(this.getPrevNode(),line)}}class BinaryParser{parse(buffer){buffer=new BinaryReader(buffer);buffer.skip(23);const version=buffer.getUint32();if(6400>version)throw Error("THREE.FBXLoader: FBX version not supported, FileVersion: "+version);const allNodes=new FBXTree;for(;!this.endOfContent(buffer);){const node=this.parseNode(buffer,version);null!==node&&allNodes.add(node.name,
node)}return allNodes}endOfContent(reader){return 0===reader.size()%16?(reader.getOffset()+160+16&-16)>=reader.size():reader.getOffset()+160+16>=reader.size()}parseNode(reader,version){const node={},endOffset=7500<=version?reader.getUint64():reader.getUint32();var numProperties=7500<=version?reader.getUint64():reader.getUint32();7500<=version?reader.getUint64():reader.getUint32();var nameLen=reader.getUint8();nameLen=reader.getString(nameLen);if(0===endOffset)return null;const propertyList=[];for(var i=
0;i<numProperties;i++)propertyList.push(this.parseProperty(reader));i=0<propertyList.length?propertyList[0]:"";const attrName=1<propertyList.length?propertyList[1]:"",attrType=2<propertyList.length?propertyList[2]:"";for(node.singleProperty=1===numProperties&&reader.getOffset()===endOffset?!0:!1;endOffset>reader.getOffset();)numProperties=this.parseNode(reader,version),null!==numProperties&&this.parseSubNode(nameLen,node,numProperties);node.propertyList=propertyList;"number"===typeof i&&(node.id=
i);""!==attrName&&(node.attrName=attrName);""!==attrType&&(node.attrType=attrType);""!==nameLen&&(node.name=nameLen);return node}parseSubNode(name,node,subNode){if(!0===subNode.singleProperty)name=subNode.propertyList[0],Array.isArray(name)?(node[subNode.name]=subNode,subNode.a=name):node[subNode.name]=name;else if("Connections"===name&&"C"===subNode.name){const array=[];subNode.propertyList.forEach(function(property,i){0!==i&&array.push(property)});void 0===node.connections&&(node.connections=[]);
node.connections.push(array)}else if("Properties70"===subNode.name)Object.keys(subNode).forEach(function(key){node[key]=subNode[key]});else if("Properties70"===name&&"P"===subNode.name){name=subNode.propertyList[0];let innerPropType1=subNode.propertyList[1];const innerPropType2=subNode.propertyList[2],innerPropFlag=subNode.propertyList[3];let innerPropValue;0===name.indexOf("Lcl ")&&(name=name.replace("Lcl ","Lcl_"));0===innerPropType1.indexOf("Lcl ")&&(innerPropType1=innerPropType1.replace("Lcl ",
"Lcl_"));innerPropValue="Color"===innerPropType1||"ColorRGB"===innerPropType1||"Vector"===innerPropType1||"Vector3D"===innerPropType1||0===innerPropType1.indexOf("Lcl_")?[subNode.propertyList[4],subNode.propertyList[5],subNode.propertyList[6]]:subNode.propertyList[4];node[name]={type:innerPropType1,type2:innerPropType2,flag:innerPropFlag,value:innerPropValue}}else void 0===node[subNode.name]?"number"===typeof subNode.id?(node[subNode.name]={},node[subNode.name][subNode.id]=subNode):node[subNode.name]=
subNode:"PoseNode"===subNode.name?(Array.isArray(node[subNode.name])||(node[subNode.name]=[node[subNode.name]]),node[subNode.name].push(subNode)):void 0===node[subNode.name][subNode.id]&&(node[subNode.name][subNode.id]=subNode)}parseProperty(reader){var type=reader.getString(1);switch(type){case "C":return reader.getBoolean();case "D":return reader.getFloat64();case "F":return reader.getFloat32();case "I":return reader.getInt32();case "L":return reader.getInt64();case "R":return type=reader.getUint32(),
reader.getArrayBuffer(type);case "S":return type=reader.getUint32(),reader.getString(type);case "Y":return reader.getInt16();case "b":case "c":case "d":case "f":case "i":case "l":const arrayLength=reader.getUint32(),encoding=reader.getUint32(),compressedLength=reader.getUint32();if(0===encoding)switch(type){case "b":case "c":return reader.getBooleanArray(arrayLength);case "d":return reader.getFloat64Array(arrayLength);case "f":return reader.getFloat32Array(arrayLength);case "i":return reader.getInt32Array(arrayLength);
case "l":return reader.getInt64Array(arrayLength)}"undefined"===typeof fflate&&console.error("THREE.FBXLoader: External library fflate.min.js required.");reader=fflate.unzlibSync(new Uint8Array(reader.getArrayBuffer(compressedLength)));reader=new BinaryReader(reader.buffer);switch(type){case "b":case "c":return reader.getBooleanArray(arrayLength);case "d":return reader.getFloat64Array(arrayLength);case "f":return reader.getFloat32Array(arrayLength);case "i":return reader.getInt32Array(arrayLength);
case "l":return reader.getInt64Array(arrayLength)}default:throw Error("THREE.FBXLoader: Unknown property type "+type);}}}class BinaryReader{constructor(buffer,littleEndian){this.dv=new DataView(buffer);this.offset=0;this.littleEndian=void 0!==littleEndian?littleEndian:!0}getOffset(){return this.offset}size(){return this.dv.buffer.byteLength}skip(length){this.offset+=length}getBoolean(){return 1===(this.getUint8()&1)}getBooleanArray(size){const a=[];for(let i=0;i<size;i++)a.push(this.getBoolean());
return a}getUint8(){const value=this.dv.getUint8(this.offset);this.offset+=1;return value}getInt16(){const value=this.dv.getInt16(this.offset,this.littleEndian);this.offset+=2;return value}getInt32(){const value=this.dv.getInt32(this.offset,this.littleEndian);this.offset+=4;return value}getInt32Array(size){const a=[];for(let i=0;i<size;i++)a.push(this.getInt32());return a}getUint32(){const value=this.dv.getUint32(this.offset,this.littleEndian);this.offset+=4;return value}getInt64(){let low,high;this.littleEndian?
(low=this.getUint32(),high=this.getUint32()):(high=this.getUint32(),low=this.getUint32());return high&2147483648?(high=~high&4294967295,low=~low&4294967295,4294967295===low&&(high=high+1&4294967295),-(4294967296*high+(low+1&4294967295))):4294967296*high+low}getInt64Array(size){const a=[];for(let i=0;i<size;i++)a.push(this.getInt64());return a}getUint64(){let low,high;this.littleEndian?(low=this.getUint32(),high=this.getUint32()):(high=this.getUint32(),low=this.getUint32());return 4294967296*high+
low}getFloat32(){const value=this.dv.getFloat32(this.offset,this.littleEndian);this.offset+=4;return value}getFloat32Array(size){const a=[];for(let i=0;i<size;i++)a.push(this.getFloat32());return a}getFloat64(){const value=this.dv.getFloat64(this.offset,this.littleEndian);this.offset+=8;return value}getFloat64Array(size){const a=[];for(let i=0;i<size;i++)a.push(this.getFloat64());return a}getArrayBuffer(size){const value=this.dv.buffer.slice(this.offset,this.offset+size);this.offset+=size;return value}getString(size){let a=
[];for(let i=0;i<size;i++)a[i]=this.getUint8();size=a.indexOf(0);0<=size&&(a=a.slice(0,size));return _three.LoaderUtils.decodeText(new Uint8Array(a))}}class FBXTree{add(key,val){this[key]=val}}const dataArray=[],tempEuler=new _three.Euler,tempVec=new _three.Vector3}
//# sourceMappingURL=module$node_modules$three$examples$jsm$loaders$FBXLoader.js.map
