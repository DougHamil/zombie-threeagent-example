{
"version":3,
"file":"module$node_modules$troika_three_utils$dist$troika_three_utils_esm.js",
"lineCount":43,
"mappings":"AAAAA,cAAA,CAAA,kEAAA,CAAuF,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CA8B/HC,QAASA,qBAAoB,CAACC,MAAD,CAAS,CAQpC,MAAOA,OAAOC,CAAAA,OAAP,CAPSC,kCAOT,CALPD,QAAgB,CAACE,KAAD,CAAQC,OAAR,CAAiB,CAE/B,MAAO,CADHC,OACG,CADKC,MAAOC,CAAAA,WAAP,CAAmBH,OAAnB,CACL,EAAQL,oBAAA,CAAqBM,OAArB,CAAR,CAAsCF,KAFd,CAK1B,CAR6B,CA0HtCK,QAASA,sBAAqB,CAACC,YAAD,CAAeC,OAAf,CAAwB,CAKpD,MAAMC,WAAaC,gBAAA,CAAiBF,OAAjB,CAGnB,KAAIG,kBAAoBC,iBAAkBC,CAAAA,GAAlB,CAAsBN,YAAtB,CAEnBI,kBAAL,EACEC,iBAAkBE,CAAAA,GAAlB,CAAsBP,YAAtB;AAAoCI,iBAApC,CAAwDI,MAAOC,CAAAA,MAAP,CAAc,IAAd,CAAxD,CAGF,IAAIL,iBAAA,CAAkBF,UAAlB,CAAJ,CACE,MAAO,KAAIE,iBAAA,CAAkBF,UAAlB,CAGb,OAAMQ,yBAA2B,mBAAmBR,UAAnB,EAAjC,CAGMS,gBAAkBA,QAAS,CAACC,UAAD,CAAa,CAC5CZ,YAAaW,CAAAA,eAAgBE,CAAAA,IAA7B,CAAkC,IAAlC,CAAwCD,UAAxC,CAEA,OAAME,SAAWZ,UAAXY,CAAwB,KAAxBA,CAAgCF,UAAWG,CAAAA,YAA3CD,CAA0D,KAA1DA,CAAkEF,UAAWI,CAAAA,cACnF,KAAIC,gBAAkBC,oBAAA,CAAqBJ,QAArB,CAEjBG,gBAAL,GACQE,eACN,CADiBC,cAAA,CAAeR,UAAf,CAA2BX,OAA3B,CAAoCC,UAApC,CACjB,CAAAe,eAAA,CAAkBC,oBAAA,CAAqBJ,QAArB,CAAlB;AAAmDK,eAFrD,CAMAP,WAAWG,CAAAA,YAAX,CAA0BE,eAAgBF,CAAAA,YAC1CH,WAAWI,CAAAA,cAAX,CAA4BC,eAAgBD,CAAAA,cAC5CK,OAAA,CAAOT,UAAWU,CAAAA,QAAlB,CAA4B,IAAKA,CAAAA,QAAjC,CAEIrB,QAAQsB,CAAAA,WAAZ,GACEX,UAAWU,CAAAA,QAAX,CAAoBrB,OAAQsB,CAAAA,WAA5B,CADF,CAC6C,CACrCC,SAAQ,EAAA,CACV,MAAOC,KAAKC,CAAAA,GAAL,EAAP,CAAoBC,KADV,CAD6B,CAD7C,CAUA,IAAI,IAAA,CAAKjB,wBAAL,CAAJ,CACE,IAAA,CAAKA,wBAAL,CAAA,CAA+BE,UAA/B,CA3B0C,CAH9C,CAkCMgB,gBAAkBA,QAAwB,EAAG,CACjD,MAAOC,OAAA,CAAO5B,OAAQ6B,CAAAA,OAAR,CAAkB9B,YAAlB,CAAiCA,YAAa+B,CAAAA,KAAb,EAAxC,CAD0C,CAlCnD,CAsCMF,OAASA,QAAS,CAACG,IAAD,CAAO,CAE7B,MAAMC,QAAUzB,MAAOC,CAAAA,MAAP,CAAcuB,IAAd,CAAoBE,UAApB,CAEhB1B;MAAO2B,CAAAA,cAAP,CAAsBF,OAAtB,CAA+B,cAA/B,CAA+C,CAC7CT,MAAOxB,YADsC,CAA/C,CAIAQ,OAAO2B,CAAAA,cAAP,CAAsBF,OAAtB,CAA+B,IAA/B,CAAqC,CACnCT,MAAOY,kBAAA,EAD4B,CAArC,CAjKIC,KAAAA,yBAAqB,UAArBA,CAAKC,IAAKC,CAAAA,MAAL,EAALF,CAAkC,CACxC,OAAMG,GAAqB,UAArBA,CAAKF,IAAKC,CAAAA,MAAL,EAALC,CAAkC,CAAxC,CACMC,GAAqB,UAArBA,CAAKH,IAAKC,CAAAA,MAAL,EAALE,CAAkC,CADxC,CAEMC,GAAqB,UAArBA,CAAKJ,IAAKC,CAAAA,MAAL,EAALG,CAAkC,CAGxC,yBAAA,CAAYC,CAFCC,IAAA,CAAKP,wBAAL,CAAU,GAAV,CAEDM,CAFmBC,IAAA,CAAKP,wBAAL,EAAW,CAAX,CAAe,GAAf,CAEnBM,CAF0CC,IAAA,CAAKP,wBAAL,EAAW,EAAX,CAAgB,GAAhB,CAE1CM,CAFkEC,IAAA,CAAKP,wBAAL,EAAW,EAAX,CAAgB,GAAhB,CAElEM,CAF0F,GAE1FA,CAFgGC,IAAA,CAAKJ,EAAL,CAAU,GAAV,CAEhGG,CAFkHC,IAAA,CAAKJ,EAAL,EAAW,CAAX,CAAe,GAAf,CAElHG,CAFyI,GAEzIA,CAF+IC,IAAA,CAAKJ,EAAL;AAAW,EAAX,CAAgB,EAAhB,CAAuB,EAAvB,CAE/IG,CAF8KC,IAAA,CAAKJ,EAAL,EAAW,EAAX,CAAgB,GAAhB,CAE9KG,CAFsM,GAEtMA,CAF4MC,IAAA,CAAKH,EAAL,CAAU,EAAV,CAAiB,GAAjB,CAE5ME,CAFqOC,IAAA,CAAKH,EAAL,EAAW,CAAX,CAAe,GAAf,CAErOE,CAF4P,GAE5PA,CAFkQC,IAAA,CAAKH,EAAL,EAAW,EAAX,CAAgB,GAAhB,CAElQE,CAF0RC,IAAA,CAAKH,EAAL,EAAW,EAAX,CAAgB,GAAhB,CAE1RE,CAFkTC,IAAA,CAAKF,EAAL,CAAU,GAAV,CAElTC,CAFoUC,IAAA,CAAKF,EAAL,EAAW,CAAX,CAAe,GAAf,CAEpUC,CAF2VC,IAAA,CAAKF,EAAL,EAAW,EAAX,CAAgB,GAAhB,CAE3VC,CAFmXC,IAAA,CAAKF,EAAL,EAAW,EAAX,CAAgB,GAAhB,CAEnXC,EAAAA,WAAL,EA8JLV,QAAQY,CAAAA,IAAR,CAAe,wBAEfZ,QAAQX,CAAAA,QAAR,CAAmBD,MAAA,CAAO,EAAP,CAAWW,IAAKV,CAAAA,QAAhB,CAA0BrB,OAAQqB,CAAAA,QAAlC,CACnBW,QAAQa,CAAAA,OAAR,CAAkBzB,MAAA,CAAO,EAAP,CAAWW,IAAKc,CAAAA,OAAhB,CAAyB7C,OAAQ6C,CAAAA,OAAjC,CAClBb,QAAQa,CAAAA,OAAR,CAAgB,2BAA2B5C,UAA3B,EAAhB,CAAA,CAA2D,EAE3D+B,QAAQc,CAAAA,UAAR,CAAqB1B,MAAA,CAAO,EAAP,CAAWW,IAAKe,CAAAA,UAAhB,CAA4B9C,OAAQ8C,CAAAA,UAApC,CAErBd,QAAQe,CAAAA,UAAR,CAAqBC,IAAAA,EACrB,OAAOhB,QApBsB,CAtC/B,CA6DMC;AAAa,CACjBgB,YAAa,CACX1B,MAAOI,eADI,CADI,CAIjBuB,kBAAmB,CACjB3B,MAAO,CAAA,CADU,CAJF,CAOjB4B,sBAAuB,CACrBC,SAAU,CAAA,CADW,CAErBC,aAAc,CAAA,CAFO,CAGrB9B,MAAOA,QAAS,EAAG,CACjB,MAAOtB,WADU,CAHE,CAPN,CAcjBS,gBAAiB,CACfL,GAAG,EAAG,CACJ,MAAOK,gBADH,CADS,CAKfJ,GAAG,CAACgD,EAAD,CAAK,CACN,IAAA,CAAK7C,wBAAL,CAAA,CAAiC6C,EAD3B,CALO,CAdA,CAwBjBC,KAAM,CACJH,SAAU,CAAA,CADN,CAEJC,aAAc,CAAA,CAFV,CAGJ9B,MAAOA,QAAS,CAACjC,MAAD,CAAS,CACvBS,YAAawD,CAAAA,IAAK3C,CAAAA,IAAlB,CAAuB,IAAvB,CAA6BtB,MAA7B,CAEKS,aAAayD,CAAAA,gBAAlB,EAAuCzD,YAAamD,CAAAA,iBAApD,GACE9B,MAAA,CAAO,IAAK0B,CAAAA,UAAZ,CAAwBxD,MAAOwD,CAAAA,UAA/B,CAEA,CADA1B,MAAA,CAAO,IAAKyB,CAAAA,OAAZ,CAAqBvD,MAAOuD,CAAAA,OAA5B,CACA,CAAAzB,MAAA,CAAO,IAAKC,CAAAA,QAAZ;AAAsBzB,MAAO6D,CAAAA,aAAc3B,CAAAA,KAArB,CAA2BxC,MAAO+B,CAAAA,QAAlC,CAAtB,CAHF,CAMA,OAAO,KATgB,CAHrB,CAxBW,CAuCjBS,MAAO,CACLsB,SAAU,CAAA,CADL,CAELC,aAAc,CAAA,CAFT,CAGL9B,MAAOA,QAAS,EAAG,CACjB,MAAMmC,QAAU,IAAI3D,YAAakD,CAAAA,WACjC,OAAOrB,OAAA,CAAO8B,OAAP,CAAgBH,CAAAA,IAAhB,CAAqB,IAArB,CAFU,CAHd,CAvCU,CAoDjBI,iBAAkB,CAChBP,SAAU,CAAA,CADM,CAEhBC,aAAc,CAAA,CAFE,CAGhB9B,MAAOA,QAAS,EAAG,CACjB,IAAIqC,cAAgB,IAAKC,CAAAA,cAEpBD,cAAL,GACEA,aAIA,CAJgB,IAAKC,CAAAA,cAIrB,CAJsC/D,qBAAA,CAAsBC,YAAamD,CAAAA,iBAAb,CAAiCnD,YAAa4D,CAAAA,gBAAb,EAAjC,CAAmE,IAAI/D,MAAOkE,CAAAA,iBAAX,CAA6B,CAC1JC,aAAcnE,MAAOoE,CAAAA,gBADqI,CAA7B,CAAzF,CAElChE,OAFkC,CAItC;AADA4D,aAAcf,CAAAA,OAAQoB,CAAAA,iBACtB,CAD0C,EAC1C,CAAAL,aAAcvC,CAAAA,QAAd,CAAyB,IAAKA,CAAAA,QALhC,CAQA,OAAOuC,cAXU,CAHH,CApDD,CA0EjBM,oBAAqB,CACnBd,SAAU,CAAA,CADS,CAEnBC,aAAc,CAAA,CAFK,CAGnB9B,MAAOA,QAAS,EAAG,CACjB,IAAI4C,iBAAmB,IAAKC,CAAAA,iBAEvBD,iBAAL,GACEA,gBAEA,CAFmB,IAAKC,CAAAA,iBAExB,CAF4CtE,qBAAA,CAAsBC,YAAamD,CAAAA,iBAAb,CAAiCnD,YAAamE,CAAAA,mBAAb,EAAjC,CAAsE,IAAItE,MAAOyE,CAAAA,oBAAvG,CAA+HrE,OAA/H,CAE5C,CADAmE,gBAAiBtB,CAAAA,OAAQyB,CAAAA,oBACzB,CADgD,EAChD,CAAAH,gBAAiB9C,CAAAA,QAAjB,CAA4B,IAAKA,CAAAA,QAHnC,CAMA,OAAO8C,iBATU,CAHA,CA1EJ;AAyFjBI,QAAS,CACPnB,SAAU,CAAA,CADH,CAEPC,aAAc,CAAA,CAFP,CAIP9B,KAAK,EAAG,CACN,MAAM,CACJsC,cADI,CAEJO,iBAFI,CAAA,CAGF,IACAP,eAAJ,EAAoBA,cAAeU,CAAAA,OAAf,EAChBH,kBAAJ,EAAuBA,iBAAkBG,CAAAA,OAAlB,EACvBxE,aAAawE,CAAAA,OAAQ3D,CAAAA,IAArB,CAA0B,IAA1B,CAPM,CAJD,CAzFQ,CAyGnBT,kBAAA,CAAkBF,UAAlB,CAAA,CAAgC0B,eAChC,OAAO,KAAIA,eAzLyC,CA4LtDR,QAASA,eAAc,CAAC,CACtBL,YADsB,CAEtBC,cAFsB,CAAD,CAGpBf,OAHoB,CAGXwE,GAHW,CAGN,CACf,IAAI,CACFC,UADE,CAEFC,eAFE,CAGFC,eAHE,CAIFC,eAJE,CAKFC,YALE,CAMFC,iBANE,CAOFC,iBAPE,CAQFC,sBARE,CASFC,cATE;AAUF3D,WAVE,CAAA,CAWAtB,OACJyE,WAAA,CAAaA,UAAb,EAA2B,EAC3BC,gBAAA,CAAkBA,eAAlB,EAAqC,EACrCC,gBAAA,CAAkBA,eAAlB,EAAqC,EACrCE,aAAA,CAAeA,YAAf,EAA+B,EAC/BC,kBAAA,CAAoBA,iBAApB,EAAyC,EACzCC,kBAAA,CAAoBA,iBAApB,EAAyC,EAEzC,IAAIH,eAAJ,EAAuBK,cAAvB,CACEnE,YAAA,CAAezB,oBAAA,CAAqByB,YAArB,CAGjB,IAAIkE,sBAAJ,EAA8BC,cAA9B,CAKElE,cACA,CADiBA,cAAexB,CAAAA,OAAf,CAAuB,4FAAvB,CAAqH,sDAArH,CACjB;AAAAwB,cAAA,CAAiB1B,oBAAA,CAAqB0B,cAArB,CAIfkE,eAAJ,GACMC,cAKJ,CALUD,cAAA,CAAe,CACvBnE,YADuB,CAEvBC,cAFuB,CAAf,CAKV,CADAD,YACA,CADeoE,cAAIpE,CAAAA,YACnB,CAAAC,cAAA,CAAiBmE,cAAInE,CAAAA,cANvB,CAWA,IAAIiE,sBAAJ,CAA4B,CAC1B,IAAIG,WAAa,EACjBpE,eAAA,CAAiBA,cAAexB,CAAAA,OAAf,CAAuB,mDAAvB,CACjBE,KAAA,EAAS,CACP0F,UAAWC,CAAAA,IAAX,CAAgB3F,KAAhB,CACA,OAAO,EAFA,CADQ,CAKjBsF,kBAAA,CAAoB,GAAGC,sBAAH,KAA8BG,UAAWE,CAAAA,IAAX,CAAgB,IAAhB,CAA9B,KAAwDN,iBAAxD,EAPM,CAWxBzD,WAAJ;CACQgE,OAEN,CAFa,mBAAmBhE,WAAnB,KAEb,CADAmD,UACA,CADaa,OACb,CADoBb,UACpB,CAAAI,YAAA,CAAeS,OAAf,CAAsBT,YAHxB,CAOID,gBAAJ,GAOEH,UAYA,CAZa,GAAGA,UAAH;4BACWD,GADX;IAEbI,eAFa;;CAYb,CAPAF,eAOA,CAPkB;kBACJF,GADI;gBAENA,GAFM;YAGVA,GAHU;uBAICA,GAJD,oBAIwBA,GAJxB,mBAI8CA,GAJ9C,eAIgEA,GAJhE;EAKpBE,eALoB;CAOlB,CAAA5D,YAAA,CAjBeA,wBAAwB0D,GAAxB1D;qBACE0D,GADF1D;iBAEF0D,GAFE1D;EAGjBA,YAHiBA;CAiBavB,CAAAA,OAAb,CAAqB,2BAArB,CAAkD,CAACE,KAAD,CAAQ8F,MAAR,CAAgBC,KAAhB,CAAuBC,OAAvB,CAAA,EACxD,2BAA4BC,CAAAA,IAA5B,CAAiCD,OAAQE,CAAAA,MAAR,CAAe,CAAf,CAAkBH,KAAlB,CAAjC,CAAA,CAA6DD,MAA7D,CAAsE,UAAUA,MAAV,IAAoBf,GAApB,EADhE,CAnBjB,CAyBA1D,aAAA,CAAe8E,oBAAA,CAAqB9E,YAArB,CAAmC0D,GAAnC,CAAwCC,UAAxC,CAAoDC,eAApD,CAAqEC,eAArE,CACf5D,eAAA,CAAiB6E,oBAAA,CAAqB7E,cAArB,CAAqCyD,GAArC,CAA0CK,YAA1C,CAAwDC,iBAAxD,CAA2EC,iBAA3E,CACjB,OAAO,CACLjE,YADK,CAELC,cAFK,CA1FQ,CAgGjB6E,QAASA,qBAAoB,CAACC,UAAD,CAAaC,EAAb,CAAiBC,IAAjB,CAAuBC,KAAvB,CAA8BC,KAA9B,CAAqC,CAChE,GAAID,KAAJ,EAAaC,KAAb,EAAsBF,IAAtB,CACEF,UAGA,CAHaA,UAAWtG,CAAAA,OAAX,CAAmB2G,cAAnB;AAAmC;EAClDH,IADkD;qBAE/BD,EAF+B,MAAnC,CAGb,CAAAD,UAAA,EAAc;;IAEdG,KAFc;kBAGAF,EAHA;IAIdG,KAJc;EAQhB,OAAOJ,WAbyD,CAgBlEM,QAASA,oBAAmB,CAAC3B,GAAD,CAAMjD,KAAN,CAAa,CACvC,MAAe,UAAR,GAAAiD,GAAA,CAAqBxB,IAAAA,EAArB,CAAkD,UAAjB,GAAA,MAAOzB,MAAP,CAA8BA,KAAM6E,CAAAA,QAAN,EAA9B,CAAiD7E,KADlD,CAOzCrB,QAASA,iBAAgB,CAACF,OAAD,CAAU,CAC3BqG,OAAAA,CAAcC,IAAKC,CAAAA,SAAL,CAAevG,OAAf,CAAwBmG,mBAAxB,CACpB,KAAIL,GAAKU,kBAAmBnG,CAAAA,GAAnB,CAAuBgG,OAAvB,CAEC,KAAV,EAAIP,EAAJ,EACEU,kBAAmBlG,CAAAA,GAAnB,CAAuB+F,OAAvB,CAAoCP,EAApC,CAAyC,EAAEW,MAA3C,CAGF,OAAOX,GAR0B,CA3cnCvF,MAAO2B,CAAAA,cAAP,CAAsB9C,OAAtB,CAA+B,YAA/B,CAA6C,CAC3CmC,MAAO,CAAA,CADoC,CAA7C,CAGAnC,QAAQU,CAAAA,qBAAR,CAAgCA,qBAChCV,QAAQC,CAAAA,oBAAR,CAA+BA,oBAC/BD,QAAQsH,CAAAA,qBAAR;AAwfAA,QAA8B,CAACC,MAAD,CAAS,CACrC,IAAIC,UAAY,sDAAhB,CACIvF,SAAWd,MAAOC,CAAAA,MAAP,CAAc,IAAd,CADf,CAEIf,KAEJ,KAAA,CAA4C,IAA5C,IAAQA,KAAR,CAAgBmH,SAAUC,CAAAA,IAAV,CAAeF,MAAf,CAAhB,EAAA,CACEtF,QAAA,CAAS5B,KAAA,CAAM,CAAN,CAAT,CAAA,CAAqBA,KAAA,CAAM,CAAN,CAGvB,OAAO4B,SAT8B,CAvfvCjC,QAAQ0H,CAAAA,qBAAR,CA2eAA,QAA8B,CAACC,QAAD,CAAW,CACvC,IAAIC,YAAcC,yBAAA,CAA0BF,QAASG,CAAAA,IAAnC,CAClB,OAAOF,YAAA,CAAcpH,MAAOuH,CAAAA,SAAP,CAAiBH,WAAjB,CAAd,CAA8CD,QAFd,CA1ezC3H,QAAQgI,CAAAA,aAAR,CAygBAA,QAAsB,CAACC,SAAD,CAAYC,SAAA,CAAY,IAAI1H,MAAO2H,CAAAA,OAAnC,CAA8C,CAClC,UAAhC,GAAI,MAAOD,UAAUE,CAAAA,MAArB,CACEF,SAAU/D,CAAAA,IAAV,CAAe8D,SAAf,CAA0BG,CAAAA,MAA1B,EADF;AAGEF,SAAUG,CAAAA,UAAV,CAAqBJ,SAArB,CAGF,OAAOC,UAP2D,CAxgBpElI,QAAQ8G,CAAAA,cAAR,CAAyB9G,OAAQsI,CAAAA,UAAjC,CAA8C,IAAK,EAEnD,KAAI9H,OAASV,OAAA,CAAQ,8CAAR,CAMb,OAAMgH,eAAiB,8BASvB9G,QAAQ8G,CAAAA,cAAR,CAAyBA,cAmBzB,OAAMvD,KAAO,EAEb,KAASgF,MAAT,CAAa,CAAb,CAAoB,GAApB,CAAgBA,MAAhB,CAAyBA,MAAA,EAAzB,CACEhF,IAAA,CAAKgF,MAAL,CAAA,EAAe,EAAJ,CAAAA,MAAA,CAAS,GAAT,CAAe,EAA1B,EAAgCA,MAAEvB,CAAAA,QAAF,CAAW,EAAX,CAelC,OAAMhF,OAASb,MAAOa,CAAAA,MAAhBA,EAA0B,QAAS,EAEzC,CACE,IAAIwG,OAASC,SAAA,CAAU,CAAV,CAEb,KAAK,IAAIF,EAAI,CAAR,CAAWG,IAAMD,SAAUE,CAAAA,MAAhC,CAAwCJ,CAAxC,CAA4CG,GAA5C,CAAiDH,CAAA,EAAjD,CAAsD,CACpD,IAAIrI,OAASuI,SAAA,CAAUF,CAAV,CAEb,IAAIrI,MAAJ,CACE,IAAK,IAAI0I,IAAT,GAAiB1I,OAAjB,CACMA,MAAO2I,CAAAA,cAAP,CAAsBD,IAAtB,CAAJ;CACEJ,MAAA,CAAOI,IAAP,CADF,CACiB1I,MAAA,CAAO0I,IAAP,CADjB,CALgD,CAYtD,MAAOJ,OAfT,CAFA,CAoBMlG,MAAQF,IAAKC,CAAAA,GAAL,EApBd,CAqBMrB,kBAAoB,IAAI8H,OArB9B,CAsBMjH,qBAAuB,IAAIkH,GAGjC,KAAIhG,mBAAqB,IAAzB,CAiXIsE,OAAS,CACb,OAAMD,mBAAqB,IAAI2B,GAA/B,CAeMlB,0BAA4B,CAChCnD,kBAAmB,OADa,CAEhCO,qBAAsB,cAFU,CAGhC+D,mBAAoB,QAHY,CAIhCC,kBAAmB,OAJa,CAKhCC,oBAAqB,SALW,CAMhCC,kBAAmB,OANa,CAOhCC,iBAAkB,MAPc,CAQhCC,qBAAsB,UARU,CAShCC,qBAAsB,UATU,CAUhCC,mBAAoB,QAVY;AAWhCC,kBAAmB,OAXa,CAYhCC,mBAAoB,QAZY,CAahCC,eAAgB,QAbgB,CAchCC,eAAgB,QAdgB,CAehCC,eAAgB,QAfgB,CAiLlC,KAAIC,SAAW,IACf,OAAMC,oBAEN,IAAItJ,MAAO6I,CAAAA,oBAAX,CAAgC,CAC9BU,MAAO,QADuB,CAE9BC,KAAMxJ,MAAOyJ,CAAAA,UAFiB,CAAhC,CAgCA,MAAM3B,WAAN,QAAyB9H,OAAO0J,CAAAA,IAAhC,CACSC,kBAAW,EAAG,CACnB,MAAON,SAAP,GAAoBA,QAApB,CAAiFO,CAAlD,IAAI5J,MAAO6J,CAAAA,sBAAX,CAAkC,CAAlC,CAAqC,CAArC,CAAwC,CAAxC,CAA2C,CAA3C,CAA8C,EAA9C,CAAkDD,EAAAA,SAAlD,CAA4D,CAA5D,CAA+D,EAA/D,CAAoE,CAApE,CAA/B,CADmB,CAIrBvG,WAAW,EAAG,CACZ,KAAA,CAAMyE,UAAW6B,CAAAA,WAAX,EAAN,CAAgCL,mBAAhC,CACA,KAAKQ,CAAAA,MAAL,CAAc,IAAI9J,MAAO+J,CAAAA,OACzB,KAAKC,CAAAA,QAAL;AAAgB,IAAIhK,MAAO+J,CAAAA,OAC3B,KAAKE,CAAAA,QAAL,CAAgB,IAAIjK,MAAO+J,CAAAA,OAC3B,KAAKG,CAAAA,MAAL,CAAc,IAAIlK,MAAO+J,CAAAA,OACzB,KAAKI,CAAAA,MAAL,CAAc,GACd,KAAKC,CAAAA,SAAL,CAAiB,IAAIpK,MAAOqK,CAAAA,OAC5B,KAAKC,CAAAA,UAAL,CAAkB,CAGlB,KAAKC,CAAAA,aAAL,CAAqB,CAAA,CAXT,CAgBV,YAAW,EAAA,CACb,IAAIC,gBAAkB,IAAKC,CAAAA,gBAC3B,OAAMtK,aAAe,IAAKuK,CAAAA,aAApBvK,EAAqC,IAAKwK,CAAAA,gBAA1CxK,GAA+D,IAAKwK,CAAAA,gBAApExK,CAAuFmJ,mBAAoBpH,CAAAA,KAApB,EAAvF/B,CAEDqK,gBAAL,EAAwBA,eAAgBrK,CAAAA,YAAxC,GAAyDA,YAAzD,GACEqK,eAEA,CAFkB,IAAKC,CAAAA,gBAEvB,CA7FGvK,qBAAA,CA2FgEC,YA3FhE,CAAoC,CACzC8B,QAAS,CAAA,CADgC,CAEzCR,SAAU,CACRqI,OAAQ,CACNnI,MAAO,IAAI3B,MAAO+J,CAAAA,OADZ,CADA;AAIRC,SAAU,CACRrI,MAAO,IAAI3B,MAAO+J,CAAAA,OADV,CAJF,CAORE,SAAU,CACRtI,MAAO,IAAI3B,MAAO+J,CAAAA,OADV,CAPF,CAURG,OAAQ,CACNvI,MAAO,IAAI3B,MAAO+J,CAAAA,OADZ,CAVA,CAaRI,OAAQ,CACNxI,MAAO,GADD,CAbA,CAgBRiJ,QAAS,CACPjJ,MAAO,IAAI3B,MAAO+J,CAAAA,OADX,CAhBD,CAF+B,CAuBzClF,WAnGeA,upBA4E0B;AAwBzCG,gBA3EoBA,+mCAmDqB;AAyBzCC,aAjDiBA,mDAwBwB,CA0BzCC,kBA9CsBA,2KAoBmB,CAApC,CA6FH,CAAA/E,YAAa0K,CAAAA,gBAAb,CAA8B,SAA9B,CAAyCC,QAASA,UAAS,EAAG,CAC5D3K,YAAa4K,CAAAA,mBAAb,CAAiC,SAAjC,CAA4CD,SAA5C,CACAN,gBAAgB7F,CAAAA,OAAhB,EAF4D,CAA9D,CAHF,CASA,OAAO6F,gBAbM,CAgBX,YAAQ,CAACrK,YAAD,CAAe,CACzB,IAAKuK,CAAAA,aAAL,CAAqBvK,YADI,CAKvB,uBAAsB,EAAA,CACxB,MAAO,KAAKgH,CAAAA,QAASpD,CAAAA,gBAAd,EADiB,CAItB,0BAAyB,EAAA,CAC3B,MAAO,KAAKoD,CAAAA,QAAS7C,CAAAA,mBAAd,EADoB,CAI7B0G,cAAc,CAACjK,UAAD,CAAa,CACzB,CAAM,CACJ,SAAAU,UADI,CAAN;AAEI,IAAK0F,CAAAA,QAFT,CAGA,OAAM,CACJ2C,MADI,CAEJE,QAFI,CAGJC,QAHI,CAIJC,MAJI,CAKJC,MALI,CAMJC,SANI,CAOJE,UAPI,CAAA,CAQF,IACJ7I,WAASqI,CAAAA,MAAOnI,CAAAA,KAAMgC,CAAAA,IAAtB,CAA2BmG,MAA3B,CACArI,WAASuI,CAAAA,QAASrI,CAAAA,KAAMgC,CAAAA,IAAxB,CAA6BqG,QAA7B,CACAvI,WAASwI,CAAAA,QAAStI,CAAAA,KAAMgC,CAAAA,IAAxB,CAA6BsG,QAA7B,CACAxI,WAASyI,CAAAA,MAAOvI,CAAAA,KAAMgC,CAAAA,IAAtB,CAA2BuG,MAA3B,CACAzI,WAAS0I,CAAAA,MAAOxI,CAAAA,KAAhB,CAAwBwI,MACxB1I,WAASmJ,CAAAA,OAAQjJ,CAAAA,KAAMjB,CAAAA,GAAvB,CAA2B0J,SAAUa,CAAAA,CAArC,CAAwCb,SAAUc,CAAAA,CAAlD,CAAqDZ,UAArD,EAAmE,CAAnE,CAlByB,CAqB3Ba,OAAO,CAACC,SAAD,CAAYC,UAAZ,CAAwB,EAvEjC,CA4EA7L,OAAQsI,CAAAA,UAAR,CAAqBA,UA3vB0G;",
"sources":["node_modules/troika-three-utils/dist/troika-three-utils.esm.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$troika_three_utils$dist$troika_three_utils_esm\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createDerivedMaterial = createDerivedMaterial;\nexports.expandShaderIncludes = expandShaderIncludes;\nexports.getShaderUniformTypes = getShaderUniformTypes;\nexports.getShadersForMaterial = getShadersForMaterial;\nexports.invertMatrix4 = invertMatrix4;\nexports.voidMainRegExp = exports.BezierMesh = void 0;\n\nvar _three = require(\"three\");\n\n/**\n * Regular expression for matching the `void main() {` opener line in GLSL.\n * @type {RegExp}\n */\nconst voidMainRegExp = /\\bvoid\\s+main\\s*\\(\\s*\\)\\s*{/g;\n/**\n * Recursively expands all `#include <xyz>` statements within string of shader code.\n * Copied from three's WebGLProgram#parseIncludes for external use.\n *\n * @param {string} source - The GLSL source code to evaluate\n * @return {string} The GLSL code with all includes expanded\n */\n\nexports.voidMainRegExp = voidMainRegExp;\n\nfunction expandShaderIncludes(source) {\n  const pattern = /^[ \\t]*#include +<([\\w\\d./]+)>/gm;\n\n  function replace(match, include) {\n    let chunk = _three.ShaderChunk[include];\n    return chunk ? expandShaderIncludes(chunk) : match;\n  }\n\n  return source.replace(pattern, replace);\n}\n/*\n * This is a direct copy of MathUtils.generateUUID from Three.js, to preserve compatibility with three\n * versions before 0.113.0 as it was changed from Math to MathUtils in that version.\n * https://github.com/mrdoob/three.js/blob/dd8b5aa3b270c17096b90945cd2d6d1b13aaec53/src/math/MathUtils.js#L16\n */\n\n\nconst _lut = [];\n\nfor (let i = 0; i < 256; i++) {\n  _lut[i] = (i < 16 ? '0' : '') + i.toString(16);\n}\n\nfunction generateUUID() {\n  // http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136\n  const d0 = Math.random() * 0xffffffff | 0;\n  const d1 = Math.random() * 0xffffffff | 0;\n  const d2 = Math.random() * 0xffffffff | 0;\n  const d3 = Math.random() * 0xffffffff | 0;\n  const uuid = _lut[d0 & 0xff] + _lut[d0 >> 8 & 0xff] + _lut[d0 >> 16 & 0xff] + _lut[d0 >> 24 & 0xff] + '-' + _lut[d1 & 0xff] + _lut[d1 >> 8 & 0xff] + '-' + _lut[d1 >> 16 & 0x0f | 0x40] + _lut[d1 >> 24 & 0xff] + '-' + _lut[d2 & 0x3f | 0x80] + _lut[d2 >> 8 & 0xff] + '-' + _lut[d2 >> 16 & 0xff] + _lut[d2 >> 24 & 0xff] + _lut[d3 & 0xff] + _lut[d3 >> 8 & 0xff] + _lut[d3 >> 16 & 0xff] + _lut[d3 >> 24 & 0xff]; // .toUpperCase() here flattens concatenated strings to save heap memory space.\n\n  return uuid.toUpperCase();\n} // Local assign polyfill to avoid importing troika-core\n\n\nconst assign = Object.assign || function ()\n/*target, ...sources*/\n{\n  let target = arguments[0];\n\n  for (let i = 1, len = arguments.length; i < len; i++) {\n    let source = arguments[i];\n\n    if (source) {\n      for (let prop in source) {\n        if (source.hasOwnProperty(prop)) {\n          target[prop] = source[prop];\n        }\n      }\n    }\n  }\n\n  return target;\n};\n\nconst epoch = Date.now();\nconst CONSTRUCTOR_CACHE = new WeakMap();\nconst SHADER_UPGRADE_CACHE = new Map(); // Material ids must be integers, but we can't access the increment from Three's `Material` module,\n// so let's choose a sufficiently large starting value that should theoretically never collide.\n\nlet materialInstanceId = 1e10;\n/**\n * A utility for creating a custom shader material derived from another material's\n * shaders. This allows you to inject custom shader logic and transforms into the\n * builtin ThreeJS materials without having to recreate them from scratch.\n *\n * @param {THREE.Material} baseMaterial - the original material to derive from\n *\n * @param {Object} options - How the base material should be modified.\n * @param {Object} options.defines - Custom `defines` for the material\n * @param {Object} options.extensions - Custom `extensions` for the material, e.g. `{derivatives: true}`\n * @param {Object} options.uniforms - Custom `uniforms` for use in the modified shader. These can\n *        be accessed and manipulated via the resulting material's `uniforms` property, just like\n *        in a ShaderMaterial. You do not need to repeat the base material's own uniforms here.\n * @param {String} options.timeUniform - If specified, a uniform of this name will be injected into\n *        both shaders, and it will automatically be updated on each render frame with a number of\n *        elapsed milliseconds. The \"zero\" epoch time is not significant so don't rely on this as a\n *        true calendar time.\n * @param {String} options.vertexDefs - Custom GLSL code to inject into the vertex shader's top-level\n *        definitions, above the `void main()` function.\n * @param {String} options.vertexMainIntro - Custom GLSL code to inject at the top of the vertex\n *        shader's `void main` function.\n * @param {String} options.vertexMainOutro - Custom GLSL code to inject at the end of the vertex\n *        shader's `void main` function.\n * @param {String} options.vertexTransform - Custom GLSL code to manipulate the `position`, `normal`,\n *        and/or `uv` vertex attributes. This code will be wrapped within a standalone function with\n *        those attributes exposed by their normal names as read/write values.\n * @param {String} options.fragmentDefs - Custom GLSL code to inject into the fragment shader's top-level\n *        definitions, above the `void main()` function.\n * @param {String} options.fragmentMainIntro - Custom GLSL code to inject at the top of the fragment\n *        shader's `void main` function.\n * @param {String} options.fragmentMainOutro - Custom GLSL code to inject at the end of the fragment\n *        shader's `void main` function. You can manipulate `gl_FragColor` here but keep in mind it goes\n *        after any of ThreeJS's color postprocessing shader chunks (tonemapping, fog, etc.), so if you\n *        want those to apply to your changes use `fragmentColorTransform` instead.\n * @param {String} options.fragmentColorTransform - Custom GLSL code to manipulate the `gl_FragColor`\n *        output value. Will be injected near the end of the `void main` function, but before any\n *        of ThreeJS's color postprocessing shader chunks (tonemapping, fog, etc.), and before the\n *        `fragmentMainOutro`.\n * @param {function<{vertexShader,fragmentShader}>:{vertexShader,fragmentShader}} options.customRewriter - A function\n *        for performing custom rewrites of the full shader code. Useful if you need to do something\n *        special that's not covered by the other builtin options. This function will be executed before\n *        any other transforms are applied.\n * @param {boolean} options.chained - Set to `true` to prototype-chain the derived material to the base\n *        material, rather than the default behavior of copying it. This allows the derived material to\n *        automatically pick up changes made to the base material and its properties. This can be useful\n *        where the derived material is hidden from the user as an implementation detail, allowing them\n *        to work with the original material like normal. But it can result in unexpected behavior if not\n *        handled carefully.\n *\n * @return {THREE.Material}\n *\n * The returned material will also have two new methods, `getDepthMaterial()` and `getDistanceMaterial()`,\n * which can be called to get a variant of the derived material for use in shadow casting. If the\n * target mesh is expected to cast shadows, then you can assign these to the mesh's `customDepthMaterial`\n * (for directional and spot lights) and/or `customDistanceMaterial` (for point lights) properties to\n * allow the cast shadow to honor your derived shader's vertex transforms and discarded fragments. These\n * will also set a custom `#define IS_DEPTH_MATERIAL` or `#define IS_DISTANCE_MATERIAL` that you can look\n * for in your derived shaders with `#ifdef` to customize their behavior for the depth or distance\n * scenarios, e.g. skipping antialiasing or expensive shader logic.\n */\n\nfunction createDerivedMaterial(baseMaterial, options) {\n  // Generate a key that is unique to the content of these `options`. We'll use this\n  // throughout for caching and for generating the upgraded shader code. This increases\n  // the likelihood that the resulting shaders will line up across multiple calls so\n  // their GL programs can be shared and cached.\n  const optionsKey = getKeyForOptions(options); // First check to see if we've already derived from this baseMaterial using this\n  // unique set of options, and if so reuse the constructor to avoid some allocations.\n\n  let ctorsByDerivation = CONSTRUCTOR_CACHE.get(baseMaterial);\n\n  if (!ctorsByDerivation) {\n    CONSTRUCTOR_CACHE.set(baseMaterial, ctorsByDerivation = Object.create(null));\n  }\n\n  if (ctorsByDerivation[optionsKey]) {\n    return new ctorsByDerivation[optionsKey]();\n  }\n\n  const privateBeforeCompileProp = `_onBeforeCompile${optionsKey}`; // Private onBeforeCompile handler that injects the modified shaders and uniforms when\n  // the renderer switches to this material's program\n\n  const onBeforeCompile = function (shaderInfo) {\n    baseMaterial.onBeforeCompile.call(this, shaderInfo); // Upgrade the shaders, caching the result by incoming source code\n\n    const cacheKey = optionsKey + '|||' + shaderInfo.vertexShader + '|||' + shaderInfo.fragmentShader;\n    let upgradedShaders = SHADER_UPGRADE_CACHE[cacheKey];\n\n    if (!upgradedShaders) {\n      const upgraded = upgradeShaders(shaderInfo, options, optionsKey);\n      upgradedShaders = SHADER_UPGRADE_CACHE[cacheKey] = upgraded;\n    } // Inject upgraded shaders and uniforms into the program\n\n\n    shaderInfo.vertexShader = upgradedShaders.vertexShader;\n    shaderInfo.fragmentShader = upgradedShaders.fragmentShader;\n    assign(shaderInfo.uniforms, this.uniforms); // Inject auto-updating time uniform if requested\n\n    if (options.timeUniform) {\n      shaderInfo.uniforms[options.timeUniform] = {\n        get value() {\n          return Date.now() - epoch;\n        }\n\n      };\n    } // Users can still add their own handlers on top of ours\n\n\n    if (this[privateBeforeCompileProp]) {\n      this[privateBeforeCompileProp](shaderInfo);\n    }\n  };\n\n  const DerivedMaterial = function DerivedMaterial() {\n    return derive(options.chained ? baseMaterial : baseMaterial.clone());\n  };\n\n  const derive = function (base) {\n    // Prototype chain to the base material\n    const derived = Object.create(base, descriptor); // Store the baseMaterial for reference; this is always the original even when cloning\n\n    Object.defineProperty(derived, 'baseMaterial', {\n      value: baseMaterial\n    }); // Needs its own ids\n\n    Object.defineProperty(derived, 'id', {\n      value: materialInstanceId++\n    });\n    derived.uuid = generateUUID(); // Merge uniforms, defines, and extensions\n\n    derived.uniforms = assign({}, base.uniforms, options.uniforms);\n    derived.defines = assign({}, base.defines, options.defines);\n    derived.defines[`TROIKA_DERIVED_MATERIAL_${optionsKey}`] = ''; //force a program change from the base material\n\n    derived.extensions = assign({}, base.extensions, options.extensions); // Don't inherit EventDispatcher listeners\n\n    derived._listeners = undefined;\n    return derived;\n  };\n\n  const descriptor = {\n    constructor: {\n      value: DerivedMaterial\n    },\n    isDerivedMaterial: {\n      value: true\n    },\n    customProgramCacheKey: {\n      writable: true,\n      configurable: true,\n      value: function () {\n        return optionsKey;\n      }\n    },\n    onBeforeCompile: {\n      get() {\n        return onBeforeCompile;\n      },\n\n      set(fn) {\n        this[privateBeforeCompileProp] = fn;\n      }\n\n    },\n    copy: {\n      writable: true,\n      configurable: true,\n      value: function (source) {\n        baseMaterial.copy.call(this, source);\n\n        if (!baseMaterial.isShaderMaterial && !baseMaterial.isDerivedMaterial) {\n          assign(this.extensions, source.extensions);\n          assign(this.defines, source.defines);\n          assign(this.uniforms, _three.UniformsUtils.clone(source.uniforms));\n        }\n\n        return this;\n      }\n    },\n    clone: {\n      writable: true,\n      configurable: true,\n      value: function () {\n        const newBase = new baseMaterial.constructor();\n        return derive(newBase).copy(this);\n      }\n    },\n\n    /**\n     * Utility to get a MeshDepthMaterial that will honor this derived material's vertex\n     * transformations and discarded fragments.\n     */\n    getDepthMaterial: {\n      writable: true,\n      configurable: true,\n      value: function () {\n        let depthMaterial = this._depthMaterial;\n\n        if (!depthMaterial) {\n          depthMaterial = this._depthMaterial = createDerivedMaterial(baseMaterial.isDerivedMaterial ? baseMaterial.getDepthMaterial() : new _three.MeshDepthMaterial({\n            depthPacking: _three.RGBADepthPacking\n          }), options);\n          depthMaterial.defines.IS_DEPTH_MATERIAL = '';\n          depthMaterial.uniforms = this.uniforms; //automatically recieve same uniform values\n        }\n\n        return depthMaterial;\n      }\n    },\n\n    /**\n     * Utility to get a MeshDistanceMaterial that will honor this derived material's vertex\n     * transformations and discarded fragments.\n     */\n    getDistanceMaterial: {\n      writable: true,\n      configurable: true,\n      value: function () {\n        let distanceMaterial = this._distanceMaterial;\n\n        if (!distanceMaterial) {\n          distanceMaterial = this._distanceMaterial = createDerivedMaterial(baseMaterial.isDerivedMaterial ? baseMaterial.getDistanceMaterial() : new _three.MeshDistanceMaterial(), options);\n          distanceMaterial.defines.IS_DISTANCE_MATERIAL = '';\n          distanceMaterial.uniforms = this.uniforms; //automatically recieve same uniform values\n        }\n\n        return distanceMaterial;\n      }\n    },\n    dispose: {\n      writable: true,\n      configurable: true,\n\n      value() {\n        const {\n          _depthMaterial,\n          _distanceMaterial\n        } = this;\n        if (_depthMaterial) _depthMaterial.dispose();\n        if (_distanceMaterial) _distanceMaterial.dispose();\n        baseMaterial.dispose.call(this);\n      }\n\n    }\n  };\n  ctorsByDerivation[optionsKey] = DerivedMaterial;\n  return new DerivedMaterial();\n}\n\nfunction upgradeShaders({\n  vertexShader,\n  fragmentShader\n}, options, key) {\n  let {\n    vertexDefs,\n    vertexMainIntro,\n    vertexMainOutro,\n    vertexTransform,\n    fragmentDefs,\n    fragmentMainIntro,\n    fragmentMainOutro,\n    fragmentColorTransform,\n    customRewriter,\n    timeUniform\n  } = options;\n  vertexDefs = vertexDefs || '';\n  vertexMainIntro = vertexMainIntro || '';\n  vertexMainOutro = vertexMainOutro || '';\n  fragmentDefs = fragmentDefs || '';\n  fragmentMainIntro = fragmentMainIntro || '';\n  fragmentMainOutro = fragmentMainOutro || ''; // Expand includes if needed\n\n  if (vertexTransform || customRewriter) {\n    vertexShader = expandShaderIncludes(vertexShader);\n  }\n\n  if (fragmentColorTransform || customRewriter) {\n    // We need to be able to find postprocessing chunks after include expansion in order to\n    // put them after the fragmentColorTransform, so mark them with comments first. Even if\n    // this particular derivation doesn't have a fragmentColorTransform, other derivations may,\n    // so we still mark them.\n    fragmentShader = fragmentShader.replace(/^[ \\t]*#include <((?:tonemapping|encodings|fog|premultiplied_alpha|dithering)_fragment)>/gm, '\\n//!BEGIN_POST_CHUNK $1\\n$&\\n//!END_POST_CHUNK\\n');\n    fragmentShader = expandShaderIncludes(fragmentShader);\n  } // Apply custom rewriter function\n\n\n  if (customRewriter) {\n    let res = customRewriter({\n      vertexShader,\n      fragmentShader\n    });\n    vertexShader = res.vertexShader;\n    fragmentShader = res.fragmentShader;\n  } // The fragmentColorTransform needs to go before any postprocessing chunks, so extract\n  // those and re-insert them into the outro in the correct place:\n\n\n  if (fragmentColorTransform) {\n    let postChunks = [];\n    fragmentShader = fragmentShader.replace(/^\\/\\/!BEGIN_POST_CHUNK[^]+?^\\/\\/!END_POST_CHUNK/gm, // [^]+? = non-greedy match of any chars including newlines\n    match => {\n      postChunks.push(match);\n      return '';\n    });\n    fragmentMainOutro = `${fragmentColorTransform}\\n${postChunks.join('\\n')}\\n${fragmentMainOutro}`;\n  } // Inject auto-updating time uniform if requested\n\n\n  if (timeUniform) {\n    const code = `\\nuniform float ${timeUniform};\\n`;\n    vertexDefs = code + vertexDefs;\n    fragmentDefs = code + fragmentDefs;\n  } // Inject a function for the vertexTransform and rename all usages of position/normal/uv\n\n\n  if (vertexTransform) {\n    // Hoist these defs to the very top so they work in other function defs\n    vertexShader = `vec3 troika_position_${key};\nvec3 troika_normal_${key};\nvec2 troika_uv_${key};\n${vertexShader}\n`;\n    vertexDefs = `${vertexDefs}\nvoid troikaVertexTransform${key}(inout vec3 position, inout vec3 normal, inout vec2 uv) {\n  ${vertexTransform}\n}\n`;\n    vertexMainIntro = `\ntroika_position_${key} = vec3(position);\ntroika_normal_${key} = vec3(normal);\ntroika_uv_${key} = vec2(uv);\ntroikaVertexTransform${key}(troika_position_${key}, troika_normal_${key}, troika_uv_${key});\n${vertexMainIntro}\n`;\n    vertexShader = vertexShader.replace(/\\b(position|normal|uv)\\b/g, (match, match1, index, fullStr) => {\n      return /\\battribute\\s+vec[23]\\s+$/.test(fullStr.substr(0, index)) ? match1 : `troika_${match1}_${key}`;\n    });\n  } // Inject defs and intro/outro snippets\n\n\n  vertexShader = injectIntoShaderCode(vertexShader, key, vertexDefs, vertexMainIntro, vertexMainOutro);\n  fragmentShader = injectIntoShaderCode(fragmentShader, key, fragmentDefs, fragmentMainIntro, fragmentMainOutro);\n  return {\n    vertexShader,\n    fragmentShader\n  };\n}\n\nfunction injectIntoShaderCode(shaderCode, id, defs, intro, outro) {\n  if (intro || outro || defs) {\n    shaderCode = shaderCode.replace(voidMainRegExp, `\n${defs}\nvoid troikaOrigMain${id}() {`);\n    shaderCode += `\nvoid main() {\n  ${intro}\n  troikaOrigMain${id}();\n  ${outro}\n}`;\n  }\n\n  return shaderCode;\n}\n\nfunction optionsJsonReplacer(key, value) {\n  return key === 'uniforms' ? undefined : typeof value === 'function' ? value.toString() : value;\n}\n\nlet _idCtr = 0;\nconst optionsHashesToIds = new Map();\n\nfunction getKeyForOptions(options) {\n  const optionsHash = JSON.stringify(options, optionsJsonReplacer);\n  let id = optionsHashesToIds.get(optionsHash);\n\n  if (id == null) {\n    optionsHashesToIds.set(optionsHash, id = ++_idCtr);\n  }\n\n  return id;\n} // Copied from threejs WebGLPrograms.js so we can resolve builtin materials to their shaders\n// TODO how can we keep this from getting stale?\n\n\nconst MATERIAL_TYPES_TO_SHADERS = {\n  MeshDepthMaterial: 'depth',\n  MeshDistanceMaterial: 'distanceRGBA',\n  MeshNormalMaterial: 'normal',\n  MeshBasicMaterial: 'basic',\n  MeshLambertMaterial: 'lambert',\n  MeshPhongMaterial: 'phong',\n  MeshToonMaterial: 'toon',\n  MeshStandardMaterial: 'physical',\n  MeshPhysicalMaterial: 'physical',\n  MeshMatcapMaterial: 'matcap',\n  LineBasicMaterial: 'basic',\n  LineDashedMaterial: 'dashed',\n  PointsMaterial: 'points',\n  ShadowMaterial: 'shadow',\n  SpriteMaterial: 'sprite'\n};\n/**\n * Given a Three.js `Material` instance, find the shaders/uniforms that will be\n * used to render that material.\n *\n * @param material - the Material instance\n * @return {object} - the material's shader info: `{uniforms:{}, fragmentShader:'', vertexShader:''}`\n */\n\nfunction getShadersForMaterial(material) {\n  let builtinType = MATERIAL_TYPES_TO_SHADERS[material.type];\n  return builtinType ? _three.ShaderLib[builtinType] : material; //TODO fallback for unknown type?\n}\n/**\n * Find all uniforms and their types within a shader code string.\n *\n * @param {string} shader - The shader code to parse\n * @return {object} mapping of uniform names to their glsl type\n */\n\n\nfunction getShaderUniformTypes(shader) {\n  let uniformRE = /\\buniform\\s+(int|float|vec[234])\\s+([A-Za-z_][\\w]*)/g;\n  let uniforms = Object.create(null);\n  let match;\n\n  while ((match = uniformRE.exec(shader)) !== null) {\n    uniforms[match[2]] = match[1];\n  }\n\n  return uniforms;\n}\n/**\n * Helper for smoothing out the `m.getInverse(x)` --\u003e `m.copy(x).invert()` conversion\n * that happened in ThreeJS r123.\n * @param {Matrix4} srcMatrix\n * @param {Matrix4} [tgtMatrix]\n */\n\n\nfunction invertMatrix4(srcMatrix, tgtMatrix = new _three.Matrix4()) {\n  if (typeof tgtMatrix.invert === 'function') {\n    tgtMatrix.copy(srcMatrix).invert();\n  } else {\n    tgtMatrix.getInverse(srcMatrix);\n  }\n\n  return tgtMatrix;\n}\n/*\nInput geometry is a cylinder with r=1, height in y dimension from 0 to 1,\ndivided into a reasonable number of height segments.\n*/\n\n\nconst vertexDefs = `\nuniform vec3 pointA;\nuniform vec3 controlA;\nuniform vec3 controlB;\nuniform vec3 pointB;\nuniform float radius;\nvarying float bezierT;\n\nvec3 cubicBezier(vec3 p1, vec3 c1, vec3 c2, vec3 p2, float t) {\n  float t2 = 1.0 - t;\n  float b0 = t2 * t2 * t2;\n  float b1 = 3.0 * t * t2 * t2;\n  float b2 = 3.0 * t * t * t2;\n  float b3 = t * t * t;\n  return b0 * p1 + b1 * c1 + b2 * c2 + b3 * p2;\n}\n\nvec3 cubicBezierDerivative(vec3 p1, vec3 c1, vec3 c2, vec3 p2, float t) {\n  float t2 = 1.0 - t;\n  return -3.0 * p1 * t2 * t2 +\n    c1 * (3.0 * t2 * t2 - 6.0 * t2 * t) +\n    c2 * (6.0 * t2 * t - 3.0 * t * t) +\n    3.0 * p2 * t * t;\n}\n`;\nconst vertexTransform = `\nfloat t = position.y;\nbezierT = t;\nvec3 bezierCenterPos = cubicBezier(pointA, controlA, controlB, pointB, t);\nvec3 bezierDir = normalize(cubicBezierDerivative(pointA, controlA, controlB, pointB, t));\n\n// Make \"sideways\" always perpendicular to the camera ray; this ensures that any twists\n// in the cylinder occur where you won't see them: \nvec3 viewDirection = normalMatrix * vec3(0.0, 0.0, 1.0);\nif (bezierDir == viewDirection) {\n  bezierDir = normalize(cubicBezierDerivative(pointA, controlA, controlB, pointB, t == 1.0 ? t - 0.0001 : t + 0.0001));\n}\nvec3 sideways = normalize(cross(bezierDir, viewDirection));\nvec3 upish = normalize(cross(sideways, bezierDir));\n\n// Build a matrix for transforming this disc in the cylinder:\nmat4 discTx;\ndiscTx[0].xyz = sideways * radius;\ndiscTx[1].xyz = bezierDir * radius;\ndiscTx[2].xyz = upish * radius;\ndiscTx[3].xyz = bezierCenterPos;\ndiscTx[3][3] = 1.0;\n\n// Apply transform, ignoring original y\nposition = (discTx * vec4(position.x, 0.0, position.z, 1.0)).xyz;\nnormal = normalize(mat3(discTx) * normal);\n`;\nconst fragmentDefs = `\nuniform vec3 dashing;\nvarying float bezierT;\n`;\nconst fragmentMainIntro = `\nif (dashing.x + dashing.y > 0.0) {\n  float dashFrac = mod(bezierT - dashing.z, dashing.x + dashing.y);\n  if (dashFrac > dashing.x) {\n    discard;\n  }\n}\n`; // Debugging: separate color for each of the 6 sides:\n// const fragmentColorTransform = `\n// float sideNum = floor(vUV.x * 6.0);\n// vec3 mixColor = sideNum < 1.0 ? vec3(1.0, 0.0, 0.0) :\n//   sideNum < 2.0 ? vec3(0.0, 1.0, 1.0) :\n//   sideNum < 3.0 ? vec3(1.0, 1.0, 0.0) :\n//   sideNum < 4.0 ? vec3(0.0, 0.0, 1.0) :\n//   sideNum < 5.0 ? vec3(0.0, 1.0, 0.0) :\n//   vec3(1.0, 0.0, 1.0);\n// gl_FragColor.xyz = mix(gl_FragColor.xyz, mixColor, 0.5);\n// `\n\nfunction createBezierMeshMaterial(baseMaterial) {\n  return createDerivedMaterial(baseMaterial, {\n    chained: true,\n    uniforms: {\n      pointA: {\n        value: new _three.Vector3()\n      },\n      controlA: {\n        value: new _three.Vector3()\n      },\n      controlB: {\n        value: new _three.Vector3()\n      },\n      pointB: {\n        value: new _three.Vector3()\n      },\n      radius: {\n        value: 0.01\n      },\n      dashing: {\n        value: new _three.Vector3()\n      } //on, off, offset\n\n    },\n    vertexDefs,\n    vertexTransform,\n    fragmentDefs,\n    fragmentMainIntro\n  });\n}\n\nlet geometry = null;\nconst defaultBaseMaterial =\n/*#__PURE__*/\nnew _three.MeshStandardMaterial({\n  color: 0xffffff,\n  side: _three.DoubleSide\n});\n/**\n * A ThreeJS `Mesh` that bends a tube shape along a 3D cubic bezier path. The bending is done\n * by deforming a straight cylindrical geometry in the vertex shader based on a set of four\n * control point uniforms. It patches the necessary GLSL into the mesh's assigned `material`\n * automatically.\n *\n * The cubiz bezier path is determined by its four `Vector3` properties:\n * - `pointA`\n * - `controlA`\n * - `controlB`\n * - `pointB`\n *\n * The tube's radius is controlled by its `radius` property, which defaults to `0.01`.\n *\n * You can also give the tube a dashed appearance with two properties:\n *\n * - `dashArray` - an array of two numbers, defining the length of \"on\" and \"off\" parts of\n *   the dash. Each is a 0-1 ratio of the entire path's length. (Actually this is the `t` length\n *   used as input to the cubic bezier function, not its visible length.)\n * - `dashOffset` - offset of where the dash starts. You can animate this to make the dashes move.\n *\n * Note that the dashes will appear like a hollow tube, not solid. This will be more apparent on\n * thicker tubes.\n *\n * TODO: proper geometry bounding sphere and raycasting\n * TODO: allow control of the geometry's segment counts\n */\n\nclass BezierMesh extends _three.Mesh {\n  static getGeometry() {\n    return geometry || (geometry = new _three.CylinderBufferGeometry(1, 1, 1, 6, 64).translate(0, 0.5, 0));\n  }\n\n  constructor() {\n    super(BezierMesh.getGeometry(), defaultBaseMaterial);\n    this.pointA = new _three.Vector3();\n    this.controlA = new _three.Vector3();\n    this.controlB = new _three.Vector3();\n    this.pointB = new _three.Vector3();\n    this.radius = 0.01;\n    this.dashArray = new _three.Vector2();\n    this.dashOffset = 0; // TODO - disabling frustum culling until I figure out how to customize the\n    //  geometry's bounding sphere that gets used\n\n    this.frustumCulled = false;\n  } // Handler for automatically wrapping the base material with our upgrades. We do the wrapping\n  // lazily on _read_ rather than write to avoid unnecessary wrapping on transient values.\n\n\n  get material() {\n    let derivedMaterial = this._derivedMaterial;\n    const baseMaterial = this._baseMaterial || this._defaultMaterial || (this._defaultMaterial = defaultBaseMaterial.clone());\n\n    if (!derivedMaterial || derivedMaterial.baseMaterial !== baseMaterial) {\n      derivedMaterial = this._derivedMaterial = createBezierMeshMaterial(baseMaterial); // dispose the derived material when its base material is disposed:\n\n      baseMaterial.addEventListener('dispose', function onDispose() {\n        baseMaterial.removeEventListener('dispose', onDispose);\n        derivedMaterial.dispose();\n      });\n    }\n\n    return derivedMaterial;\n  }\n\n  set material(baseMaterial) {\n    this._baseMaterial = baseMaterial;\n  } // Create and update material for shadows upon request:\n\n\n  get customDepthMaterial() {\n    return this.material.getDepthMaterial();\n  }\n\n  get customDistanceMaterial() {\n    return this.material.getDistanceMaterial();\n  }\n\n  onBeforeRender(shaderInfo) {\n    const {\n      uniforms\n    } = this.material;\n    const {\n      pointA,\n      controlA,\n      controlB,\n      pointB,\n      radius,\n      dashArray,\n      dashOffset\n    } = this;\n    uniforms.pointA.value.copy(pointA);\n    uniforms.controlA.value.copy(controlA);\n    uniforms.controlB.value.copy(controlB);\n    uniforms.pointB.value.copy(pointB);\n    uniforms.radius.value = radius;\n    uniforms.dashing.value.set(dashArray.x, dashArray.y, dashOffset || 0);\n  }\n\n  raycast(raycaster, intersects) {// TODO - just fail for now\n  }\n\n}\n\nexports.BezierMesh = BezierMesh;\n};"],
"names":["shadow$provide","global","require","module","exports","expandShaderIncludes","source","replace","pattern","match","include","chunk","_three","ShaderChunk","createDerivedMaterial","baseMaterial","options","optionsKey","getKeyForOptions","ctorsByDerivation","CONSTRUCTOR_CACHE","get","set","Object","create","privateBeforeCompileProp","onBeforeCompile","shaderInfo","call","cacheKey","vertexShader","fragmentShader","upgradedShaders","SHADER_UPGRADE_CACHE","upgraded","upgradeShaders","assign","uniforms","timeUniform","value","Date","now","epoch","DerivedMaterial","derive","chained","clone","base","derived","descriptor","defineProperty","materialInstanceId","d0","Math","random","d1","d2","d3","toUpperCase","_lut","uuid","defines","extensions","_listeners","undefined","constructor","isDerivedMaterial","customProgramCacheKey","writable","configurable","fn","copy","isShaderMaterial","UniformsUtils","newBase","getDepthMaterial","depthMaterial","_depthMaterial","MeshDepthMaterial","depthPacking","RGBADepthPacking","IS_DEPTH_MATERIAL","getDistanceMaterial","distanceMaterial","_distanceMaterial","MeshDistanceMaterial","IS_DISTANCE_MATERIAL","dispose","key","vertexDefs","vertexMainIntro","vertexMainOutro","vertexTransform","fragmentDefs","fragmentMainIntro","fragmentMainOutro","fragmentColorTransform","customRewriter","res","postChunks","push","join","code","match1","index","fullStr","test","substr","injectIntoShaderCode","shaderCode","id","defs","intro","outro","voidMainRegExp","optionsJsonReplacer","toString","optionsHash","JSON","stringify","optionsHashesToIds","_idCtr","getShaderUniformTypes","shader","uniformRE","exec","getShadersForMaterial","material","builtinType","MATERIAL_TYPES_TO_SHADERS","type","ShaderLib","invertMatrix4","srcMatrix","tgtMatrix","Matrix4","invert","getInverse","BezierMesh","i","target","arguments","len","length","prop","hasOwnProperty","WeakMap","Map","MeshNormalMaterial","MeshBasicMaterial","MeshLambertMaterial","MeshPhongMaterial","MeshToonMaterial","MeshStandardMaterial","MeshPhysicalMaterial","MeshMatcapMaterial","LineBasicMaterial","LineDashedMaterial","PointsMaterial","ShadowMaterial","SpriteMaterial","geometry","defaultBaseMaterial","color","side","DoubleSide","Mesh","getGeometry","translate","CylinderBufferGeometry","pointA","Vector3","controlA","controlB","pointB","radius","dashArray","Vector2","dashOffset","frustumCulled","derivedMaterial","_derivedMaterial","_baseMaterial","_defaultMaterial","dashing","addEventListener","onDispose","removeEventListener","onBeforeRender","x","y","raycast","raycaster","intersects"]
}
