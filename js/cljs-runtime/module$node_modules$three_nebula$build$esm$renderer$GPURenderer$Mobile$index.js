shadow$provide.module$node_modules$three_nebula$build$esm$renderer$GPURenderer$Mobile$index=function(global,require,module,exports){function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj}}function ownKeys(object,enumerableOnly){var keys=Object.keys(object);if(Object.getOwnPropertySymbols){var symbols=Object.getOwnPropertySymbols(object);enumerableOnly&&(symbols=symbols.filter(function(sym){return Object.getOwnPropertyDescriptor(object,sym).enumerable}));keys.push.apply(keys,
symbols)}return keys}function _objectSpread(target){for(var i=1;i<arguments.length;i++){var source=null!=arguments[i]?arguments[i]:{};i%2?ownKeys(Object(source),!0).forEach(function(key){(0,_defineProperty2.default)(target,key,source[key])}):Object.getOwnPropertyDescriptors?Object.defineProperties(target,Object.getOwnPropertyDescriptors(source)):ownKeys(Object(source)).forEach(function(key){Object.defineProperty(target,key,Object.getOwnPropertyDescriptor(source,key))})}return target}Object.defineProperty(exports,
"__esModule",{value:!0});exports.default=void 0;var _defineProperty2=_interopRequireDefault(require("module$node_modules$$babel$runtime$helpers$defineProperty")),_common=require("module$node_modules$three_nebula$build$esm$renderer$GPURenderer$common$index"),_shaders=require("module$node_modules$three_nebula$build$esm$renderer$GPURenderer$Mobile$shaders$index");global=_interopRequireDefault(require("module$node_modules$three_nebula$build$esm$renderer$BaseRenderer"));var _constants=require("module$node_modules$three_nebula$build$esm$renderer$GPURenderer$common$constants"),
_core=require("module$node_modules$three_nebula$build$esm$core$index"),_types=require("module$node_modules$three_nebula$build$esm$renderer$types");let THREE;class MobileGPURenderer extends global.default{constructor(container,three,options=_constants.DEFAULT_RENDERER_OPTIONS){super(_types.RENDERER_TYPE_GPU_MOBILE);THREE=this.three=three;three=_objectSpread(_objectSpread({},_constants.DEFAULT_RENDERER_OPTIONS),options);const {camera,maxParticles,baseColor,blending,depthTest,depthWrite,transparent,
shouldDebugTextureAtlas}=three;three=new _common.ParticleBuffer(maxParticles,THREE);options=new THREE.ShaderMaterial({uniforms:{baseColor:{value:new THREE.Color(baseColor)},uTexture:{value:null},FFatlasIndex:{value:null},atlasDim:{value:new THREE.Vector2}},vertexShader:(0,_shaders.vertexShader)(),fragmentShader:(0,_shaders.fragmentShader)(),blending:THREE[blending],depthTest,depthWrite,transparent});this.camera=camera;this.targetPool=new _core.Pool;this.uniqueList=new _common.UniqueList(maxParticles);
this.particleBuffer=three;this.buffer=three.buffer;this.stride=three.stride;this.geometry=three.geometry;this.material=options;this.points=new THREE.Points(this.geometry,this.material);this.points.frustumCulled=!1;this.shouldDebugTextureAtlas=shouldDebugTextureAtlas;container.add(this.points)}onSystemUpdate(system){super.onSystemUpdate(system);this.buffer.needsUpdate=!0;({textureAtlas:system}=this);system&&(system.update(),this.material.uniforms.atlasDim.value.set(system.atlasTexture.image.width,
system.atlasTexture.image.height))}onParticleCreated(particle){particle.target||(particle.target=this.targetPool.get(_common.Target,THREE),this.uniqueList.add(particle.id));this.updateTarget(particle).mapParticleTargetPropsToPoint(particle)}onParticleUpdate(particle){particle.target&&this.updateTarget(particle).mapParticleTargetPropsToPoint(particle)}onParticleDead(particle){particle.target&&(particle.target.reset(),this.mapParticleTargetPropsToPoint(particle),particle.target=null)}updateTarget(particle){const {position,
scale,radius,color,alpha,body,id}=particle,{r,g,b}=color;particle.target.position.copy(position);particle.target.size=scale*radius;particle.target.color.setRGB(r,g,b);particle.target.alpha=alpha;particle.target.index=this.uniqueList.find(id);if(body&&body instanceof THREE.Sprite){const {map}=body.material;particle.target.texture=map;particle.target.textureIndex=this.getTextureID(map,this.shouldDebugTextureAtlas)}return this}mapParticleTargetPropsToPoint(particle){this.updatePointPosition(particle).updatePointSize(particle).updatePointColor(particle).updatePointAlpha(particle).updatePointTextureIndex(particle);
return this}updatePointPosition(particle){const {geometry,stride,buffer}=this;({target:particle}=particle);const {offset}=geometry.attributes.position;buffer.array[particle.index*stride+offset+0]=particle.position.x;buffer.array[particle.index*stride+offset+1]=particle.position.y;buffer.array[particle.index*stride+offset+2]=particle.position.z;return this}updatePointSize(particle){const {geometry,stride,buffer}=this;({target:particle}=particle);const {offset}=geometry.attributes.size;buffer.array[particle.index*
stride+offset+0]=particle.size;return this}updatePointColor(particle){const {geometry,stride,buffer}=this;({target:particle}=particle);const {offset}=geometry.attributes.color;buffer.array[particle.index*stride+offset+0]=particle.color.r;buffer.array[particle.index*stride+offset+1]=particle.color.g;buffer.array[particle.index*stride+offset+2]=particle.color.b;return this}updatePointAlpha(particle){const {geometry,stride,buffer}=this;({target:particle}=particle);const {offset}=geometry.attributes.alpha;
buffer.array[particle.index*stride+offset+0]=particle.alpha;return this}updatePointTextureIndex(particle){const {geometry,stride,buffer}=this;var {target}=particle;({offset:particle}=geometry.attributes.texID);particle=target.index*stride+particle+0;var ti=4*target.textureIndex;target=this.textureAtlas;const ida=target.indexData,nx=ida[ti++],ny=ida[ti++],px=ida[ti++];ti=ida[ti++];buffer.array[particle]=(nx*target.atlasTexture.image.width|0)+px;buffer.array[particle+1]=(ny*target.atlasTexture.image.height|
0)+ti;return this}getTextureID(texture,debug){void 0===texture.textureIndex&&(this.textureAtlas||(this.textureAtlas=new _common.TextureAtlas(this,debug)),this.textureAtlas.addTexture(texture));return texture.textureIndex}destroy(){const {container,points,textureAtlas,uniqueList}=this;container.remove(points);uniqueList.destroy();textureAtlas&&textureAtlas.destroy()}}exports.default=MobileGPURenderer}
//# sourceMappingURL=module$node_modules$three_nebula$build$esm$renderer$GPURenderer$Mobile$index.js.map
